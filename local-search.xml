<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计组上机考试后的一些小思考</title>
    <link href="/2020/12/20/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/"/>
    <url>/2020/12/20/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1>计组上机考试后的一些小思考</h1><p>​昨天进行了上机考试，然后感觉发挥的不是很好吧！没能拿到自己理想的结果，所以下次要冲一下。我并不是想卷一个好看点的分数，只是说我在考试中真的暴露出了太多的问题😢。</p><p>​话说，自从高考结束后，我也很少再特意的腾出一块时间来单独的用来思考和总结，以及规划我的前行的道路了。这也导致了我在整个大一和即将结束的大二学习都是很莽撞的样子，像极了一只无头苍蝇，💢局限于透明的玻璃瓶中，撞得头破血流！也就越发的觉得思考和规划是多么的重要！</p><p>​首先回顾一下考试！emmm！我对这次考试准备的不算多吧，就要考试的那天把自己写过的代码过了一遍，然后主要自己把PPT上的知识点进行了一些列的总结。在这期间，也把之前没掌握或者说掌握的很朦胧的知识点给理清了。同时思考后获取新的理解的感觉真的很棒😀。然后最值得自豪的是，自己简单的改进了下NBCD码减法的算法步骤，然后给老师发了封我证明我自己结论的PDF，不过他还没回，估计是觉得这都讲过了，你才知道！！！（可能是老师上课讲了，我当时没听到？啊！这里很气，我早就该换一副眼镜了。每次只要没做到前排位置，我就基本看不清黑板和投屏！）</p><p>​然后整个计组的编程作业我也都是很认真的在做，而且这是为数不多的让我觉得很惊喜的课程！✨虽然Cache一度让我难受！Virtual Memory也让我感受到了它的神秘之力~~不过，我都解决了，并且都是靠着自己一点一点的去理解，一点一点的去挖掘其中的联系！TLB，永远的神！✨我觉得自己在作业这方面做的还算不错吧，没有抄袭，并且是本着学知识的态度去完成的！主要是，这个作业是真的蛮好玩的！👍</p><p>​ok，回到机考！题目怎么说呢！我感觉出的很好，但同时也出的有点问题！很好的原因是：它整个代码框架的逻辑非常的贯通，一环扣一环，同时纸质题卷让我感觉这才是南大考试该有的样子吧！但是它可能稍微简单了点？导致了一些不公平？还有，这机房的电脑也太垃圾了吧！！！ 五六十台电脑用不了，还在那等别人写完了，轮到自己了才能去写？？？</p><p>​这稍微有点离谱！更奇葩的是，居然有的同学的电脑里有往年考试的答案，然后知识寄存器/操作数参数不一样？？？一个是8，一个是16？？这不是只要改个参数就好了嘛？考试从下午13：00开始，我等到了14：29才有机器用！然后这其实也就算了。</p><p>​最主要我在考试的时候，助教一直在我旁边看着，因为其他同学基本都走完了，我是属于倒数第二批去机房考试的！一批大概2-5个人不等！然后因为比较简单，事先就构思好了，然后在Booth算法那里出了点bug，把两个操作数搞反了，导致中间步骤的部分积和测试用例的不一样，就一直在找！！！然后助教也在旁边看着，我就有点慌乱！为嘛我心态这么容易慌张？从高中到大学一直这样！害，还是稍微菜了点，对自己不够自信！</p><p>​个人评价：主要是自己内心不够平静，老是自乱阵脚，明明平时做的都不错，准备的也不差，就以考试就考不出来！高中也是，不过高中我一直在写小结，复盘，思考，找解决方法，所以在慢慢向好的方向发展。现在大学里，同样需要做到这点，以后的人生里也是。调整心跳，学习这是一生都要做的事！！还有就是规划，规划真的太重要了！</p><p>​好了，罗里吧嗦的吐槽完了！之后再进一步做更详细的规划！现在需要赶进复习期末考试了，我的GPA真的太低了！退学警告！！！✊</p><p>​克制自己，平静！淡定！在勤奋一点！加油，冲冲冲！相信自己期末不会差的！这学期肯定能把GPA提高一个小的等级！！！🚀</p>]]></content>
    
    
    <categories>
      
      <category>个人思考总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误修正</title>
    <link href="/2020/12/18/%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/"/>
    <url>/2020/12/18/%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/</url>
    
    <content type="html"><![CDATA[<h1>错误修正</h1><ul><li><p>半导体存储系统是很容易出错的</p></li><li><p>错误类型：</p><ul><li>硬故障<ul><li>永久性的物理故障，以至于影响存储单元不能可靠的存储数据，称为固定的“1”或“0”或其之间跳转的故障</li></ul></li><li>软差错<ul><li>随即非破坏性事件，改变了存储单元的内容，但是不破坏存储器</li><li>可以是电源问题或$a$粒子引起</li></ul></li></ul></li><li><p>基本思想：增加一些额外的位用来存储纠错信息</p></li><li><p>过程：</p><ul><li><p>输入的数据：M位的数据D和映射函数$f$产生的K位纠错码C</p></li><li><p>输出的数据：一个新的数据$D<sup>{'}$和映射函数$f$产生的K位纠错码$C</sup>{‘’}$，并且和已经存在的K位纠错码$C^{'}$进行比较</p><ul><li>没有检测出错误：传送数据$D^{'}$</li><li>检测出一个可以修改的错误：纠正错误然后发送纠正后的数据</li><li>检测出一个不可修改的错误：报告错误</li><li><img src="/img/article_img/Error1.png" alt="Error Correction"></li></ul></li></ul><h2 id="奇偶校验">奇偶校验</h2><ul><li>基础思想：通过增加一位来确定数字1在数据中出现的是奇数词或偶数次</li><li>过程：<ul><li>假设数据$D=D_{M}…D_{2}D_{1}$</li><li>输入的数据：<ul><li>奇校验位：$C=D_{M} \bigoplus  … \bigoplus D_{2} \bigoplus D_{1} \bigoplus 1$；</li><li>偶校验位：$C=D_{M} \bigoplus  … \bigoplus D_{2} \bigoplus D_{1}$；</li></ul></li><li>输出的数据：<ul><li>奇校验位：$C=D^{‘}<em>{M} \bigoplus  … \bigoplus D^{'}</em>{2} \bigoplus D^{’}_{1} \bigoplus 1$；</li><li>偶校验位：$C=D^{‘}<em>{M} \bigoplus  … \bigoplus D^{'}</em>{2} \bigoplus D^{’}_{1}$；</li></ul></li><li>检查：$S=C^{‘’} \bigoplus C^{'}$<ul><li>S = 1: 出错的位数是奇数个</li><li>S = 0：正确或出错的位数的偶数个</li></ul></li></ul></li><li>简单说明：奇偶校验位，其中0的出现对结果没有影响，所以只考虑1，如果出现了偶数个1，定义奇数位是0，这个是定义的，偶数位必然和奇数位相反。</li><li>优点：消耗少</li><li>缺点：出错位数是奇数个时，不能找出具体出错的地方；也不能用来进行纠错</li><li>comment：比较是用于一个字节的数据的检验</li></ul></li></ul><h2 id="海明码-汉明码">海明码/汉明码</h2><ul><li>基本思想：把数据位分成不同的组，然后使用奇偶校验码来对每组进行纠错和检验</li><li>步骤：<ul><li>将M位分成K组</li><li>输入的数据：用一位来指示一组，生成K位的校验码</li><li>输出的数据：用一位来指示一组，生成一个新的K位的校验码</li><li>校验：对获取的数据，重新计算出一个K位的校验码，把这个重新计算出的校验码和同数据一同传过来的数据中含有的校验码进行异或，获得一个K位的<strong>故障字</strong>。</li></ul></li><li>校验码的长度<ul><li>前提假设：最多的错误是数据中只有1位出现错误</li><li>可能的错误：<ul><li>1位数据位出错：M</li><li>一位校验码错误：K</li><li>没有错误：1</li></ul></li><li>校验码长度：$2^{k} \geq M + K + 1$</li><li><img src="/img/article_img/Error2.png" alt=""></li></ul></li><li>对于故障字的值<ul><li>把故障字的值映射到可能出错或需要的环境</li><li>规则：<ul><li>全0：没有检测出错误</li><li>全1：检查位中出现了一位错误，但是不需要纠正，因为传输出去的时候会重新计算校验码</li><li>其他位：将这些位用来一一对应一个错误（或者闲置），并且用来进行纠错</li></ul></li></ul></li><li>数据位的划分<ul><li>假设8位的数据$D=D_{8}…D_{2}D_{1}$，4位校验码是$C=C_{4}C_{3}C_{2}C_{1}$</li><li>数据位+校验码与故障字的关系：<ul><li><img src="/img/article_img/Error3.png" alt=""></li></ul></li></ul></li><li><img src="/img/article_img/Error4.png" alt=""></li><li><img src="/img/article_img/Error5.png" alt=""></li><li><img src="/img/article_img/Error6.png" alt=""></li><li>SEC（single_error_correcting）:可以找到并修正1位的错误</li><li>SEC-DED（single_error_correcting, double_error_detecting）:可以找到2位错误，并修正1位错误<ul><li>增加额外的一位：$C_{5} = D_{1} \bigoplus D_{2} \bigoplus D_{3} \bigoplus D_{5} \bigoplus D_{6} \bigoplus D_{8}$</li><li>一位的错误出现了，三位的校验码会被改变</li></ul></li><li><img src="/img/article_img/Error7.png" alt=""></li><li><img src="/img/article_img/Error8.png" alt=""></li></ul><h2 id="Cyclic-Redundancy-Check">Cyclic Redundancy Check</h2><ul><li>奇偶校验码的问题<ul><li>额外的消耗太大</li><li>需要将数据划分成字节</li></ul></li><li>CRC<ul><li>适用于存储和传输以流的形式的大容量的数据</li><li>通过数据函数生成数据的校验码</li></ul></li><li>基本思想<ul><li>假设数据N位，左移后与K+1位的生成多项式进行模二除法</li><li>使用K位的余数作为校验码</li><li>把校验码放在数据的后面</li></ul></li><li>Check<ul><li>如果N+K位数据同生成多项式进行模二除法能够进整除，没有错误出现</li><li>否则，出现错误</li></ul></li><li>例子：<img src="/img/article_img/Error9.png" alt=""></li><li>编程算法：<ul><li>数据D，生成多项式Pol，长度分别为N，K+1</li><li>在数据D后面加上K+1位0，同Pol进行模二除法（取异或）</li><li>最后获取的K位余数即为校验码</li><li>Check同理</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点数算术</title>
    <link href="/2020/12/18/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%AE%97%E6%9C%AF/"/>
    <url>/2020/12/18/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%AE%97%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1>浮点数算术</h1><h2 id="1-加减法">1. 加减法</h2><ul><li><p>确保两个操作数得指数相同</p><p>$X + Y = (X_{s} \times B^{X_{E} - Y_{E}} + Y_{S}) \times B^{Y_{E}}$</p><p>$X - Y = (X_{s} \times B^{X_{E} - Y_{E}} - Y_{S}) \times B^{Y_{E}}$</p><p>$X_{E} \leq Y_{E}$</p></li><li><p>步骤</p><ol><li>检查是否有0</li><li>对阶：把阶数较小的向阶数较大得对齐（大阶小阶，有效位的高位左移被丢失，准确度损失大❌；小阶对大阶，有效位低位右移被丢失，损失相对较小✔️）</li><li>对有效值加减</li><li>规格化结果</li></ol></li><li><p><img src="/img/article_img/FPU1.png" alt="add/sub workflow"></p></li><li><p>阶数上溢：</p><ul><li>正阶数查过了阶码域能表示的范围</li><li>记为$+\infty$;$-\infty$</li></ul></li><li><p>阶数下溢：</p><ul><li>负阶数小于阶码域能表示的最小值</li><li>报告为0</li></ul></li><li><p>有效值上溢：</p><ul><li>相同符号的有效值相加可能会导致进位</li><li>调整阶数和有效值的关系</li></ul></li><li><p>有效值下溢：</p><ul><li>在对阶过程中，有效值的有效位可能会右移到有效值域的外面</li><li>使用一些保护位</li></ul></li></ul><h2 id="2-符号幅值加法">2. 符号幅值加法</h2><ul><li>如果操作数的符号相同，做加法，否则做减法<ul><li>加法：直接相加<ul><li>如果最高位有进位，上溢</li><li>符号和加数的符号相同</li></ul></li><li>减法：加减数的补码<ul><li>如果最高位有进位，修正（去掉进位就是结果）</li><li>否则计算它的补码后取负</li></ul></li></ul></li></ul><p><img src="/img/article_img/FPU2.png" alt="example"></p><ul><li>例子中：第一个表示上溢；第二个现堆0.8125取补码，然后相加后发现没有进位，那么再次取补码后取负即为结果；第三个先对0.625取补码，相加后有进位，修正符号同减数的符号（舍弃进位）</li><li>简单说明：$X + Y$; 如果$X; Y$符号相同就直接相加，否则就是相当于$X - (-Y)$,做减法💨<ul><li>先对$(-Y)$取补码得$(-Y_{c})$，假设$X， Y$都是n位，又因为我们不计入符号位，所以有$2^{n} = (-Y) + (-Y)_{c}$</li><li>执行加法：$Z = X + (-Y)_{c} = X + 2^{n} - Y$</li><li>如果$Z$得最高位有进位，说明$Z = 2^{n} + X - Y \geq 2<sup>{n}$；即进位即为$2</sup>{n}$，所以去掉进位即为结果</li><li>如果$Z$得最高位没有进位，则说明$Z = 2^{n} + X - Y &lt; 2^{n}$, 即结果$X - Y = - (2^{n} - Z)$；即对$Z$取补码，然后取负即为结果。</li></ul></li></ul><p><img src="/img/article_img/FPU3.png" alt="addition &amp; subtraction"></p><p><img src="/img/article_img/FPU4.png" alt="addition &amp; subtraction"></p><ul><li>对上述例子得简单说明：<ul><li>上述两个例子就是很好得用到了上面的符号幅值加法得算法原理！简直棒极了！！！🚀</li><li>第一个例子：先对阶，然后发现是0.5 -(-0.4375)；所以要转为加法来计算—&gt;0.5 + (-(-0.4375)) = 0.5 + 0.4375, 直接相加即可。</li><li>第二个例子：先对阶，然后发现是0.5+(-0.4375)；所以采用符号幅值加法，即相当于0.5-0.4375; 对0.4375得有效值取补码，然后同0.5的有效值相加，判断是否有进位，发现有进位，直接舍弃掉进位即为真正的有效值，然后再规格化就好了！</li></ul></li></ul><h2 id="3-乘法">3. 乘法</h2><ul><li>运算步骤：<ul><li>如果操作数出现0，直接返回0</li><li>对两个操作数的阶码求和，减去偏移量（32bits的bias=127）（因为在浮点数表示为计算机中的01串时，会对阶码加上偏移量，即$E_{1} = E_{true, 1} + bias; E_{2} = E_{true, 2} + bias=&gt; E_{3} = E_{true, 3} + bias = E_{1} + E_{2} - bias$）</li><li>有效值相乘</li><li>规格化结果，并且进行舍入</li><li><img src="/img/article_img/FPU5.png" alt="multiply workflow"></li><li><img src="/img/article_img/FPU6.png" alt="example"></li></ul></li><li>主要是需要注意下浮点数的表示，以及阶码和那个地方。其余的乘法就是普通的无符号乘法，然后判断下符号即可。</li></ul><h2 id="4-除法">4. 除法</h2><ul><li>运算步骤：<ul><li>如果除数为0，抛出异常，或者设置结果为无穷大（看需求）</li><li>被除数为0，结果为0</li><li>被除数阶码减去除数阶码，然后再加上偏移量（做减法时，偏移量抵消了）</li><li>对有效值进行除法</li><li>对结果进行规格化和舍入</li><li><img src="/img/article_img/FPU7.png" alt="div workflow"></li><li><img src="/img/article_img/FPU8.png" alt="example"></li></ul></li><li>需要注意的点：主要是除数为0，被除数为0的处理方法，它的时限要求不要随着需求改变；还有就是规格化时，可能会涉及到后面的保护位的使用</li></ul><h2 id="5-精度的考量">5. 精度的考量</h2><ul><li><p>保护位：</p><ul><li>实际的浮点寄存器的比有效值要长一点</li><li>这些多出来的位用来存储一些可能会用到的位，称为保护位</li><li>它们通过“0”这个位来拉长有效位的右端</li></ul><p><img src="/img/article_img/FPU9.png" alt="example"></p><ul><li>注意🍎：它们是实际拉长了有效位来计算的，但计算完结果后，截取后面的保护位，能够增大精确度</li></ul></li><li><p>舍入：</p><ul><li>计算后的有效值一般会存储在比较长的寄存器中</li><li>当我们把数字读取位正常的浮点数的格式时，我们会忽略那些多余出来的位，因此就需要考量怎么舍入的问题：<ul><li>就近舍入：结果被舍入为最近可表示的数</li><li>向$+\infty$舍入：结果向正无穷大方向向上舍入</li><li>向$-\infty$舍入：结果向负无穷大方向向下舍入</li><li>朝0舍入：结果向0舍入</li></ul></li></ul></li><li><p>有意思的两个小例子🔔：假设浮点数16位，1位符号位，9位有效值位，6位阶码（bias：31）</p><ul><li><p>+652.13: 0 101000 010001100 -&gt; +652.0；-7.48: 1 100001 110111101 -&gt; -7.4765</p></li><li><p>🌼：652.13 + ( - 7.48) = 644.65</p></li><li><p>101000 - 100001 = 000111</p></li><li><p>calculate without guard bits:</p><ul><li>1 010001100  - 0 00000111 -&gt; 1 010000101</li><li>=&gt; 0 101000 010000101 (645.0)</li></ul></li><li><p>calculate with guard bits:</p><ul><li>1 010001100 000000 - 0 000000111 011110 -&gt; 1 010000100 100010</li><li>=&gt; 0 10100 010000100（644.0）</li></ul></li><li><p>为什么使用了保护为结果反而离实际结果更远了呢？👻</p><ul><li>因为我们把一个浮点数输入计算机中表示，它本身就是有误差的；而这个计算结果是在计算机表示更精确（使用了保护位，有效值位数多）的情况下计算出的结果，是计算机认为的准确结果，也是我们所认为计算机更加精确了的结果。</li></ul></li><li><p>🍁：652.13 - ( -7.48 ) = 659.61</p></li><li><p>101000 - 100001 = 000111</p></li><li><p>calculate without guard bits:</p><ul><li><p>1 010001100  + 0 00000111 -&gt; 1 010010011</p></li><li><p>=&gt; 0 101000 010010011 (659.0)</p></li><li><p>calculate with guard bits:</p><ul><li>1 010001100 000000 + 0 000000111 011110 -&gt; 1 010010011 011110</li><li>=&gt; 0 101000 010010011（659.0）</li></ul></li></ul></li></ul></li></ul><p>—end!📄</p>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十进制运算</title>
    <link href="/2020/12/17/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <url>/2020/12/17/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1>十进制运算</h1><h2 id="加法🌙">加法🌙</h2><p><img src="/img/article_img/Dec1.png" alt="Addition"></p><ul><li>当有进位时，就对整个二进制表示加 <strong>0110</strong>；这相当于16进制和10进制的转换需要✔️</li></ul><h1>减法</h1><p><img src="/img/article_img/Dec2.png" alt="Subtraction"></p><p><img src="/img/article_img/Dec3.png" alt="example"></p><ul><li><p>emmm！对于减法的实现，我们很容易会和二进制补码联系起来，就是重复利用已经实现好的加法器进行运算​​</p></li><li><p>$N_{1} - N_{2} = N_{1} + (10 ^{n} - N_{2})$</p></li><li><p>因为我们使用NBCD码进行减法运算时，它是将每4位当作一个块，计算数字后乘以10的底来运算的</p></li><li><p>$N_{1} - N_{2} = [10^{n} - (10^n - N_{1} + N_{2})]$</p></li><li><p>修正后步骤即为：</p><ul><li>$N_{1} - N_{2}$; 现对$N_{1}$对照着表格进行转换(其实就是9 - X),记转换后的为$N^{'}$</li><li>然后对$N^{'}$与$N_{2}$进行上面的加法（复用）</li><li>考虑加法结果的进位<ul><li>进位为0：直接进行转换即为结果</li><li>进位为1：直接在低位+1，然后取负即为结果</li></ul></li></ul><p>😆简单证明：</p><p>NBCD减法算法的简单证明✔️:</p><ul><li>给定$N_{1}, N_{2}$; 假设它们用$4n$位01串表示的NBCD码，均为整数，不带符号，因为有符号的数计算同理。</li><li>计算$Ans = N1 - N2$； $N_{1} = (a_{n,4}…a_{n,1})…(a_{1,4}…a_{1,1}); N_{2} = (b_{n,4}…b_{n,1})…(b_{1,4}…b_{1,1})$</li><li>算法步骤为：<ol><li>按照转换表，对$N_{1}$的从左开始，每四位做一次转换（1001 - 4bits）得$N^{‘}<em>{1} = (a<sup>{'}_{n,4}…a</sup>{'}</em>{n,1})…(a<sup>{'}_{1,4}…a</sup>{’}<em>{1,1})$；其中$N^{'}</em>{1} = 9 \times 10^{n-1} + 9 \times 10^{n-2} + … +  9 \times 10^{0} - N_{1} = 1 \times 10^{n} - N_{1} - 1$</li><li>复用NBCD码得加法得$N_{3} = N^{'}<em>{1} + N</em>{2} = 1 \times 10^{n} - N_{1} - 1 + N_{2}$（以通过NBCD码加法进位得修正）</li><li>看$N_{3}$是否有进位：<ul><li>如果$N_{3}$没有进位，则说明$10^{n} - N_{1} - 1 + N_{2} &lt; 10^{n}$； 即$N_{1} - N_{2} &gt; 1$；所以直接对$N_{3}$做一次上述转换得$N^{'}<em>{3}$; 有$N^{'}</em>{3} = 10^{n} - N_{3} - 1 = 10^{n} - (10^{n} - N_{1} - 1 +N_{2}) = N_{1} - N_{2}$即为结果。</li><li>如果$N_{3}$有进位，即$10^{n} - N_{1} - 1 + N_{2} \geq 10^{n}$；即有$N_{2} - N_{1} \geq 1$；即$N_{3} = 10^{n} + N_{2} - N_{1} - 1 $；即进位表示$10^{n}$, 而$N_{3}$为$N_{2} - N_{1} - 1$; 为此，我们只要对$N_{3}$在低位加上“0001”，然后取负即为结果。</li></ul></li></ol></li></ul><p><strong>✔️简单的例子</strong></p><p>eg: 309 - 125<br>0011 0000 1001 （309）-<br>0001 0010 0101 （125）</p><p>0110 1001 0000  （进行一次转换）+<br>0001 0010 0101 -&gt;<br>0111 1011 0101</p><p>0111 1011 0101 （对1011修正）+<br>0000 0110 0000   -&gt;<br>1000 0001 0101 进位为0， 直接转换即为结果 -&gt;<br>0001 1000 0100 (184)</p><p>eg: 125 - 309<br>0001 0010 0101   (125) -<br>0011 0000 1001   (309)</p><p>1000 0111 0100   (进行了一次转换) +<br>0011 0000 1001   -&gt;<br>1011 0111 1101</p><p>1011 0111 1101  （对1011、1101进行修正) +<br>0110 0000 0110   -&gt;<br>1 0001 1000 0011  (进位为1，在此基础上+1后取负) -&gt;</p><p>0001 1000 0100 （-184）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数算术</title>
    <link href="/2020/12/17/%E6%95%B4%E6%95%B0%E7%AE%97%E6%9C%AF/"/>
    <url>/2020/12/17/%E6%95%B4%E6%95%B0%E7%AE%97%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1>整数算术</h1><h3 id="1-整数运算在ALU中进行">1. 整数运算在ALU中进行</h3><ul><li>数据、结果、标志都保存在寄存器中</li><li>控制单元提供控制信号来控制数据的转运和运算的进行</li><li><img src="/img/article_img/ALU1.png" alt="ALU"></li></ul><h2 id="2-加法全加器">2. 加法全加器</h2><ul><li>$S = X + Y $; $S = S_{n}S_{n-1}…S_{1}$; $X = X_{n}X_{n-1}…X_{1}$; $Y = Y_{n}Y_{n-1}…Y_{1}$(可能结果还会多出进位$C_{n}$</li><li>$S_{i} = X_{i} \bigoplus Y_{i} \bigoplus C_{i-1}$;  $C_{i} = X_{i}C_{i-1} | Y_{i}C_{i-1} | X_{i}Y_{i}$;</li><li>与门延迟: 1ty</li><li>或门延迟：1ty</li><li>异或门延迟：3ty</li><li><img src="/img/article_img/ALU2.png" alt=""></li><li><img src="/img/article_img/ALU3.png" alt=""></li></ul><h2 id="3-串行进位加法器">3. 串行进位加法器</h2><ul><li>延迟：<ul><li>$C_{n}: 2n ty$</li><li>$S_{n} : (2n+1)ty$</li></ul></li><li>缺点：慢</li></ul><p><img src="/img/article_img/ALU4.png" alt="serial carry Adder"></p><h2 id="4-进位超前加法器">4. 进位超前加法器</h2><p><img src="/img/article_img/ALU5.png" alt="carry look ahead Adder"></p><p><img src="/img/article_img/ALU6.png" alt="carry look ahead Adder"></p><ul><li>1ty: 将所有的$P_{i}, G_{i}$都算好</li><li>2ty：计算所有的$C_{i}$</li><li>3ty：计算所有的$S_{i}$</li></ul><h2 id="5-部分进位超前加法器">5. 部分进位超前加法器</h2><p><img src="/img/article_img/ALU7.png" alt="part carry look ahead Adder"></p><ul><li>3ty：计算好所有$P_{i}$;$C_{i} (0&lt;=i&lt;=7)$；同时异或好所有$X_{i},Y_{i}$</li><li>2ty：开始计算$S_{i}(0&lt;=i&lt;=7)$;并且计算好$C_{i}(8&lt;=i&lt;=15)$</li><li>2ty：计算好$S_{i}(0&lt;=i&lt;=7)$;开始计算$S_{i}(8&lt;=i&lt;=15)$;并且计算好$C_{i}(16&lt;=i&lt;=23)$</li><li>2ty：计算好$S_{i}(8&lt;=i&lt;=15)$;开始计算$S_{i}(16&lt;=i&lt;=23)$;并且计算好$C_{i}(24&lt;=i&lt;=31)$</li><li>3ty：计算好$S_{i}(16&lt;=i&lt;=23)$;并且计算好$S_{i}(24&lt;=i&lt;=31)$</li></ul><p><strong>❌溢出</strong>：</p><ul><li><p>$C_{n} \neq C_{n-1}$: $overflow = C_{n} \bigoplus C_{n-1}$</p></li><li><p>$S_{n} \neq X_{n} and S_{n} \neq Y_{n}$:$overflow = X_{n}Y_{n} \overline S_{n} | \overline X_{n} \overline Y_{n}S_{n}$;</p></li><li><table><thead><tr><th>C<sub>n</sub></th><th>C<sub>n-1</sub></th><th>X<sub>n</sub></th><th>Y<sub>n</sub></th><th>S<sub>n</sub></th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><table><thead><tr><th>X<sub>n</sub></th><th>Y<sub>n</sub></th><th>S<sub>n</sub></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="6-减法">6. 减法</h2><ul><li>$[X - Y]<em>{c} = [X]</em>{c} + [-Y]_{c}$</li><li>overflow: same to addition</li></ul><p><img src="/img/article_img/ALU8.png" alt="subtraction"></p><h2 id="7-乘法">7. 乘法</h2><ul><li><p>模拟手算乘法的变化：</p><ul><li>每一步都计算部分积</li><li>右移部分积</li><li>如果$Y_{i} = 0$,右移部分积</li></ul></li><li><p>example：<img src="/img/article_img/ALU9.png" alt="example"></p></li><li><p>问题：$[X \times Y]<em>{c} \neq [X]</em>{c} \times [Y]_{c}$; 即补码乘法结果并不等于其直接乘法结果</p></li><li><p>粗略的想法：</p><ul><li>将补码表示的乘数和被乘数转为符号位表示的数</li><li>然后再将计算结果转为补码表示</li></ul></li><li><p>✔️Booth’s algorithm</p><p><img src="/img/article_img/ALU10.png" alt="Booth's algorithm"></p></li><li><p>Booth’s algorithm</p><ol><li>$Y_{0} = 0$</li><li>根据$Y_{i+1}Y_{i}$;来决定是否是$+X | -X$</li><li>右移部分积</li><li>重复2-3的步骤n次</li></ol><p><img src="/img/article_img/ALU11.png" alt="example"></p></li></ul><h2 id="8-除法">8. 除法</h2><ul><li><p>preprocessing:</p><ul><li>$X = 0$ &amp; $Y \neq 0$: 0</li><li>$X \neq 0$ &amp; $Y = 0$: exception</li><li>$X = 0$ &amp; $Y = 0$: NaN</li><li>$X \neq 0$ &amp; $Y \neq 0$: further processing</li></ul></li><li><p>手算除法</p><ul><li>从左到右检查被除数，直到找到大于等于除数的位置</li><li>被除数减去除数，如果部分余大于等于0，商1，否则商0</li><li>右移除数，然后重复上述步骤</li></ul><p><img src="/img/article_img/ALU12.png" alt="example"></p><p><img src="/img/article_img/ALU13.png" alt=""></p></li><li><p>ALU除法步骤</p><ul><li>扩展被除数，增加n位符号位在前面，分别存储在余数和商寄存器中</li><li>左移余数和商，判断余数是否足够大<ul><li>足够大：做减法，然后设置商1</li><li>不够大：设置商0</li></ul></li><li>重复上述步骤</li><li>如果被除数和除数的符号不同，对计算的商取补就是真正结果</li><li>余数在余数寄存器中</li></ul></li><li><p>这种除法的问题❌：</p><ul><li>回复余数的代价太高了，加减做了多次</li></ul></li><li><p>解决方法✔️: 不去恢复商</p><ul><li>只考虑减法：<ul><li>如果余数足够大：左移后直接减除数</li><li>不够大：左移后加上除数</li></ul></li></ul></li></ul><h2 id="9-另一种除法">9. 另一种除法</h2><p>1.步骤：</p><ul><li>向扩展n位，分别存储在余数和商中</li><li>如果除数和被除数符号相同，做减法，否则做加法<ul><li>如果余数和除数的符号相同，商1；否则商0</li></ul></li><li>如果左移后的余数和除数符号相同，做减法；否则做加法<ul><li>如果新的余数符号和除数符号相同，商1；否则商0</li></ul></li><li>重复上述步骤</li></ul><ol start="2"><li>对商的修正，如果商是负的就加上1</li><li>对除数的修正，如果符号不同的，如果除数和被除数符号是否相同，如果相同，我们需要减去除数。</li><li>还要看余数是否和除数相同，如果相同要进行处理</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的表示</title>
    <link href="/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1>数的表示</h1><h2 id="1-二进制表示">1. 二进制表示</h2><ol><li>为了表示多个数值，必须对多个位进行组合<ul><li>如果有k位，最多能区分出$2^{k}$个不同的值</li></ul></li></ol><h2 id="2-整数类型：">2. 整数类型：</h2><ul><li>无符号整数</li><li>有符号整数： 原码、反码、补码<ul><li>原码和反码在进行加法运算时都会造成不必要的硬件需求，于是出现了补码</li></ul></li></ul><ol><li><p>补码表示：</p><p>$ [X]<em>{c} = X</em>{n}X_{n-1}…X_{2}X_{1} $</p><p>=&gt; $X = -X_{n}*2^{n-1} + … + X_{2} * 2^{1} + X_{1} * 2^{0} =&gt; (-2^{n-1} &lt;= X&lt;= 2^{n-1} - 1) $</p></li></ol><h2 id="3-浮点数表示">3. 浮点数表示</h2><ol><li>实数表示（科学计数法）</li><li><strong>定点表示法</strong>的值的范围极大的被限制了</li><li>科学计数法: $\pm S*B^{\pm E}$<ul><li>$\pm$: plus or minus</li><li>S: significant</li><li>B: base</li><li>E: exponent</li></ul></li><li><img src="/img/article_img/compute1.png" alt="representation"></li><li>规格化的数：<ul><li>任何一个浮点数都能表示为多个式子：$0.110 \times 2^{5}, 110 \times 2^{2}$</li><li>规格化表示：$\pm 1.bbb…b \times 2^{\pm E}$</li><li>符号位：第一位</li><li>第一位有效数字是 1 ；不需要保存在有效字段中</li><li>真正的$e = E - 127$</li><li>基是2</li></ul></li><li><img src="/img/article_img/compute2.png" alt="value range"></li><li>精度和范围之间有一个平衡：<ul><li>增加exponent的位数，意味着减少S的位数，即扩大表示范围-&gt;精度减少；反之亦然</li></ul></li><li>使用更大的基底？<ul><li>获得了更大的表示范围，同时也会减小精度</li></ul></li></ol><h2 id="4-IEEE-Standard-754">4. IEEE Standard 754</h2><ul><li>确定了32位/64位浮点数的格式</li><li><img src="/img/article_img/compute3.png" alt="format"></li><li>确定了两种扩展方式<ul><li>包括了指数域和有效值域的扩展</li><li>减少了高度交换数据带来的错误和中间溢出</li><li><img src="/img/article_img/compute4.png" alt="interpretation"></li></ul></li></ul><h2 id="5-十进制表示">5. 十进制表示</h2><ul><li>浮点数的算术问题：<ul><li>精度的限制</li><li>高代价的转换</li><li>应用需求：<ul><li>计算长的字符串表示的数字、可计算的</li></ul></li><li>解决方案：<ul><li>使用4位2进制表示0，1，…，9（BCD, Binary-Coded Decimal)</li></ul></li></ul></li><li>Natural Binary Coded Decimal (NBCD, 8421code)<ul><li>0 - 9: 0000 - 1001</li><li>sign:<ul><li>p: 1100/0</li><li>n: 1101/1</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机功能和互连的顶层视图</title>
    <link href="/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
    <url>/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1>计算机功能和互连的顶层视图</h1><p><img src="/img/article_img/top_view1.png" alt="Top level view"></p><h1>1. 计算机元素</h1><ol><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li><li>执行指令的顺序是从当前指令到下一个，除非显式的修改</li></ol><h3 id="1-Memory">1. Memory</h3><ol><li>单个的存储器<ul><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li></ul></li></ol><p><img src="/img/article_img/top_view2.png" alt="Memory"></p><ol start="2"><li>问题：数据在CPU和主存中传输的速度远远的慢于CPU执行的速度</li></ol><p><img src="/img/article_img/top_view3.png" alt="Memory wall"></p><ol start="3"><li><p>解决方法：</p><ul><li>增加一个cache或者其他的缓冲装置来减少CPU对主存的访问频率</li><li>增加一次传输的数据宽度</li></ul></li><li><p>约束：</p><ul><li>容量：越大越好</li><li>速度：能够跟得上处理器</li><li>价格：相对于其他组件合理</li></ul></li><li><p>约束之间的关系：</p><ul><li>更短的访问时间、每位数据的开销更大</li></ul></li><li><p>需求：</p><ul><li>大容量的数据存储</li><li>高速度的访问性能</li></ul></li><li><p>解决方案：</p><ul><li>采用一种层次结构而不是单个的存储器</li></ul></li></ol><p><img src="/img/article_img/top_view4.png" alt="hierarchy"></p><h3 id="2-I-O">2. I/O</h3><ol><li><p>在外设和CPU、主存之间交换数据</p></li><li><p>问题：I/O的性能跟不上CPU的执行速度</p></li></ol><p><img src="/img/article_img/top_view5.png" alt="I/O performance"></p><ol start="3"><li>解决方法：<ul><li>缓冲机制</li><li>新的接口技术</li></ul></li></ol><h3 id="3-CPU">3. CPU</h3><ol><li><p>从一条执行到下一条，除非发生显示的改变</p></li><li><p>问题：CPU会经常出于空闲状态等待I/O设备读写完成</p></li><li><p>解决方法：</p><ul><li><p>中断：其他设备可以中断正常的执行过程的机制</p></li><li><p>中断检测：在指令周期里加上一个中断周期</p><p><img src="/img/article_img/top_view6.png" alt="interrupt detection"></p></li></ul></li><li><p>多级中断：</p><ul><li><img src="/img/article_img/top_view7.png" alt="sequential interrupt processing"></li><li><img src="/img/article_img/top_view8.png" alt="nested interrupt processing"></li></ul></li></ol><p><img src="/img/article_img/top_view9.png" alt="theoretical max performance"></p><h3 id="4-Bus">4. Bus</h3><ol><li>总线是一种连接多个设备的数据传输通路</li></ol><p><img src="/img/article_img/top_view10.png" alt="interconnection solution"></p><ol start="2"><li>数据传输类型：任何总线都可以被分为三种类型<ul><li>数据线：在系统模块中传输数据</li><li>地址线：指定数据源或接收数据的端口，也就是传输地址</li><li>控制线：控制设备对数据线地址线上的内容的读取</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概论</title>
    <link href="/2020/12/16/%E6%A6%82%E8%AE%BA/"/>
    <url>/2020/12/16/%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1>概论</h1><h3 id="1-结构和组织">1. 结构和组织</h3><ul><li>计算机结构：对程序员可见的系统属性，这些属性直接决定了程序的逻辑执行<ul><li>指令集、数据类型、输入输出机制、寻址技术</li></ul></li><li>计算机组成：实现结构规范的操作单元及其互连<ul><li>硬件细节，如控制信号、计算机和外设的接口以及存储器使用的技术</li></ul></li></ul><h2 id="2-冯诺伊曼机">2. 冯诺伊曼机</h2><ul><li>组成部分：<ul><li>存储器：地址和存储的内容</li><li>处理单元：执行信息的实际处理</li><li>控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li></ul><p><img src="/img/article_img/intro1.png" alt="冯诺依曼机结构图"></p><ul><li>重要思想：存储程序，及把数中据和程序存储到计算机中</li></ul><h2 id="3-摩尔定律">3. 摩尔定律</h2><ul><li>内容：单芯片上包含的晶体管数量每年/18个月翻一番</li><li>影响：<ul><li>因为单片芯片的价格不变而导致芯片的逻辑电路和存储器电路成本显著下降</li><li>更小的体积使得更容易放置在各种环境中</li><li>更短的电路提高了芯片的工作速度</li><li>减少了电能的消耗和冷却的要求</li><li>集成电路上的连接比焊接更加可靠，由于芯片电路的增加，减少了芯片之间的连接。</li></ul></li></ul><p><img src="/img/article_img/intro2.png" alt="data process"></p><h2 id="4-计算机性能">4. 计算机性能</h2><ul><li>重要参数：外观、价格、大小、安全性、稳定性、续航</li><li>用来评估的一些标准：<ul><li>CPU： speed</li><li>Memory：capacity、speed</li><li>I/O：capacity、speed</li></ul></li></ul><p><strong>main goal/driver</strong>： increase of CPU speed</p><h2 id="5-CPU性能">5. CPU性能</h2><ul><li><p>系统时钟：</p><ul><li>时钟频率/时钟速度：一秒钟内计算运转的周期数</li><li>clock cycle/clock tick：单次CPU的脉冲/时钟称为一个时钟周期/时钟滴答声</li><li>周期时间：两次脉冲间的时间</li><li>处理器的速度由时钟产生的脉冲频率来指示，用每秒周期数/赫兹数测量</li></ul></li><li><p>指令执行速度：</p><ul><li>处理器由时钟驱动，时钟固定频率为$f$或等价为固定时钟周期$t$, $t = 1/ f$</li><li>$I_{c}$: 一个程序的指令条数</li><li>$CPI(average cycle per instruction)$:每条指令的平均周期数</li><li>$CPI_{i}$: $i$类型执行所需周期数；$I_{i}$：某一给定程序中所执行的$i$类型指令的条数</li><li><img src="/img/article_img/intro3.png" alt="CPI"></li><li>处理器执行完一个给定的程序所需的时间$T = I_{c} * CPI * t$</li><li><img src="/img/article_img/intro4.png" alt="T"></li><li><img src="/img/article_img/intro5.png" alt="MIPS"></li><li>$R_{i}$时第i个程序高级语言指令执行的速度</li><li><img src="/img/article_img/intro6.png" alt="平均结果"></li></ul></li><li><p><strong>基本来说，用户更加关心系统的执行时间，而非它的执行速度。如果我们获得了各种测试程序的指令执行速度的算术平均值，那么我们就一定能得到一个与执行时间倒数之和成正比的结果，但这不与执行时间之和成反比。</strong></p></li><li><p><strong>指令执行速度的算术平均值并不能准确地刻画执行时间；另一方面，指令执行速度的调和平均值是平均执行时间的倒数</strong></p></li><li><p>阿姆达尔定律：</p><ul><li><p>考虑系统性能，人们会通过改变技术/设计来提高性能，如并行处理器、cache的使用、高速I/O访问等。</p></li><li><p>但之加速技术/设计的一个方面并不能很好的提高性能的相应改善。</p></li><li><p>一个程序在多处理器上运行与单处理器上运行的加速比：</p><p>假设一个程序有$f$可以无限并行，无调度负载；$(1-f)$只能串行；$T_{sin}$:单个处理器上运行的时间；$T_{n}$:n个处理器系统上运行的时间；则</p><p>$speedup = T_{sin} / T_{n} = [T(1-f) + Tf] / [T(1-f) + Tf/ n] = 1 / [1-f + f / n]$</p><ol><li>f非常小，使用并行处理器有一些影响</li><li>n的增大，加速比被限制</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache存储器</title>
    <link href="/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>Cache存储器</h1><h2 id="1-为什么使用Cache？">1. 为什么使用Cache？</h2><ol><li>内存墙的存在（内存性能严重限制CPU性能的发挥）</li></ol><h2 id="2-解决内存墙问题的方法">2. 解决内存墙问题的方法</h2><ol><li>同时使用速度快容量小的Cache与速度慢容量大的存储块</li><li>cache包含主存一部分内存的副本</li><li>cache位于CPU和主存之间，或者位于CPU内部</li></ol><h2 id="3-Cache如何工作得？">3. Cache如何工作得？</h2><ul><li>check：当处理器需要读取一个数据时，先去cache里检查一下是否在cache里</li><li>hit：如果在，直接将这个数据传给处理器</li><li>miss：如果不在，从主存中将包括这个数据的固定大小的块写进cache，并把需要的数据传给处理器</li></ul><p><img src="/img/article_img/cache1.png" alt="cache workFlow"></p><h2 id="4-cache工作流程的一些问题">4. cache工作流程的一些问题</h2><ul><li>如何确定一个数据是否在cache里？<ul><li>冯诺依曼计算机结构确定“无论什么数据都是以相同的方式寻址”</li><li>cache包含一个tag用来确定cache的某一行对应主存的那一部分</li><li>内存中的数据是由标签来进行指向的，而不是依据数据类型进行访问</li></ul></li><li>为什么在cache-miss时是从主存中读取一个块而不是一个字？<ul><li>因为程序的局部性原理</li><li>在程序执行过程中，处理器会倾向于向一块地方集中的访问数据</li><li>局部性分为：<ul><li>时间局部性</li><li>空间局部性</li><li>顺序访问（数组之类的）</li></ul></li></ul></li></ul><p><img src="/img/article_img/cache2.png" alt="temporal locality"></p><p><img src="/img/article_img/cache3.png" alt="spatial locality"></p><h2 id="5-把数据搬到Cache">5. 把数据搬到Cache</h2><ul><li>使用时间局部性</li><li>经典的cache组织</li></ul><p><img src="/img/article_img/cache4.png" alt="typical cache organization"></p><h2 id="6-一次搬用一整块内容而不是一个字">6. 一次搬用一整块内容而不是一个字</h2><ul><li>使用空间局部性原理</li><li>cache结构</li></ul><p><img src="/img/article_img/cache5.png" alt="cache structure"></p><h2 id="7-同比起来，使用cache会多更多的操作，为什么能节省时间呢？">7. 同比起来，使用cache会多更多的操作，为什么能节省时间呢？</h2><ul><li>访问cache的速度比访问内存的速度快很多</li><li>由于局部性原理的存在，cache的命中率会比较高</li><li>一次搬用一个块的数据比多次搬用一个字的时间少</li></ul><h2 id="8-平均访问时间">8. 平均访问时间</h2><ul><li><p>假设命中率为$p$，$T_{c}$为访问cache的时间，$T_{m}$是访问存储器的时间，那么平均访问时间为：$T_{A} = pT_{c} + (1-p)(T_{c} + T_{M}) = T_{c} + (1-p)T_{M}$</p></li><li><p>当$p &gt; T_{c} / T_{M}$时，$T_{A} &lt; T_{M}$</p></li><li><p>问题：cache的容量远小于存储器的容量</p></li></ul><h2 id="9-cache设计考虑因素">9. cache设计考虑因素</h2><ul><li>大小</li><li>映射策略</li><li>替换策略</li><li>写策略</li><li>行大小</li><li>数量</li></ul><h2 id="10-Cache-Size">10. Cache Size</h2><ul><li>增加行大小 -&gt; 增加命中率$p$, 同时也会增加cache的访问时间</li><li><img src="/img/article_img/cache6.png" alt="cache_size_hit _ratio"></li></ul><h2 id="11-Mapping-Function">11. Mapping Function</h2><ul><li>用来将主中的块映射到cache行的策略/算法</li><li>一种覆盖cache中哪一行的策略</li><li>映射函数的选择决定了cache行的组织</li><li>类型：<ul><li>直接映射</li><li>全相关映射</li><li>组相关映射</li></ul></li></ul><h4 id="1-直接映射">1. 直接映射</h4><ul><li>将存储器中的块固定的对应于cache中可以用的行中</li><li>$i = j mod C$, $i$:cache行号，$j$:数据块的块号, $C$:cache总行数</li><li>tag：前n位，$n = log_{2}M - log_{2}C$</li></ul><p><img src="/img/article_img/cache7.png" alt="​address​"></p><p><strong>1. 优点</strong>：</p><ul><li>简单</li><li>映射速度快</li><li>检查速度快</li></ul><p><strong>2.缺点</strong>：</p><ul><li>抖动大：当一个程序需要多次交替的访问两个映射在同一行的块，会发生多次的块替换</li></ul><p>comment：适用于大容量的cache</p><h4 id="2-全相关映射">2. 全相关映射</h4><ul><li>允许将存储器中的块映射到cache的任意行</li><li>tag：前n位， $n = log_{2}M$</li></ul><p><img src="/img/article_img/cache8.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>避免了抖动</li></ul><p><strong>2.缺点</strong>：</p><ul><li>复杂的实现</li><li>cache的查询消耗大</li></ul><p>comment：是用于小容量的cache</p><h4 id="3-组相关映射">3. 组相关映射</h4><ul><li>cache被分为$s$个组，每组$k$行。</li><li>$j$为块号，$i = j mod s$，第j块被映射到第i组。</li><li>称为k-路组</li><li>tag：前n位，$n = log_{2}M - log_{2}S$</li></ul><p><img src="/img/article_img/cache9.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>集成了直接映射和全相关映射的优点</li></ul><p><strong>2. 缺点</strong>：</p><ul><li>同时也集成了直接映射和全相关映射的缺点</li></ul><p>comment：对任意容量的cache在性能上进行了很好的权衡</p><h2 id="12-映射策略的对比">12. 映射策略的对比</h2><h5 id="1-相关性：每个块可能在cache中的行数">1. 相关性：每个块可能在cache中的行数</h5><ul><li>直接映射：1</li><li>全相关映射：C</li><li>组相关映射：k</li></ul><h5 id="2-相关性与性能">2. 相关性与性能</h5><ul><li>相关性越低，命中率越低</li><li>相关性越低，检查速度越快</li><li>相关性越低，tag长度越短</li></ul><h2 id="13-替换策略">13. 替换策略</h2><ol><li><p>当cache的行被填充时，一个新的块需要插入cache，那么此时就可能将cache中已有的块丢弃，也就是替换掉</p></li><li><p>对于直接映射：一个确定的块有且只有一个对应的cache行可以装填</p></li><li><p>对于全相关和组相关映射而言，替换策略是必需的，并且必须通过硬件来实现。</p></li><li><p><strong>最常用的集中替换算法</strong></p><ul><li>least recently use（LRU）-- 最近最少使用</li><li>first in first out（FIFO）-- 先进先出</li><li>least frequently used（LFU）-- 最不经常被使用</li><li>random – 随机</li></ul><h4 id="1-LRU">1. LRU</h4><ul><li>根据最近一次被用到的时间进行排序<ul><li>以二路组为例，我们将一位置为1，则另一位被置为0</li></ul></li><li>替换cache中当前最长时间没被使用的块</li><li>将设最近被使用的块不久还将会被使用</li><li>特别适合二路组关联映射</li></ul><h4 id="2-FIFO">2. FIFO</h4><ul><li>和使用时间关系不大，根据进入cache的时间来排序</li><li>假设越靠后的数据越容易被再次使用到</li><li>实现：循环/循环缓冲技术</li><li>通过计数器来时间（时间戳）</li></ul><h4 id="3-Random">3.Random</h4><ul><li>随机的替换对应的行</li><li>假设每个存储位置都等概率被再次访问到</li></ul></li></ol><h2 id="14-写策略">14. 写策略</h2><ul><li>内存与cache的一致性要求<ul><li>当一个块在cache中被替换时，需要考虑块是否被个别更改可</li></ul></li><li>两种情况：<ul><li>如果没有更改，可以直接替换</li><li>如果更改了，对应在内存中的块需要被更新</li></ul></li><li>两种策略：<ul><li>写入法（write through）</li><li>写回法（write back）</li></ul></li></ul><h4 id="1-写入法">1. 写入法</h4><ul><li><p>当cache中的行发生改变时，立即对内存中对应的块进行更新</p></li><li><p>优点：确保了内存中的数据始终被更新过了</p></li><li><p>缺点：</p><ul><li><p>产生大量的内存访问，出现时间瓶颈</p></li><li><p>减慢了写操作</p></li></ul></li></ul><h4 id="2-写回法">2. 写回法</h4><ul><li>只更新cache中的数据，当这个快被替换或者遇到I/O操作需要对主存这块区域读取数据时，才发生更新</li><li>使用dirty bit/ use bit，来代表是否被修改了</li><li>优点：减少了对内存的写操作</li><li>缺点：内存中对应的内容时过时的，因此当存在I/O操作时，只能允许通过cache进行，因此会造成复杂的电路以及潜在的瓶颈</li></ul><h2 id="15-行大小">15. 行大小</h2><ul><li>当行大小从很小的容量增加到比较大的容量时：<ul><li>命中率提高</li><li>更多有用的数据可以被带入cache</li></ul></li><li>当行大小变的非常大时：<ul><li>命中率提高，但提高的速度明显减慢<ul><li>更大的行，导致cache的行数减少，这将导致频繁的替换</li><li>每个额外的字都会离被需要的字更远，因此更小的可能性会在不久的将来被访问在</li></ul></li></ul></li><li>块大小和命中率之间的关系更加复杂</li></ul><h2 id="16-cache行数量">16. cache行数量</h2><ul><li>unified（统一）：<ul><li>提高指令与数据负载自动平衡的命中率</li><li>只有一个cache需要被设计和实现</li></ul></li><li>split（分隔）：<ul><li>消除指令获取/解码单元和执行单元之间对缓存的争用，这对指令的流水线很重要</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU结构和功能</title>
    <link href="/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1>CPU结构和功能</h1><h3 id="一、CPU的任务">一、CPU的任务</h3><ul><li>取指令：从存储器（register、main-memory、cache）读取指令</li><li>解释指令：对指令解码，确定要进行的操作</li><li>取数据：指令的执行可能需要从存储器或I/O中读取数据</li><li>处理数据：对数据完成要求的算术/逻辑运算</li><li>写数据：执行的结果可能需要写回存储器或I/O</li></ul><h3 id="二、CPU的要求">二、CPU的要求</h3><ul><li>CPU能暂时的存储部分数据</li><li>CPU必须知道当前执行指令的位置，以便获取下一条指令的位置</li><li>CPU必须在执行指令期间保存指令和数据</li></ul><p><img src="/img/article_img/cpu_structure_function1.jpg" alt="cpu简介图"></p><p><img src="/img/article_img/cpu_structure_function2.jpg" alt="cpu详介图"></p><h3 id="三、寄存器的组成">三、寄存器的组成</h3><h4 id="1-CPU中寄存器主要可以分为两类：">1. CPU中寄存器主要可以分为两类：</h4><ul><li>用户可见寄存器：允许机器语言或者汇编语言的编程人员通过优化寄存器的使用而减少对内存的访问</li><li>控制和状态寄存器：由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行</li></ul><h4 id="2-用户可见寄存器：">2. 用户可见寄存器：</h4><ul><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：用于保存数据，不能用于操作数地址的计算</li><li>地址寄存器：用于可以是自身有某种通用性或者专用性的寻址方式</li><li>标志寄存器：保存条件码、允许程序员读出，但不能更改</li></ul><h4 id="3-寄存器的设计出发点：">3. 寄存器的设计出发点：</h4><ul><li>使用完全通用寄存器还是规定各寄存器的用途</li><li>寄存器的数量</li><li>寄存器的长度</li></ul><h4 id="4-控制和状态寄存器：">4. 控制和状态寄存器：</h4><ul><li>程序计数器（PC）：存放待取指令的地址</li><li>指令寄存器（IR）：存放最近取来的地址</li><li>存储器地址寄存器（MAR）：存放存储器位置的地址</li><li>存储器缓冲寄存器（MBR）：存有将被写入或最近从存储器读出的字</li></ul><h4 id="5-程序状态字（PSW）：">5. 程序状态字（PSW）：</h4><ul><li>符号（sign）：容纳算术运算结果的符号位</li><li>零（zero）：当结果是0时置位</li><li>进位（carry）：操作导致向最高位有向上进位或借位时被置位</li><li>等于（equal）：逻辑结果相等置位</li><li>溢出（overflow）：用于指示算术运算溢出</li><li>中断允许/禁止（interrupt enable/disable）：用于允许/禁止中断</li><li>监管（supervisor）：指出CPU是执行在监管模式还是用户模式</li></ul><h4 id="6-设计控制和状态寄存器组织时考虑的几个因素：">6. 设计控制和状态寄存器组织时考虑的几个因素：</h4><ul><li>考虑对操作系统的支持（某些控制信息专门为控制操作系统使用）</li><li>考虑控制信息在寄存器和存储器之间的分配</li></ul><h4 id="7-指令周期：">7. 指令周期：</h4><ul><li>取指：将下一条指令从存储器中读入CPU</li><li>执行；解释操作码并完成指定操作</li><li>中断：如果中断允许并且有中断发生，则保存当前状态执行中断</li></ul><h4 id="8-间接周期：">8. 间接周期：</h4><ul><li>指令的执行可能涉及到内存中的一个或多个操作数，并且每个操作数都需要内存访问</li><li>如果使用间接地址，需要额外的内存访问</li><li>将间接地址的获取视为一个或多个指令周期</li></ul><p><img src="/img/article_img/cpu_structure_function3.png" alt="指令周期"></p><p><img src="/img/article_img/cpu_structure_function4.png" alt="指令周期状态图"></p><h4 id="9-数据流：">9. 数据流：</h4><ol><li><p><img src="/img/article_img/cpu_structure_function5.png" alt="数据流与取指周期"></p><ul><li>控制器向PC发送请求 -&gt; PC将存有的下一条指令的地址传给MAR -&gt; MAR放到地址总线上</li><li>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号 -&gt; 存储器获取指令地址并将对应的指令放到数据总线上</li><li>MBR从数据总线上获取指令然后传给IR</li></ul></li><li><p><img src="/img/article_img/cpu_structure_function6.png" alt="数据流间接周期"></p><ul><li><p>MBR存储的是指令的地址 -&gt; MBR将地址传给MAR -&gt; MAR将该地址传放到地址总线上</p></li><li><p>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号并读取指令的地址</p></li><li><p>存储器根据地址将对应指令放到数据线上 -&gt; MBR读取指令</p></li></ul><p><img src="/img/article_img/cpu_structure_function7.png" alt=""></p><ul><li>控制器向MAR传送信号 -&gt; MAR将当前数据要保存到的地址放到地址总线上</li><li>控制器向PC传送信号 -&gt; PC将当前要保存的数据传入MBR -&gt; MBR将数据放到数据总线上</li><li>控制器向控制总线上发送信号 -&gt; 存储器读取信号 -&gt; 存储器从地址总线上接收地址，并从数据总线上接收数据</li><li>存储器将数据写入对应的地址</li></ul></li></ol><h3 id="四、指令流水线技术：">四、指令流水线技术：</h3><p><strong>1. 流水线技术</strong>：把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</p><p><strong>2. 对指令执行使用流水线技术</strong>：显然能够加快指令的执行，但是使得执行速度翻倍是不可能的，原因如下：</p><ul><li>执行时间一般长于指令的执行（执行指令和取指令都可能使用I/O，所以会产生冲突，一次只能有一个进行）</li><li>条件分支指令使得待取的下一条指令的地址未知（当多条指令执行了一些步骤后，遇到跳转指令，这些指令执行的步骤将会作废）</li></ul><p><strong>3.对指令执行的细分</strong>（为了进一步加速）：</p><ul><li>取指：获取下一条要执行指令到MBR</li><li>译码：解析指令，确定操作码、操作数</li><li>计算操作数：计算源操作数的有效地址</li><li>取操作数：从存储器中读取操作数（寄存器中的数据不需要读取）</li><li>执行：完成指定操作</li><li>写回操作数：将结果写回存储器</li></ul><p><strong>4. 几个限制性能提升的因素</strong>：</p><ul><li>细分的各个阶段时间不完全相等</li><li>遇到条件转移指令时，之前进行的指令会作废</li><li>寄存器和存储器可能产生冲突</li></ul><p><strong>5. 人们认为流水线中阶段越多，执行速度越快？No</strong></p><ul><li>流水线的每一阶段，都会有某些开销设计数据在MBR间的传送，以及各种准备会使得一次指令的总的执行时间边长</li><li>优化流水线的使用和处理存储器及寄存器相关性所需要的控制逻辑总量，会随着流水线阶段数的增长而急剧增长</li><li><strong>锁存延迟</strong>，即流水线阶段之间的缓冲需要一定时间来完成其操作，这也会增加指令周期的时间</li></ul><p><strong>6.流水线性能</strong>：</p><ul><li>$t_{i}$:流水线第$i$段的延迟</li><li>$t_{m}$:最大段延迟</li><li>$k$:指令流水线段数</li><li>$d$:所存延迟</li><li>$t = max[ t_{i} ] + d = t_{m} + d$ -&gt; $t$: 指令流水线周期</li><li>假设$n$条指令没有条件转移的在进行，$T_{k, n} = [ k + (n - 1)] t$表示k段流水线执行n条指令所需的总时间</li><li>完成第一条指令需要k个周期，其余n-1条指令需要n-1个周期</li><li>加速比$S_{k} = T_{1, n} / T_{k, n} = nk / (k + n - 1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

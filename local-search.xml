<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cache存储器</title>
    <link href="/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>Cache存储器</h1><h2 id="1-为什么使用Cache？">1. 为什么使用Cache？</h2><ol><li>内存墙的存在（内存性能严重限制CPU性能的发挥）</li></ol><h2 id="2-解决内存墙问题的方法">2. 解决内存墙问题的方法</h2><ol><li>同时使用速度快容量小的Cache与速度慢容量大的存储块</li><li>cache包含主存一部分内存的副本</li><li>cache位于CPU和主存之间，或者位于CPU内部</li></ol><h2 id="3-Cache如何工作得？">3. Cache如何工作得？</h2><ul><li>check：当处理器需要读取一个数据时，先去cache里检查一下是否在cache里</li><li>hit：如果在，直接将这个数据传给处理器</li><li>miss：如果不在，从主存中将包括这个数据的固定大小的块写进cache，并把需要的数据传给处理器</li></ul><p><img src="/img/article_img/cache1.png" alt="cache workFlow"></p><h2 id="4-cache工作流程的一些问题">4. cache工作流程的一些问题</h2><ul><li>如何确定一个数据是否在cache里？<ul><li>冯诺依曼计算机结构确定“无论什么数据都是以相同的方式寻址”</li><li>cache包含一个tag用来确定cache的某一行对应主存的那一部分</li><li>内存中的数据是由标签来进行指向的，而不是依据数据类型进行访问</li></ul></li><li>为什么在cache-miss时是从主存中读取一个块而不是一个字？<ul><li>因为程序的局部性原理</li><li>在程序执行过程中，处理器会倾向于向一块地方集中的访问数据</li><li>局部性分为：<ul><li>时间局部性</li><li>空间局部性</li><li>顺序访问（数组之类的）</li></ul></li></ul></li></ul><p><img src="/img/article_img/cache2.png" alt="temporal locality"></p><p><img src="/img/article_img/cache3.png" alt="spatial locality"></p><h2 id="5-把数据搬到Cache">5. 把数据搬到Cache</h2><ul><li>使用时间局部性</li><li>经典的cache组织</li></ul><p><img src="/img/article_img/cache4.png" alt="typical cache organization"></p><h2 id="6-一次搬用一整块内容而不是一个字">6. 一次搬用一整块内容而不是一个字</h2><ul><li>使用空间局部性原理</li><li>cache结构</li></ul><p><img src="/img/article_img/cache5.png" alt="cache structure"></p><h2 id="7-同比起来，使用cache会多更多的操作，为什么能节省时间呢？">7. 同比起来，使用cache会多更多的操作，为什么能节省时间呢？</h2><ul><li>访问cache的速度比访问内存的速度快很多</li><li>由于局部性原理的存在，cache的命中率会比较高</li><li>一次搬用一个块的数据比多次搬用一个字的时间少</li></ul><h2 id="8-平均访问时间">8. 平均访问时间</h2><ul><li><p>假设命中率为$p$，$T_{c}$为访问cache的时间，$T_{m}$是访问存储器的时间，那么平均访问时间为：$T_{A} = pT_{c} + (1-p)(T_{c} + T_{M}) = T_{c} + (1-p)T_{M}$</p></li><li><p>当$p &gt; T_{c} / T_{M}$时，$T_{A} &lt; T_{M}$</p></li><li><p>问题：cache的容量远小于存储器的容量</p></li></ul><h2 id="9-cache设计考虑因素">9. cache设计考虑因素</h2><ul><li>大小</li><li>映射策略</li><li>替换策略</li><li>写策略</li><li>行大小</li><li>数量</li></ul><h2 id="10-Cache-Size">10. Cache Size</h2><ul><li>增加行大小 -&gt; 增加命中率$p$, 同时也会增加cache的访问时间</li><li><img src="/img/article_img/cache6.png" alt="cache_size_hit _ratio"></li></ul><h2 id="11-Mapping-Function">11. Mapping Function</h2><ul><li>用来将主中的块映射到cache行的策略/算法</li><li>一种覆盖cache中哪一行的策略</li><li>映射函数的选择决定了cache行的组织</li><li>类型：<ul><li>直接映射</li><li>全相关映射</li><li>组相关映射</li></ul></li></ul><h4 id="1-直接映射">1. 直接映射</h4><ul><li>将存储器中的块固定的对应于cache中可以用的行中</li><li>$i = j mod C$, $i$:cache行号，$j$:数据块的块号, $C$:cache总行数</li><li>tag：前n位，$n = log_{2}M - log_{2}C$</li></ul><p><img src="/img/article_img/cache7.png" alt="​address​"></p><p><strong>1. 优点</strong>：</p><ul><li>简单</li><li>映射速度快</li><li>检查速度快</li></ul><p><strong>2.缺点</strong>：</p><ul><li>抖动大：当一个程序需要多次交替的访问两个映射在同一行的块，会发生多次的块替换</li></ul><p>comment：适用于大容量的cache</p><h4 id="2-全相关映射">2. 全相关映射</h4><ul><li>允许将存储器中的块映射到cache的任意行</li><li>tag：前n位， $n = log_{2}M$</li></ul><p><img src="/img/article_img/cache8.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>避免了抖动</li></ul><p><strong>2.缺点</strong>：</p><ul><li>复杂的实现</li><li>cache的查询消耗大</li></ul><p>comment：是用于小容量的cache</p><h4 id="3-组相关映射">3. 组相关映射</h4><ul><li>cache被分为$s$个组，每组$k$行。</li><li>$j$为块号，$i = j mod s$，第j块被映射到第i组。</li><li>称为k-路组</li><li>tag：前n位，$n = log_{2}M - log_{2}S$</li></ul><p><img src="/img/article_img/cache9.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>集成了直接映射和全相关映射的优点</li></ul><p><strong>2. 缺点</strong>：</p><ul><li>同时也集成了直接映射和全相关映射的缺点</li></ul><p>comment：对任意容量的cache在性能上进行了很好的权衡</p><h2 id="12-映射策略的对比">12. 映射策略的对比</h2><h5 id="1-相关性：每个块可能在cache中的行数">1. 相关性：每个块可能在cache中的行数</h5><ul><li>直接映射：1</li><li>全相关映射：C</li><li>组相关映射：k</li></ul><h5 id="2-相关性与性能">2. 相关性与性能</h5><ul><li>相关性越低，命中率越低</li><li>相关性越低，检查速度越快</li><li>相关性越低，tag长度越短</li></ul><h2 id="13-替换策略">13. 替换策略</h2><ol><li><p>当cache的行被填充时，一个新的块需要插入cache，那么此时就可能将cache中已有的块丢弃，也就是替换掉</p></li><li><p>对于直接映射：一个确定的块有且只有一个对应的cache行可以装填</p></li><li><p>对于全相关和组相关映射而言，替换策略是必需的，并且必须通过硬件来实现。</p></li><li><p><strong>最常用的集中替换算法</strong></p><ul><li>least recently use（LRU）-- 最近最少使用</li><li>first in first out（FIFO）-- 先进先出</li><li>least frequently used（LFU）-- 最不经常被使用</li><li>random – 随机</li></ul><h4 id="1-LRU">1. LRU</h4><ul><li>根据最近一次被用到的时间进行排序<ul><li>以二路组为例，我们将一位置为1，则另一位被置为0</li></ul></li><li>替换cache中当前最长时间没被使用的块</li><li>将设最近被使用的块不久还将会被使用</li><li>特别适合二路组关联映射</li></ul><h4 id="2-FIFO">2. FIFO</h4><ul><li>和使用时间关系不大，根据进入cache的时间来排序</li><li>假设越靠后的数据越容易被再次使用到</li><li>实现：循环/循环缓冲技术</li><li>通过计数器来时间（时间戳）</li></ul><h4 id="3-Random">3.Random</h4><ul><li>随机的替换对应的行</li><li>假设每个存储位置都等概率被再次访问到</li></ul></li></ol><h2 id="14-写策略">14. 写策略</h2><ul><li>内存与cache的一致性要求<ul><li>当一个块在cache中被替换时，需要考虑块是否被个别更改可</li></ul></li><li>两种情况：<ul><li>如果没有更改，可以直接替换</li><li>如果更改了，对应在内存中的块需要被更新</li></ul></li><li>两种策略：<ul><li>写入法（write through）</li><li>写回法（write back）</li></ul></li></ul><h4 id="1-写入法">1. 写入法</h4><ul><li><p>当cache中的行发生改变时，立即对内存中对应的块进行更新</p></li><li><p>优点：确保了内存中的数据始终被更新过了</p></li><li><p>缺点：</p><ul><li><p>产生大量的内存访问，出现时间瓶颈</p></li><li><p>减慢了写操作</p></li></ul></li></ul><h4 id="2-写回法">2. 写回法</h4><ul><li>只更新cache中的数据，当这个快被替换或者遇到I/O操作需要对主存这块区域读取数据时，才发生更新</li><li>使用dirty bit/ use bit，来代表是否被修改了</li><li>优点：减少了对内存的写操作</li><li>缺点：内存中对应的内容时过时的，因此当存在I/O操作时，只能允许通过cache进行，因此会造成复杂的电路以及潜在的瓶颈</li></ul><h2 id="15-行大小">15. 行大小</h2><ul><li>当行大小从很小的容量增加到比较大的容量时：<ul><li>命中率提高</li><li>更多有用的数据可以被带入cache</li></ul></li><li>当行大小变的非常大时：<ul><li>命中率提高，但提高的速度明显减慢<ul><li>更大的行，导致cache的行数减少，这将导致频繁的替换</li><li>每个额外的字都会离被需要的字更远，因此更小的可能性会在不久的将来被访问在</li></ul></li></ul></li><li>块大小和命中率之间的关系更加复杂</li></ul><h2 id="16-cache行数量">16. cache行数量</h2><ul><li>unified（统一）：<ul><li>提高指令与数据负载自动平衡的命中率</li><li>只有一个cache需要被设计和实现</li></ul></li><li>split（分隔）：<ul><li>消除指令获取/解码单元和执行单元之间对缓存的争用，这对指令的流水线很重要</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU结构和功能</title>
    <link href="/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1>CPU结构和功能</h1><h3 id="一、CPU的任务">一、CPU的任务</h3><ul><li>取指令：从存储器（register、main-memory、cache）读取指令</li><li>解释指令：对指令解码，确定要进行的操作</li><li>取数据：指令的执行可能需要从存储器或I/O中读取数据</li><li>处理数据：对数据完成要求的算术/逻辑运算</li><li>写数据：执行的结果可能需要写回存储器或I/O</li></ul><h3 id="二、CPU的要求">二、CPU的要求</h3><ul><li>CPU能暂时的存储部分数据</li><li>CPU必须知道当前执行指令的位置，以便获取下一条指令的位置</li><li>CPU必须在执行指令期间保存指令和数据</li></ul><p><img src="/img/article_img/cpu_structure_function1.jpg" alt="cpu简介图"></p><p><img src="/img/article_img/cpu_structure_function2.jpg" alt="cpu详介图"></p><h3 id="三、寄存器的组成">三、寄存器的组成</h3><h4 id="1-CPU中寄存器主要可以分为两类：">1. CPU中寄存器主要可以分为两类：</h4><ul><li>用户可见寄存器：允许机器语言或者汇编语言的编程人员通过优化寄存器的使用而减少对内存的访问</li><li>控制和状态寄存器：由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行</li></ul><h4 id="2-用户可见寄存器：">2. 用户可见寄存器：</h4><ul><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：用于保存数据，不能用于操作数地址的计算</li><li>地址寄存器：用于可以是自身有某种通用性或者专用性的寻址方式</li><li>标志寄存器：保存条件码、允许程序员读出，但不能更改</li></ul><h4 id="3-寄存器的设计出发点：">3. 寄存器的设计出发点：</h4><ul><li>使用完全通用寄存器还是规定各寄存器的用途</li><li>寄存器的数量</li><li>寄存器的长度</li></ul><h4 id="4-控制和状态寄存器：">4. 控制和状态寄存器：</h4><ul><li>程序计数器（PC）：存放待取指令的地址</li><li>指令寄存器（IR）：存放最近取来的地址</li><li>存储器地址寄存器（MAR）：存放存储器位置的地址</li><li>存储器缓冲寄存器（MBR）：存有将被写入或最近从存储器读出的字</li></ul><h4 id="5-程序状态字（PSW）：">5. 程序状态字（PSW）：</h4><ul><li>符号（sign）：容纳算术运算结果的符号位</li><li>零（zero）：当结果是0时置位</li><li>进位（carry）：操作导致向最高位有向上进位或借位时被置位</li><li>等于（equal）：逻辑结果相等置位</li><li>溢出（overflow）：用于指示算术运算溢出</li><li>中断允许/禁止（interrupt enable/disable）：用于允许/禁止中断</li><li>监管（supervisor）：指出CPU是执行在监管模式还是用户模式</li></ul><h4 id="6-设计控制和状态寄存器组织时考虑的几个因素：">6. 设计控制和状态寄存器组织时考虑的几个因素：</h4><ul><li>考虑对操作系统的支持（某些控制信息专门为控制操作系统使用）</li><li>考虑控制信息在寄存器和存储器之间的分配</li></ul><h4 id="7-指令周期：">7. 指令周期：</h4><ul><li>取指：将下一条指令从存储器中读入CPU</li><li>执行；解释操作码并完成指定操作</li><li>中断：如果中断允许并且有中断发生，则保存当前状态执行中断</li></ul><h4 id="8-间接周期：">8. 间接周期：</h4><ul><li>指令的执行可能涉及到内存中的一个或多个操作数，并且每个操作数都需要内存访问</li><li>如果使用间接地址，需要额外的内存访问</li><li>将间接地址的获取视为一个或多个指令周期</li></ul><p><img src="/img/article_img/cpu_structure_function3.png" alt="指令周期"></p><p><img src="/img/article_img/cpu_structure_function4.png" alt="指令周期状态图"></p><h4 id="9-数据流：">9. 数据流：</h4><ol><li><p><img src="/img/article_img/cpu_structure_function5.png" alt="数据流与取指周期"></p><ul><li>控制器向PC发送请求 -&gt; PC将存有的下一条指令的地址传给MAR -&gt; MAR放到地址总线上</li><li>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号 -&gt; 存储器获取指令地址并将对应的指令放到数据总线上</li><li>MBR从数据总线上获取指令然后传给IR</li></ul></li><li><p><img src="/img/article_img/cpu_structure_function6.png" alt="数据流间接周期"></p><ul><li><p>MBR存储的是指令的地址 -&gt; MBR将地址传给MAR -&gt; MAR将该地址传放到地址总线上</p></li><li><p>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号并读取指令的地址</p></li><li><p>存储器根据地址将对应指令放到数据线上 -&gt; MBR读取指令</p></li></ul><p><img src="/img/article_img/cpu_structure_function7.png" alt=""></p><ul><li>控制器向MAR传送信号 -&gt; MAR将当前数据要保存到的地址放到地址总线上</li><li>控制器向PC传送信号 -&gt; PC将当前要保存的数据传入MBR -&gt; MBR将数据放到数据总线上</li><li>控制器向控制总线上发送信号 -&gt; 存储器读取信号 -&gt; 存储器从地址总线上接收地址，并从数据总线上接收数据</li><li>存储器将数据写入对应的地址</li></ul></li></ol><h3 id="四、指令流水线技术：">四、指令流水线技术：</h3><p><strong>1. 流水线技术</strong>：把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</p><p><strong>2. 对指令执行使用流水线技术</strong>：显然能够加快指令的执行，但是使得执行速度翻倍是不可能的，原因如下：</p><ul><li>执行时间一般长于指令的执行（执行指令和取指令都可能使用I/O，所以会产生冲突，一次只能有一个进行）</li><li>条件分支指令使得待取的下一条指令的地址未知（当多条指令执行了一些步骤后，遇到跳转指令，这些指令执行的步骤将会作废）</li></ul><p><strong>3.对指令执行的细分</strong>（为了进一步加速）：</p><ul><li>取指：获取下一条要执行指令到MBR</li><li>译码：解析指令，确定操作码、操作数</li><li>计算操作数：计算源操作数的有效地址</li><li>取操作数：从存储器中读取操作数（寄存器中的数据不需要读取）</li><li>执行：完成指定操作</li><li>写回操作数：将结果写回存储器</li></ul><p><strong>4. 几个限制性能提升的因素</strong>：</p><ul><li>细分的各个阶段时间不完全相等</li><li>遇到条件转移指令时，之前进行的指令会作废</li><li>寄存器和存储器可能产生冲突</li></ul><p><strong>5. 人们认为流水线中阶段越多，执行速度越快？No</strong></p><ul><li>流水线的每一阶段，都会有某些开销设计数据在MBR间的传送，以及各种准备会使得一次指令的总的执行时间边长</li><li>优化流水线的使用和处理存储器及寄存器相关性所需要的控制逻辑总量，会随着流水线阶段数的增长而急剧增长</li><li><strong>锁存延迟</strong>，即流水线阶段之间的缓冲需要一定时间来完成其操作，这也会增加指令周期的时间</li></ul><p><strong>6.流水线性能</strong>：</p><ul><li>$t_{i}$:流水线第$i$段的延迟</li><li>$t_{m}$:最大段延迟</li><li>$k$:指令流水线段数</li><li>$d$:所存延迟</li><li>$t = max[ t_{i} ] + d = t_{m} + d$ -&gt; $t$: 指令流水线周期</li><li>假设$n$条指令没有条件转移的在进行，$T_{k, n} = [ k + (n - 1)] t$表示k段流水线执行n条指令所需的总时间</li><li>完成第一条指令需要k个周期，其余n-1条指令需要n-1个周期</li><li>加速比$S_{k} = T_{1, n} / T_{k, n} = nk / (k + n - 1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

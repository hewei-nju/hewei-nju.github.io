<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数的表示</title>
    <link href="/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1>数的表示</h1><h2 id="1-二进制表示">1. 二进制表示</h2><ol><li>为了表示多个数值，必须对多个位进行组合<ul><li>如果有k位，最多能区分出$2^{k}$个不同的值</li></ul></li></ol><h2 id="2-整数类型：">2. 整数类型：</h2><ul><li>无符号整数</li><li>有符号整数： 原码、反码、补码<ul><li>原码和反码在进行加法运算时都会造成不必要的硬件需求，于是出现了补码</li></ul></li></ul><ol><li><p>补码表示：</p><p>$ [X]<em>{c} = X</em>{n}X_{n-1}…X_{2}X_{1} $</p><p>=&gt; $X = -X_{n}*2^{n-1} + … + X_{2} * 2^{1} + X_{1} * 2^{0} =&gt; (-2^{n-1} &lt;= X&lt;= 2^{n-1} - 1) $</p></li></ol><h2 id="3-浮点数表示">3. 浮点数表示</h2><ol><li>实数表示（科学计数法）</li><li><strong>定点表示法</strong>的值的范围极大的被限制了</li><li>科学计数法: $\pm S*B^{\pm E}$<ul><li>$\pm$: plus or minus</li><li>S: significant</li><li>B: base</li><li>E: exponent</li></ul></li><li><img src="/img/article_img/compute1.png" alt="representation"></li><li>规格化的数：<ul><li>任何一个浮点数都能表示为多个式子：$0.110 \times 2^{5}, 110 \times 2^{2}$</li><li>规格化表示：$\pm 1.bbb…b \times 2^{\pm E}$</li><li>符号位：第一位</li><li>第一位有效数字是 1 ；不需要保存在有效字段中</li><li>真正的$e = E - 127$</li><li>基是2</li></ul></li><li><img src="/img/article_img/compute2.png" alt="value range"></li><li>精度和范围之间有一个平衡：<ul><li>增加exponent的位数，意味着减少S的位数，即扩大表示范围-&gt;精度减少；反之亦然</li></ul></li><li>使用更大的基底？<ul><li>获得了更大的表示范围，同时也会减小精度</li></ul></li></ol><h2 id="4-IEEE-Standard-754">4. IEEE Standard 754</h2><ul><li>确定了32位/64位浮点数的格式</li><li><img src="/img/article_img/compute3.png" alt="format"></li><li>确定了两种扩展方式<ul><li>包括了指数域和有效值域的扩展</li><li>减少了高度交换数据带来的错误和中间溢出</li><li><img src="/img/article_img/compute4.png" alt="interpretation"></li></ul></li></ul><h2 id="5-十进制表示">5. 十进制表示</h2><ul><li>浮点数的算术问题：<ul><li>精度的限制</li><li>高代价的转换</li><li>应用需求：<ul><li>计算长的字符串表示的数字、可计算的</li></ul></li><li>解决方案：<ul><li>使用4位2进制表示0，1，…，9（BCD, Binary-Coded Decimal)</li></ul></li></ul></li><li>Natural Binary Coded Decimal (NBCD, 8421code)<ul><li>0 - 9: 0000 - 1001</li><li>sign:<ul><li>p: 1100/0</li><li>n: 1101/1</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机功能和互连的顶层视图</title>
    <link href="/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
    <url>/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1>计算机功能和互连的顶层视图</h1><p><img src="/img/article_img/top_view1.png" alt="Top level view"></p><h1>1. 计算机元素</h1><ol><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li><li>执行指令的顺序是从当前指令到下一个，除非显式的修改</li></ol><h3 id="1-Memory">1. Memory</h3><ol><li>单个的存储器<ul><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li></ul></li></ol><p><img src="/img/article_img/top_view2.png" alt="Memory"></p><ol start="2"><li>问题：数据在CPU和主存中传输的速度远远的慢于CPU执行的速度</li></ol><p><img src="/img/article_img/top_view3.png" alt="Memory wall"></p><ol start="3"><li><p>解决方法：</p><ul><li>增加一个cache或者其他的缓冲装置来减少CPU对主存的访问频率</li><li>增加一次传输的数据宽度</li></ul></li><li><p>约束：</p><ul><li>容量：越大越好</li><li>速度：能够跟得上处理器</li><li>价格：相对于其他组件合理</li></ul></li><li><p>约束之间的关系：</p><ul><li>更短的访问时间、每位数据的开销更大</li></ul></li><li><p>需求：</p><ul><li>大容量的数据存储</li><li>高速度的访问性能</li></ul></li><li><p>解决方案：</p><ul><li>采用一种层次结构而不是单个的存储器</li></ul></li></ol><p><img src="/img/article_img/top_view4.png" alt="hierarchy"></p><h3 id="2-I-O">2. I/O</h3><ol><li><p>在外设和CPU、主存之间交换数据</p></li><li><p>问题：I/O的性能跟不上CPU的执行速度</p></li></ol><p><img src="/img/article_img/top_view5.png" alt="I/O performance"></p><ol start="3"><li>解决方法：<ul><li>缓冲机制</li><li>新的接口技术</li></ul></li></ol><h3 id="3-CPU">3. CPU</h3><ol><li><p>从一条执行到下一条，除非发生显示的改变</p></li><li><p>问题：CPU会经常出于空闲状态等待I/O设备读写完成</p></li><li><p>解决方法：</p><ul><li><p>中断：其他设备可以中断正常的执行过程的机制</p></li><li><p>中断检测：在指令周期里加上一个中断周期</p><p><img src="/img/article_img/top_view6.png" alt="interrupt detection"></p></li></ul></li><li><p>多级中断：</p><ul><li><img src="/img/article_img/top_view7.png" alt="sequential interrupt processing"></li><li><img src="/img/article_img/top_view8.png" alt="nested interrupt processing"></li></ul></li></ol><p><img src="/img/article_img/top_view9.png" alt="theoretical max performance"></p><h3 id="4-Bus">4. Bus</h3><ol><li>总线是一种连接多个设备的数据传输通路</li></ol><p><img src="/img/article_img/top_view10.png" alt="interconnection solution"></p><ol start="2"><li>数据传输类型：任何总线都可以被分为三种类型<ul><li>数据线：在系统模块中传输数据</li><li>地址线：指定数据源或接收数据的端口，也就是传输地址</li><li>控制线：控制设备对数据线地址线上的内容的读取</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概论</title>
    <link href="/2020/12/16/%E6%A6%82%E8%AE%BA/"/>
    <url>/2020/12/16/%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1>概论</h1><h3 id="1-结构和组织">1. 结构和组织</h3><ul><li>计算机结构：对程序员可见的系统属性，这些属性直接决定了程序的逻辑执行<ul><li>指令集、数据类型、输入输出机制、寻址技术</li></ul></li><li>计算机组成：实现结构规范的操作单元及其互连<ul><li>硬件细节，如控制信号、计算机和外设的接口以及存储器使用的技术</li></ul></li></ul><h2 id="2-冯诺伊曼机">2. 冯诺伊曼机</h2><ul><li>组成部分：<ul><li>存储器：地址和存储的内容</li><li>处理单元：执行信息的实际处理</li><li>控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li></ul><p><img src="/img/article_img/intro1.png" alt="冯诺依曼机结构图"></p><ul><li>重要思想：存储程序，及把数中据和程序存储到计算机中</li></ul><h2 id="3-摩尔定律">3. 摩尔定律</h2><ul><li>内容：单芯片上包含的晶体管数量每年/18个月翻一番</li><li>影响：<ul><li>因为单片芯片的价格不变而导致芯片的逻辑电路和存储器电路成本显著下降</li><li>更小的体积使得更容易放置在各种环境中</li><li>更短的电路提高了芯片的工作速度</li><li>减少了电能的消耗和冷却的要求</li><li>集成电路上的连接比焊接更加可靠，由于芯片电路的增加，减少了芯片之间的连接。</li></ul></li></ul><p><img src="/img/article_img/intro2.png" alt="data process"></p><h2 id="4-计算机性能">4. 计算机性能</h2><ul><li>重要参数：外观、价格、大小、安全性、稳定性、续航</li><li>用来评估的一些标准：<ul><li>CPU： speed</li><li>Memory：capacity、speed</li><li>I/O：capacity、speed</li></ul></li></ul><p><strong>main goal/driver</strong>： increase of CPU speed</p><h2 id="5-CPU性能">5. CPU性能</h2><ul><li><p>系统时钟：</p><ul><li>时钟频率/时钟速度：一秒钟内计算运转的周期数</li><li>clock cycle/clock tick：单次CPU的脉冲/时钟称为一个时钟周期/时钟滴答声</li><li>周期时间：两次脉冲间的时间</li><li>处理器的速度由时钟产生的脉冲频率来指示，用每秒周期数/赫兹数测量</li></ul></li><li><p>指令执行速度：</p><ul><li>处理器由时钟驱动，时钟固定频率为$f$或等价为固定时钟周期$t$, $t = 1/ f$</li><li>$I_{c}$: 一个程序的指令条数</li><li>$CPI(average cycle per instruction)$:每条指令的平均周期数</li><li>$CPI_{i}$: $i$类型执行所需周期数；$I_{i}$：某一给定程序中所执行的$i$类型指令的条数</li><li><img src="/img/article_img/intro3.png" alt="CPI"></li><li>处理器执行完一个给定的程序所需的时间$T = I_{c} * CPI * t$</li><li><img src="/img/article_img/intro4.png" alt="T"></li><li><img src="/img/article_img/intro5.png" alt="MIPS"></li><li>$R_{i}$时第i个程序高级语言指令执行的速度</li><li><img src="/img/article_img/intro6.png" alt="平均结果"></li></ul></li><li><p><strong>基本来说，用户更加关心系统的执行时间，而非它的执行速度。如果我们获得了各种测试程序的指令执行速度的算术平均值，那么我们就一定能得到一个与执行时间倒数之和成正比的结果，但这不与执行时间之和成反比。</strong></p></li><li><p><strong>指令执行速度的算术平均值并不能准确地刻画执行时间；另一方面，指令执行速度的调和平均值是平均执行时间的倒数</strong></p></li><li><p>阿姆达尔定律：</p><ul><li><p>考虑系统性能，人们会通过改变技术/设计来提高性能，如并行处理器、cache的使用、高速I/O访问等。</p></li><li><p>但之加速技术/设计的一个方面并不能很好的提高性能的相应改善。</p></li><li><p>一个程序在多处理器上运行与单处理器上运行的加速比：</p><p>假设一个程序有$f$可以无限并行，无调度负载；$(1-f)$只能串行；$T_{sin}$:单个处理器上运行的时间；$T_{n}$:n个处理器系统上运行的时间；则</p><p>$speedup = T_{sin} / T_{n} = [T(1-f) + Tf] / [T(1-f) + Tf/ n] = 1 / [1-f + f / n]$</p><ol><li>f非常小，使用并行处理器有一些影响</li><li>n的增大，加速比被限制</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache存储器</title>
    <link href="/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>Cache存储器</h1><h2 id="1-为什么使用Cache？">1. 为什么使用Cache？</h2><ol><li>内存墙的存在（内存性能严重限制CPU性能的发挥）</li></ol><h2 id="2-解决内存墙问题的方法">2. 解决内存墙问题的方法</h2><ol><li>同时使用速度快容量小的Cache与速度慢容量大的存储块</li><li>cache包含主存一部分内存的副本</li><li>cache位于CPU和主存之间，或者位于CPU内部</li></ol><h2 id="3-Cache如何工作得？">3. Cache如何工作得？</h2><ul><li>check：当处理器需要读取一个数据时，先去cache里检查一下是否在cache里</li><li>hit：如果在，直接将这个数据传给处理器</li><li>miss：如果不在，从主存中将包括这个数据的固定大小的块写进cache，并把需要的数据传给处理器</li></ul><p><img src="/img/article_img/cache1.png" alt="cache workFlow"></p><h2 id="4-cache工作流程的一些问题">4. cache工作流程的一些问题</h2><ul><li>如何确定一个数据是否在cache里？<ul><li>冯诺依曼计算机结构确定“无论什么数据都是以相同的方式寻址”</li><li>cache包含一个tag用来确定cache的某一行对应主存的那一部分</li><li>内存中的数据是由标签来进行指向的，而不是依据数据类型进行访问</li></ul></li><li>为什么在cache-miss时是从主存中读取一个块而不是一个字？<ul><li>因为程序的局部性原理</li><li>在程序执行过程中，处理器会倾向于向一块地方集中的访问数据</li><li>局部性分为：<ul><li>时间局部性</li><li>空间局部性</li><li>顺序访问（数组之类的）</li></ul></li></ul></li></ul><p><img src="/img/article_img/cache2.png" alt="temporal locality"></p><p><img src="/img/article_img/cache3.png" alt="spatial locality"></p><h2 id="5-把数据搬到Cache">5. 把数据搬到Cache</h2><ul><li>使用时间局部性</li><li>经典的cache组织</li></ul><p><img src="/img/article_img/cache4.png" alt="typical cache organization"></p><h2 id="6-一次搬用一整块内容而不是一个字">6. 一次搬用一整块内容而不是一个字</h2><ul><li>使用空间局部性原理</li><li>cache结构</li></ul><p><img src="/img/article_img/cache5.png" alt="cache structure"></p><h2 id="7-同比起来，使用cache会多更多的操作，为什么能节省时间呢？">7. 同比起来，使用cache会多更多的操作，为什么能节省时间呢？</h2><ul><li>访问cache的速度比访问内存的速度快很多</li><li>由于局部性原理的存在，cache的命中率会比较高</li><li>一次搬用一个块的数据比多次搬用一个字的时间少</li></ul><h2 id="8-平均访问时间">8. 平均访问时间</h2><ul><li><p>假设命中率为$p$，$T_{c}$为访问cache的时间，$T_{m}$是访问存储器的时间，那么平均访问时间为：$T_{A} = pT_{c} + (1-p)(T_{c} + T_{M}) = T_{c} + (1-p)T_{M}$</p></li><li><p>当$p &gt; T_{c} / T_{M}$时，$T_{A} &lt; T_{M}$</p></li><li><p>问题：cache的容量远小于存储器的容量</p></li></ul><h2 id="9-cache设计考虑因素">9. cache设计考虑因素</h2><ul><li>大小</li><li>映射策略</li><li>替换策略</li><li>写策略</li><li>行大小</li><li>数量</li></ul><h2 id="10-Cache-Size">10. Cache Size</h2><ul><li>增加行大小 -&gt; 增加命中率$p$, 同时也会增加cache的访问时间</li><li><img src="/img/article_img/cache6.png" alt="cache_size_hit _ratio"></li></ul><h2 id="11-Mapping-Function">11. Mapping Function</h2><ul><li>用来将主中的块映射到cache行的策略/算法</li><li>一种覆盖cache中哪一行的策略</li><li>映射函数的选择决定了cache行的组织</li><li>类型：<ul><li>直接映射</li><li>全相关映射</li><li>组相关映射</li></ul></li></ul><h4 id="1-直接映射">1. 直接映射</h4><ul><li>将存储器中的块固定的对应于cache中可以用的行中</li><li>$i = j mod C$, $i$:cache行号，$j$:数据块的块号, $C$:cache总行数</li><li>tag：前n位，$n = log_{2}M - log_{2}C$</li></ul><p><img src="/img/article_img/cache7.png" alt="​address​"></p><p><strong>1. 优点</strong>：</p><ul><li>简单</li><li>映射速度快</li><li>检查速度快</li></ul><p><strong>2.缺点</strong>：</p><ul><li>抖动大：当一个程序需要多次交替的访问两个映射在同一行的块，会发生多次的块替换</li></ul><p>comment：适用于大容量的cache</p><h4 id="2-全相关映射">2. 全相关映射</h4><ul><li>允许将存储器中的块映射到cache的任意行</li><li>tag：前n位， $n = log_{2}M$</li></ul><p><img src="/img/article_img/cache8.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>避免了抖动</li></ul><p><strong>2.缺点</strong>：</p><ul><li>复杂的实现</li><li>cache的查询消耗大</li></ul><p>comment：是用于小容量的cache</p><h4 id="3-组相关映射">3. 组相关映射</h4><ul><li>cache被分为$s$个组，每组$k$行。</li><li>$j$为块号，$i = j mod s$，第j块被映射到第i组。</li><li>称为k-路组</li><li>tag：前n位，$n = log_{2}M - log_{2}S$</li></ul><p><img src="/img/article_img/cache9.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>集成了直接映射和全相关映射的优点</li></ul><p><strong>2. 缺点</strong>：</p><ul><li>同时也集成了直接映射和全相关映射的缺点</li></ul><p>comment：对任意容量的cache在性能上进行了很好的权衡</p><h2 id="12-映射策略的对比">12. 映射策略的对比</h2><h5 id="1-相关性：每个块可能在cache中的行数">1. 相关性：每个块可能在cache中的行数</h5><ul><li>直接映射：1</li><li>全相关映射：C</li><li>组相关映射：k</li></ul><h5 id="2-相关性与性能">2. 相关性与性能</h5><ul><li>相关性越低，命中率越低</li><li>相关性越低，检查速度越快</li><li>相关性越低，tag长度越短</li></ul><h2 id="13-替换策略">13. 替换策略</h2><ol><li><p>当cache的行被填充时，一个新的块需要插入cache，那么此时就可能将cache中已有的块丢弃，也就是替换掉</p></li><li><p>对于直接映射：一个确定的块有且只有一个对应的cache行可以装填</p></li><li><p>对于全相关和组相关映射而言，替换策略是必需的，并且必须通过硬件来实现。</p></li><li><p><strong>最常用的集中替换算法</strong></p><ul><li>least recently use（LRU）-- 最近最少使用</li><li>first in first out（FIFO）-- 先进先出</li><li>least frequently used（LFU）-- 最不经常被使用</li><li>random – 随机</li></ul><h4 id="1-LRU">1. LRU</h4><ul><li>根据最近一次被用到的时间进行排序<ul><li>以二路组为例，我们将一位置为1，则另一位被置为0</li></ul></li><li>替换cache中当前最长时间没被使用的块</li><li>将设最近被使用的块不久还将会被使用</li><li>特别适合二路组关联映射</li></ul><h4 id="2-FIFO">2. FIFO</h4><ul><li>和使用时间关系不大，根据进入cache的时间来排序</li><li>假设越靠后的数据越容易被再次使用到</li><li>实现：循环/循环缓冲技术</li><li>通过计数器来时间（时间戳）</li></ul><h4 id="3-Random">3.Random</h4><ul><li>随机的替换对应的行</li><li>假设每个存储位置都等概率被再次访问到</li></ul></li></ol><h2 id="14-写策略">14. 写策略</h2><ul><li>内存与cache的一致性要求<ul><li>当一个块在cache中被替换时，需要考虑块是否被个别更改可</li></ul></li><li>两种情况：<ul><li>如果没有更改，可以直接替换</li><li>如果更改了，对应在内存中的块需要被更新</li></ul></li><li>两种策略：<ul><li>写入法（write through）</li><li>写回法（write back）</li></ul></li></ul><h4 id="1-写入法">1. 写入法</h4><ul><li><p>当cache中的行发生改变时，立即对内存中对应的块进行更新</p></li><li><p>优点：确保了内存中的数据始终被更新过了</p></li><li><p>缺点：</p><ul><li><p>产生大量的内存访问，出现时间瓶颈</p></li><li><p>减慢了写操作</p></li></ul></li></ul><h4 id="2-写回法">2. 写回法</h4><ul><li>只更新cache中的数据，当这个快被替换或者遇到I/O操作需要对主存这块区域读取数据时，才发生更新</li><li>使用dirty bit/ use bit，来代表是否被修改了</li><li>优点：减少了对内存的写操作</li><li>缺点：内存中对应的内容时过时的，因此当存在I/O操作时，只能允许通过cache进行，因此会造成复杂的电路以及潜在的瓶颈</li></ul><h2 id="15-行大小">15. 行大小</h2><ul><li>当行大小从很小的容量增加到比较大的容量时：<ul><li>命中率提高</li><li>更多有用的数据可以被带入cache</li></ul></li><li>当行大小变的非常大时：<ul><li>命中率提高，但提高的速度明显减慢<ul><li>更大的行，导致cache的行数减少，这将导致频繁的替换</li><li>每个额外的字都会离被需要的字更远，因此更小的可能性会在不久的将来被访问在</li></ul></li></ul></li><li>块大小和命中率之间的关系更加复杂</li></ul><h2 id="16-cache行数量">16. cache行数量</h2><ul><li>unified（统一）：<ul><li>提高指令与数据负载自动平衡的命中率</li><li>只有一个cache需要被设计和实现</li></ul></li><li>split（分隔）：<ul><li>消除指令获取/解码单元和执行单元之间对缓存的争用，这对指令的流水线很重要</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU结构和功能</title>
    <link href="/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1>CPU结构和功能</h1><h3 id="一、CPU的任务">一、CPU的任务</h3><ul><li>取指令：从存储器（register、main-memory、cache）读取指令</li><li>解释指令：对指令解码，确定要进行的操作</li><li>取数据：指令的执行可能需要从存储器或I/O中读取数据</li><li>处理数据：对数据完成要求的算术/逻辑运算</li><li>写数据：执行的结果可能需要写回存储器或I/O</li></ul><h3 id="二、CPU的要求">二、CPU的要求</h3><ul><li>CPU能暂时的存储部分数据</li><li>CPU必须知道当前执行指令的位置，以便获取下一条指令的位置</li><li>CPU必须在执行指令期间保存指令和数据</li></ul><p><img src="/img/article_img/cpu_structure_function1.jpg" alt="cpu简介图"></p><p><img src="/img/article_img/cpu_structure_function2.jpg" alt="cpu详介图"></p><h3 id="三、寄存器的组成">三、寄存器的组成</h3><h4 id="1-CPU中寄存器主要可以分为两类：">1. CPU中寄存器主要可以分为两类：</h4><ul><li>用户可见寄存器：允许机器语言或者汇编语言的编程人员通过优化寄存器的使用而减少对内存的访问</li><li>控制和状态寄存器：由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行</li></ul><h4 id="2-用户可见寄存器：">2. 用户可见寄存器：</h4><ul><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：用于保存数据，不能用于操作数地址的计算</li><li>地址寄存器：用于可以是自身有某种通用性或者专用性的寻址方式</li><li>标志寄存器：保存条件码、允许程序员读出，但不能更改</li></ul><h4 id="3-寄存器的设计出发点：">3. 寄存器的设计出发点：</h4><ul><li>使用完全通用寄存器还是规定各寄存器的用途</li><li>寄存器的数量</li><li>寄存器的长度</li></ul><h4 id="4-控制和状态寄存器：">4. 控制和状态寄存器：</h4><ul><li>程序计数器（PC）：存放待取指令的地址</li><li>指令寄存器（IR）：存放最近取来的地址</li><li>存储器地址寄存器（MAR）：存放存储器位置的地址</li><li>存储器缓冲寄存器（MBR）：存有将被写入或最近从存储器读出的字</li></ul><h4 id="5-程序状态字（PSW）：">5. 程序状态字（PSW）：</h4><ul><li>符号（sign）：容纳算术运算结果的符号位</li><li>零（zero）：当结果是0时置位</li><li>进位（carry）：操作导致向最高位有向上进位或借位时被置位</li><li>等于（equal）：逻辑结果相等置位</li><li>溢出（overflow）：用于指示算术运算溢出</li><li>中断允许/禁止（interrupt enable/disable）：用于允许/禁止中断</li><li>监管（supervisor）：指出CPU是执行在监管模式还是用户模式</li></ul><h4 id="6-设计控制和状态寄存器组织时考虑的几个因素：">6. 设计控制和状态寄存器组织时考虑的几个因素：</h4><ul><li>考虑对操作系统的支持（某些控制信息专门为控制操作系统使用）</li><li>考虑控制信息在寄存器和存储器之间的分配</li></ul><h4 id="7-指令周期：">7. 指令周期：</h4><ul><li>取指：将下一条指令从存储器中读入CPU</li><li>执行；解释操作码并完成指定操作</li><li>中断：如果中断允许并且有中断发生，则保存当前状态执行中断</li></ul><h4 id="8-间接周期：">8. 间接周期：</h4><ul><li>指令的执行可能涉及到内存中的一个或多个操作数，并且每个操作数都需要内存访问</li><li>如果使用间接地址，需要额外的内存访问</li><li>将间接地址的获取视为一个或多个指令周期</li></ul><p><img src="/img/article_img/cpu_structure_function3.png" alt="指令周期"></p><p><img src="/img/article_img/cpu_structure_function4.png" alt="指令周期状态图"></p><h4 id="9-数据流：">9. 数据流：</h4><ol><li><p><img src="/img/article_img/cpu_structure_function5.png" alt="数据流与取指周期"></p><ul><li>控制器向PC发送请求 -&gt; PC将存有的下一条指令的地址传给MAR -&gt; MAR放到地址总线上</li><li>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号 -&gt; 存储器获取指令地址并将对应的指令放到数据总线上</li><li>MBR从数据总线上获取指令然后传给IR</li></ul></li><li><p><img src="/img/article_img/cpu_structure_function6.png" alt="数据流间接周期"></p><ul><li><p>MBR存储的是指令的地址 -&gt; MBR将地址传给MAR -&gt; MAR将该地址传放到地址总线上</p></li><li><p>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号并读取指令的地址</p></li><li><p>存储器根据地址将对应指令放到数据线上 -&gt; MBR读取指令</p></li></ul><p><img src="/img/article_img/cpu_structure_function7.png" alt=""></p><ul><li>控制器向MAR传送信号 -&gt; MAR将当前数据要保存到的地址放到地址总线上</li><li>控制器向PC传送信号 -&gt; PC将当前要保存的数据传入MBR -&gt; MBR将数据放到数据总线上</li><li>控制器向控制总线上发送信号 -&gt; 存储器读取信号 -&gt; 存储器从地址总线上接收地址，并从数据总线上接收数据</li><li>存储器将数据写入对应的地址</li></ul></li></ol><h3 id="四、指令流水线技术：">四、指令流水线技术：</h3><p><strong>1. 流水线技术</strong>：把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</p><p><strong>2. 对指令执行使用流水线技术</strong>：显然能够加快指令的执行，但是使得执行速度翻倍是不可能的，原因如下：</p><ul><li>执行时间一般长于指令的执行（执行指令和取指令都可能使用I/O，所以会产生冲突，一次只能有一个进行）</li><li>条件分支指令使得待取的下一条指令的地址未知（当多条指令执行了一些步骤后，遇到跳转指令，这些指令执行的步骤将会作废）</li></ul><p><strong>3.对指令执行的细分</strong>（为了进一步加速）：</p><ul><li>取指：获取下一条要执行指令到MBR</li><li>译码：解析指令，确定操作码、操作数</li><li>计算操作数：计算源操作数的有效地址</li><li>取操作数：从存储器中读取操作数（寄存器中的数据不需要读取）</li><li>执行：完成指定操作</li><li>写回操作数：将结果写回存储器</li></ul><p><strong>4. 几个限制性能提升的因素</strong>：</p><ul><li>细分的各个阶段时间不完全相等</li><li>遇到条件转移指令时，之前进行的指令会作废</li><li>寄存器和存储器可能产生冲突</li></ul><p><strong>5. 人们认为流水线中阶段越多，执行速度越快？No</strong></p><ul><li>流水线的每一阶段，都会有某些开销设计数据在MBR间的传送，以及各种准备会使得一次指令的总的执行时间边长</li><li>优化流水线的使用和处理存储器及寄存器相关性所需要的控制逻辑总量，会随着流水线阶段数的增长而急剧增长</li><li><strong>锁存延迟</strong>，即流水线阶段之间的缓冲需要一定时间来完成其操作，这也会增加指令周期的时间</li></ul><p><strong>6.流水线性能</strong>：</p><ul><li>$t_{i}$:流水线第$i$段的延迟</li><li>$t_{m}$:最大段延迟</li><li>$k$:指令流水线段数</li><li>$d$:所存延迟</li><li>$t = max[ t_{i} ] + d = t_{m} + d$ -&gt; $t$: 指令流水线周期</li><li>假设$n$条指令没有条件转移的在进行，$T_{k, n} = [ k + (n - 1)] t$表示k段流水线执行n条指令所需的总时间</li><li>完成第一条指令需要k个周期，其余n-1条指令需要n-1个周期</li><li>加速比$S_{k} = T_{1, n} / T_{k, n} = nk / (k + n - 1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>computer-network</title>
    <link href="/2021/02/15/computer-network/"/>
    <url>/2021/02/15/computer-network/</url>
    
    <content type="html"><![CDATA[<h1>computer-network</h1><h2 id="一、计算机网络概述">一、计算机网络概述</h2><h3 id="一、计算机网络的早期发展">一、计算机网络的早期发展</h3><ol><li>网络的作用：<ul><li>知识经济、信息化：以网络为核心的信息时代</li></ul></li><li>载体：“三网”、三网合一<ul><li>电信网</li><li>有线电视网</li><li>计算机网络（核心）</li></ul></li><li>网络的雏形：使用（transceiver）收发器进行简单的结合，被称为“面向终端的计算机通信网”<ul><li><img src="/img/article_img/computer_network1.png" alt=""></li><li>拓扑结构：星形</li><li>网络中心是一台高性能计算机，负责整个网络的控制工作。多个终端围绕在它的周围，在多个终端上安装有收发器设备，<strong>作用是为终端发送或接收数据</strong>，此时的网络工作是在电信网络的基础设施上完成的。</li><li>PSTN：公用电话交换网（常说的电话网），电话网只能传说模拟型号，为实现计算机中数字数据的传输，通信的双方使用<strong>调制解调器</strong>来进行数字信号和模拟信号之间的转换。</li><li>Line controller–线路控制器:<strong>多重线路控制器可以实现将计算机与多个终端相连，同时线路控制器还具有数据串并行转换和差错控制功能</strong>。</li></ul></li><li>随着计算机用户的增加，网络中每增加一个终端，线路控制器要付出很大的代价，同时对主机造成了很大的负担，严重的影响了主机的工作。此时迫切的需要一个能够帮助主机分担工作的设备，于是<strong>前端处理机FEP</strong>就出现了。<ul><li>前端处理机也称为：通信控制器，承担原来主机的全部通信任务，将主机从繁重的通信任务中释放出来，更好的运行应用程序。（现在普遍存在的网卡就是前端处理机的化身）</li><li><img src="/img/article_img/computer_network2.png" alt=""></li></ul></li><li>远程终端的增加不仅会给主机带来负担，同时通讯费用也会迅速增加，特别是利用高速通信线路进行传输的时候，为了降低通信成本，在终端密集的地方出现了线路集中器，它是一种智能复用器，可以通过低速线路将多个终端集中起来，对后面的高速线路进行复用，这样高速线路的容量就可以远远小于各低速线路容量和，从而降低通信费用。<ul><li><img src="/img/article_img/computer_network3.png" alt=""></li></ul></li></ol><h3 id="二、分组交互网">二、分组交互网</h3><ol><li>从通信资源的分配角度来看，交换就是按照某种方式动态分配传输线路的资源。<ul><li>电路交换是电信网中采用的数据传输方式，在使用电路交换时，必须在通信双方之间建立一条物理连接，这条连接占用了双方通信所需要的资源，而这些资源在双方通信时不会被其他用户占用，直到通信结束。</li><li><img src="/img/article_img/computer_network4.png" alt=""></li></ul></li><li>为什么传统电路交换不适合计算机数据传输？<ul><li>浪费资源：使用专用的物理通路<ul><li>电路传输在双方没有数据传输时，所占用的通信资源会白白浪费</li><li>而计算机的数据传输具有突发性，非连续性，因此在通路建立的这段时间内可能会有大量的时间是出于空闲状态，造成了严重的资源浪费</li></ul></li><li>不同规格的终端互连不便：需要协调缓冲机制和转换机制<ul><li>计算机不像电话那样种类规格单一，它的系统结构和规格多种多样，所以需要付出额外的转换代价</li></ul></li><li>不灵活：单点故障，全线瘫痪------需要重拨<ul><li>在电路交换的线路中任何一处出现故障都会导致正太通路中断。在远距离计算机数据传输中，这个问题会严重影响数据传输效率</li></ul></li></ul></li><li><strong>分组交换</strong><ol><li>分组交换的特点<ol><li><strong>采用存储转发技术</strong>，基于数据从发送方到接收方中间要经过多个节点的暂时存储，然后根据接收方的地址找到下一个接收该数据的节点，并将数据转发除去，知道到达接收方为止。<ul><li><img src="/img/article_img/computer_network5.png" alt=""></li><li>比如现在要从主机H1向H5发送分组，分组从H1出发后，经过结点交换机A C E的转发，最终到达目的主机H5。</li></ul></li><li>分组交换技术的另一个特点：发送数据之前要对数据进行分段处理。通常我们把要发送的整块数据称为一个报文，在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段，在每个数据段前面加上一些必要的控制信息组成首部，这样就形成了一个分组。<ul><li>分组有时候也称为包，分组的首部称为包头</li><li><img src="/img/article_img/computer_network6.png" alt=""></li></ul></li></ol></li><li>分组交换网的组成<ol><li>主机（host）<ul><li>主要为用户进行信息处理，并且可以通过网络和其他主机交换信息</li></ul></li><li>结点交换机（node switch）<ul><li>节点交换机则是进行分组的存储转发</li><li>路由器</li><li><img src="/img/article_img/computer_network7.png" alt=""></li></ul></li></ol></li><li>分组交换网中一个报文的传输全过程<ol><li><img src="/img/article_img/computer_network8.png" alt=""></li><li>对于一个报文M，分成了三个分组M1，M2，M3，分别用不同的颜色表示</li><li>对于M1，M2，M3三个分组都到达了目的主机，但是中间经过的结点交换机并不相同，即它们是经过不同的路径传输的</li></ol></li><li>当网络中出现故障时的通信情况<ol><li><img src="/img/article_img/computer_network9.png" alt=""></li><li>分组传输过程中，当网络中某条通路断开或结点交换机出现故障时，分组避开故障点，重新选择新的路径，传输工作基本不受影响。</li><li>由此可见，当部分结点或链路被摧毁时，分组交换仍然可以保持网络畅通</li></ol></li><li>分组交换的优点<ol><li>高效：逐段占用通信链路，动态分配传输带宽</li><li>灵活：智能节电能够独立处理数据分发</li><li>迅速：分组作为传输单位，无需建立连接</li><li>可靠：完善的网络协议</li><li>分布式多路由的网络结构提高了网络的生存性</li></ol></li><li>分组交换的缺点<ol><li>传输时延：分组交换在各中间结点进行存储转发时需要排队，会造成一定的时延</li><li>首部数据存在开销：各分组必须携带一些控制信息，造成了一些传输开销</li></ol></li><li>20世纪40年代的电报通信中也采取了基于存储转发原理的<strong>报文交换</strong>，通过实例比较<strong>电路交换</strong>，<strong>报文交换</strong>，以及<strong>分组交换</strong>的区别<ol><li><img src="/img/article_img/computer_network10.png" alt=""></li><li>A，D分别是原点和终点，B，c是在A和D之间的中间节点，箭头方向代表时间</li><li>电路交换：<ul><li>首先进行连接建立工作</li><li>连接建立好后，整个报文的比特流连续的从原点直达终点（类似管道）</li></ul></li><li>报文交换：<ul><li>整个报文现到达相邻节点，全部存储下来后，查找转发表，然后转发到下一个节点</li><li>再重复存储转发的过程，直到到达终点为止</li></ul></li><li>分组交换：<ul><li>一个分组传送到相邻节点，存储下来后，查找转发表，然后转发到下一个节点</li><li>而此时，刚刚被这个分组占用的链路上就可以继续传输下一个分组了</li><li>在整个报文传输过程中，单个分组可以最大程度的充分利用通信链路资源</li></ul></li></ol></li><li>三种交换方式的对比<ul><li>电路交换时何传输大量、连续的数据</li><li>如果要传输少量、突发的数据则应该使用分组交换</li><li>分组交换链路分配灵活</li></ul></li></ol></li></ol><h3 id="三、Internet的发展与网络的分类">三、Internet的发展与网络的分类</h3><ol><li><img src="/img/article_img/computer_network11.png" alt=""><ul><li>计算机从早期的以主机为中心变为现在以网络为中心</li><li>早期计算机网络是面向终端的星形网，个终端通过通信线路共享昂贵的中心计算机的硬件和软件资源</li><li>分组交换网是以网络为中心，主机出于网络外围，用户通过分组交换网可以共享网络上各种丰富的资源</li></ul></li><li>Internet发展的第一阶段<ul><li>第一个分组交换网ARPANET最初只是一个单个的分组交换网</li><li>ARPA研究多种网络互连技术</li><li>1983年TCP/IP协议成为<strong>标准协议</strong></li><li>1983~1984年，形成因特网Internet</li><li>1990年ARPANET正式宣布关闭</li></ul></li><li>Internet发展的第二个阶段<ul><li><img src="/img/article_img/computer_network12.png" alt=""></li><li>三级计算机网络：主干网、地区王、校园网</li><li>各网络之间使用路由器连接，两个主机之间的通信可能需要经过多级网络</li><li><img src="/img/article_img/computer_network13.png" alt=""></li></ul></li><li>Internet标准化工作<ul><li><img src="/img/article_img/computer_network14.png" alt=""></li><li>ISOC(Internet Society)Internet协会</li><li>ISOC下面有个技术组织因特网体系结构委员会—IAB（Internet Architecture Board），负责Internet有关协议的开发</li><li>IAB下面设有两个部门<ul><li>因特网工程部—IETF（Internet Engineering Task Force）：工程部负责协议的开发和标准化</li><li>因特网研究部—IRTF（Internet Researching Task Force）：研究部进行理论方面的研究</li></ul></li><li>所有Internet标准都是以RFC文档的形式在网上发表（Request for Comment—请求评论）<ul><li>文档级别<ol><li>草案（Internet Draft）</li><li>建议标准（Proposed Standard）</li><li>草案标准（Draft Standard）</li><li>正式标准（Official Standard）</li></ol></li></ul></li></ul></li><li>中国互联网建设<ul><li>第一个分组交互网-----CNPAC铁道部</li><li>1994年正式介入Internet：首次使用64k比特每秒的专线正式介入Internet，成为国际上承认计入Internet的国家</li></ul></li><li>计算机网络分类<ol><li>按照网络的作用范围进行分类<ul><li>广域网（Wide Area Network）：几十到几千公里，Internet的核心部分，任务是进行远距离数据传输</li><li>局域网（Local Area Network）：地理上局限于比较小的范围内</li><li>城域网（Metropolitan Area Network）：一个城市，5~50公里，一个或几个单位所有，也可以是公用设施</li></ul></li><li>按照网络使用者分类<ul><li>公用网：电信公司出资建造的大型网络，所有按照电信公司缴纳费用的人都可以使用</li><li>专用网：某个部门为本单位特殊业务工作的需要建造的网络，不对外提供服务</li></ul></li><li>按照拓扑结构分类<ul><li>星形、总线型、环形、树形、网状</li><li><img src="/img/article_img/computer_network15.png" alt=""></li><li>规则拓扑结构的网络往往是局域网，而不规则的网状结构通常应用于城域网和广域网</li></ul></li></ol></li></ol><h3 id="四、计算机网络体系结构">四、计算机网络体系结构</h3><ol><li><p>网络体系结构的发展</p><ul><li>网络体系结构的工作内容<ul><li>激活：使用信号确保数据能够在这条通路上正常的发送和接收</li><li>进行数据分析，识别接收方</li><li>发送放对接收方的就绪检测</li><li>文件系统的格式转换</li><li>差错控制</li><li>其他</li></ul></li><li>两台通信的计算机必须高度协调才行，这种高度协调是非常复杂的，所以早期就提出了<strong>分层</strong>的办法来解决，而这些层次的集合就是网络的体系结构</li><li>网络体系结构发展历史<ul><li>第一个阶段：‘’群雄逐鹿‘’<ul><li>各个公司各自拥有自己的网络体系结构，如：IBM和SNA、Novell</li><li>不同公司的设备不兼容导致大公司的垄断，技术不兼容，所以导致了OSI模型的出现</li><li>OSI七层模型—ISO7498<ul><li>ISO：International Standard Organization</li><li>OSI/RM：Open System Interconnection Reference Model：开放系统互连基本参考模型</li></ul></li></ul></li><li>第二阶段：OSI“一统天下”<ul><li><img src="/img/article_img/computer_network16.png" alt=""></li><li>两个使用该标准的主机可以在世界上任何地方通信</li><li>OSI七层模型失败的教训：<ol><li>糟糕的时机<ul><li><img src="/img/article_img/computer_network17.png" alt=""></li></ul></li><li>糟糕的技术<ul><li>会话层和表示层几乎是空的，而数据链路层和网络层的内容又太多，模型中的定义过于复杂，实现起来特别困难，有些功能在不同层上有多次出现</li></ul></li><li>糟糕的实现<ul><li>由于协议和定义过于复杂，实现的非常糟糕，效率低，使用感受特别差</li></ul></li><li>糟糕的策略<ul><li>政府的产物，被认为是政府将糟糕的产物强加于人们，与此同时，TCP/IP协议得到广泛的应用</li></ul></li></ol></li></ul></li></ul></li></ul></li><li><p>不论是TCP/IP模型还是失败的OSI模型，它们在结构设计上都采用了<strong>分层的思想</strong>。那么网络体系结构为什么要分层，分层有什么好处？</p></li><li><p>分层的网络体系结构</p><ol><li><p>哲学家交流模型</p><ul><li><p><img src="/img/article_img/add_computer_network1.png" alt=""></p></li><li><p>假如有两位来自不同国家的哲学家，现在需要对某个问题进行讨论，其中一个哲学家会乌尔都语/英语，另一位哲学家会法语/汉语。两个哲学家位于最高层。由于语言不同，所以他们雇了两个翻译----第二层，两位翻译用双方都会的语言荷兰语。所以哲学家1把他对兔子的情感传达给哲学家2的时候。先将其传给他的翻译，然后他的翻译翻译成荷兰语。接下来翻译将翻译的内容交给秘书，让它发送出去给哲学家2的秘书。哲学家2的秘书将消息送给哲学家2的翻译，翻译将内容翻译给哲学家看。</p></li></ul></li><li><p>从哲学家交流模型里可以发现分层的好处：</p><ol><li>层次间的相对独立性</li><li>灵活性</li><li>易于分割</li><li>易于实现和分割</li><li>易于标准化</li></ol></li><li><p>设计体系结构是分层的原则</p><ol><li>层次数量不能过多----过多会增加传输成本和开销</li><li>层次数量不能过少----过少导致各层次功能还是过于复杂，难以实现</li><li>类似的功能放在同一层----利于实现</li><li>在实现技术经常变化的地方增加层次-----利用结构的灵活性，是变化带来的影响最小</li><li>层次边界选择要合理，使得信息量最小</li></ol></li><li><p>对等的协议需要在协议的规范下工作。协议主要由三个要素描述：语义、语法、时序。</p></li><li><p>某一层次的协议对于其他层次来说是透明的。在协议规定下，把对等层次下传输的数据单元称为这一层次的协议数据单元—PDU。下层负责向上层提供服务，上层不需要知道下层如何实现的。形象的比喻<strong>协议是水平的，服务是垂直的</strong>。下层和上层进行信息交换的接口称为服务访问点----SAP，主要用于上下层次服务原语的交换。服务原语----上层使用下层服务时需要传输的一些命令。</p><ul><li><img src="/img/article_img/add_computer_network2.png" alt=""></li></ul></li><li><p>五层体系结构</p><ul><li><p>尽管与OSI模型相比，TCP/IP模型获得了巨大的成功，但这种体系结构并不是完美的。比如它并没有区分服务、接口和协议的概念，模型不通用，不能使用TCP/IP之外的其他协议。上三层的功能主要由各种实用的协议来定义；网络层一下定义了一个接口，没有区分数据层和物理链路层。</p><ul><li><img src="/img/article_img/add_computer_network3.png" alt=""></li></ul></li><li><p>综合TCP/IP和OSI模型的优点，采用5层结构模型来了解计算机网络</p><ul><li><img src="/img/article_img/add_computer_network4.png" alt=""></li></ul><ol><li>应用层—最高层，直接为用户进程提供服务。</li><li>运输层：以报文为单位在两个主机之间提供可靠的端到端的数据传输。</li><li>网络层：以分组为单位，实现数据在不同子网中的传输。</li><li>数据链路层：负责将数据封装成帧，实现透明的无差错传输。</li><li>物理层：是透明的传输bit流，需要考虑如何在不同的传输媒体上的传输问题</li></ol></li></ul></li><li><p>以一次数据传输为例，感受数据在不同层次间传输的问题</p><ul><li><img src="/img/article_img/add_computer_network5.png" alt=""></li><li>上图中两边代表两台网络主机，现在这两台主机应用进程需要通过网络进行数据传输。假设左边的主机是数据的发送端，右边的主机是数据的接收端。应用进程将需要发送的数据首先交给应用层处理。应用层根据相应的应用层协议将该数据进行封装，也就是加上协议的头部字段，这样就形成了应用层的PDU。接下来这个PDU被送到运输层，运输层将整个PDU全都看成数据部分，然后在它的前面加上运输层协议的头部，形成运输层的PDU。然后继续向下交给网络层，网络层进行类似的处理，在收到的数据前面加上网络层的协议头部，形成网络层的PDU。然后交给链路层，链路层加上头部和尾部进行最后一次封装，形成数据帧。然后交给物理层的主要工作是将链路层封装好的帧转换成何时传输的信号，通过传输媒体将数据发送给接收方。而接收方主机在收到这个数据后，执行和发送方相反的操作，即逐层解析各PDU的头部字段，取出其中的数据部分，提交给上层，直到应用进程为止。</li></ul></li></ol></li></ol><h2 id="二、物理层">二、物理层</h2><h3 id="一、物理层的基本概念">一、物理层的基本概念</h3><ol><li><p>物理层的任务：确定与传输媒体的接口特征</p><ul><li>主要是机械特征：指接口所用接线器的形状，尺寸，引线数目及排列等等</li><li>电气特征：指接口电缆所承载电压范围</li><li>功能特征：指某条传输线上电压的意义，比如高电压代表数据1，低电压代表数据0</li><li>规程特征：指在功能实现过程中各种事件出现的顺序</li></ul></li><li><p>信道：指向某一方向传输信息的媒体。</p><ul><li><p>通信信道=发送信道+接受信道</p></li><li><p>传输方式上有3类：</p><ol><li>单向通信：也叫单工通信，特点是只能向一个方向进行信息传输，没有反方向的交互，因此单向通信只需要一条信道。比如使用耳机收听音频文件</li><li>双向交替通信：也叫半双工通信，特点是通信双方都可以发送信息，但是双方不能同时进行。由于这种信息传递方式有两个传输方向，所以需要两条通信信道。比如使用对讲机进行通话</li><li>双向同时通信：也叫全双工通信，特点是通信的双方可以同时发送和接收信息。比如打电话，也需要两条通信信道</li></ol></li></ul></li><li><p>信道带宽：指信道所能通过的信号的频率范围。</p><ul><li>信道带宽越宽，能够通过的信号的高频分量就越多，也就可以用更高的速率来传送码元。因此<strong>信道带宽</strong>是影响信道传输速率的一个因素。</li><li>信号在信道上的传输存在差异，有的频率高一些，有些低一些，但信道所能通过的频率范围总是有限的。当信号的频率超出这个范围时，信号中的高频分量就会收到衰减，坡形边界变模糊，导致接收方对码元的提取困难。</li><li><img src="/img/article_img/computer_network18.png" alt=""></li><li><img src="/img/article_img/computer_network19.png" alt=""></li><li>任何实际信道都是不理想的，在信号传输过程中会有外界干扰，有噪声且带宽受限，所以信号会产生失真。如果传输距离很远或者噪声干扰很大，或者传输媒体很差就会导致信号失真严重，接收方无法识别出正确的信号波形，最后出现错误。考虑这种错误的情况，我们采用<strong>信道容量</strong>来衡量一个信道的<strong>数据传输率</strong>。</li></ul></li><li><p>信道容量：单位时间内信道正确传输的比特数，bps。</p><ul><li>香农定理—给出了信道集先传输速率的计算公式：$C=Wlog_2(1+\frac{S}{N}) bps$</li><li>S：信号平均功率</li><li>N：噪声平均功率</li><li>$\frac{S}{N}$：信噪比</li><li>W：带宽</li><li>香农定理对如何提高信道传输速率并没有给出明确办法，但意义在于只要信道传输速率低于极限速率，就一定可以找出某种办法来实现无差错的传输。</li></ul></li><li><p>波特率和比特率是衡量信道传输速率的两个常用单位</p><ul><li>波特率是指信号值每秒钟变化的次数，代表码元的传输速率</li><li>比特率是指每秒钟传输的数据位数</li></ul></li><li><p>对于一个带宽确定的信道，如果信噪比不能再提高，码元的传输速率也达到了极限，还有什么方式可以提高数据传输速率？</p><ul><li><img src="/img/article_img/computer_network20.png" alt=""></li><li>如果将数字信号直接用不同的高低电平传送，每一个码元信号携带的信息量就是1bit，此时波特率和比特率相等。</li><li>如果将原始数字数据按照每三位一组进行编码，然后采用某种调制的方法来表示这样的信号，那么每一个调制后的码元信号，携带的信息量就是3bit。如果采用相同速率来传输码元的话，那么编码后的数据传输率就是没有编码时的3倍。由此可见，通过编码的方式，可以提高数据传输速率。</li></ul></li><li><p>数据：是运输消息的实体；信号：数据的电气的或电磁的表现。</p><ul><li>分类上来讲都可以是<strong>模拟的</strong>和<strong>数字的</strong></li><li>模拟型的特点是：数字变化呈连续变化的形式</li><li>而数字型的数值则是离散的</li></ul></li><li><p>数据与信号的分类</p><ul><li>模拟数据用模拟信号发送-----载波</li><li>数字数据用数字信号发送-----编码</li><li>模拟数据用数字信号发送-----采样</li><li>数字数据用模拟信号发送-----调制</li></ul></li><li><p>基带信号：来自信源的信号，比如将计算机输出的数字信号直接用两种不同的电压表示。单机带信号中往往包含较多的低频成分甚至是直流成分，而很多信道不能传输这种低频分量，因此常用调制的方法对基带信号进行处理。其中一种做法是利用载波将基带信号的频率范围调制到另一个较高的频段，以适应信道的传输。</p></li><li><p>宽带信号：指经过上述调制后的信号，也称带通信号。</p></li><li><p>利用载波进行调制的方法有三种</p><ol><li><img src="/img/article_img/computer_network21.png" alt=""></li><li>调幅：使载波的振幅随信号的不同而变化</li><li>调频：使载波的频率随信号的不同而变化</li><li>调相：使载波的初始相位随信号的不同而变化</li></ol></li><li><p>基带数字信号的编码方法</p><ol><li>当数字数据用数字信号发送时，<strong>不归零码</strong>是最简单的基带数字信号传输方法。但在传输连续的0或1时，很难确定每个码元的界限，这就会导致接收方无法从比特流中提取出同步的<strong>位信号</strong>。因此需要用某种方法使得接收方和发送方同步。</li><li><img src="/img/article_img/computer_network22.png" alt=""></li><li>编码就是一种可以用于同步的方法，常用的编码方法有<strong>曼彻斯特编码</strong>和<strong>差分曼彻斯特编码</strong>，都是通过在码元中间出现电平转换来产生同步信号。</li><li><img src="/img/article_img/computer_network23.png" alt="这张图片还没看懂，没理解意思，感觉怪怪的！！！"></li><li>在<strong>曼彻斯特编码</strong>中，每个码元的中间有一次电平的跳变。电平从低变高代表信号0，从高到低代表信号1</li><li>在<strong>差分曼彻斯特编码</strong>中，每个码元的中间有一次电平的跳变，同时在信号开始时，不改变电平表示1，信号开始时改变电平表示0</li><li>与曼彻斯特编码相比，差分曼彻斯特编码的抗干扰能力更好一些</li></ol></li></ol><h3 id="二、传输媒体">二、传输媒体</h3><ol><li>传输媒体时数据传输系统中发送器和接收器之间的物理通路，可以分为两大类，<strong>导向传输媒体</strong>和<strong>非导向传输媒体</strong>。<ul><li>在导向传输媒体中，电磁波沿着固体媒体（铜线/光纤）传播</li><li>非导向传输媒体的传输就是无线传输</li></ul></li><li>导向传输媒体<ol><li>双绞线，<img src="/img/article_img/computer_network24.png" alt="">：最古老但又最常用的传输媒体，把两根相互绝缘的铜导线用规则的方法绞合在一起，就构成了双绞线。<ul><li>模拟传输和数字传输都可以使用双绞线进行，通信距离一般是几公里到十几公里</li><li>双绞线的绞合可以减少相邻导线的电磁干扰</li><li>根据绞合的紧密程度，可以将双绞线分为三类线，四类线，五类线，六类线，七类线等等</li><li>绞合度越高，抗干扰性能越好，获得的带宽也就越宽</li><li>为了提高双绞线的抗干扰能力，还可以在双绞线的外面加上一层用金属丝编成的屏蔽层—屏蔽双绞线，价格稍高</li><li><img src="/img/article_img/computer_network25.png" alt=""></li><li>由于价格和性能都不错，广泛应用于电话系统和通信系统中</li></ul></li><li>同轴电缆，<img src="/img/article_img/computer_network26.png" alt=""><ul><li>由于外导体屏蔽层的作用，同轴电缆具有很好的抗干扰性能，通常用于传输较高速率的数据，主要用于有线电视网的传输中</li></ul></li><li>光纤，<img src="/img/article_img/computer_network27.png" alt=""><ul><li>非常透明的玻璃芯和包层组成，利用光波在纤芯中传导时，遇到折射率较低的包层而发生全反射现象，将光沿着光纤传输下去</li><li>光纤包层分为玻璃和塑料两种。玻璃光纤损耗小，成本高，通常用于远距离的宽带传输中。塑料光纤损耗大成本低，通常用于短距离的基带传输中</li><li>光纤传送模式<ol><li><img src="/img/article_img/computer_network28.png" alt=""></li><li>光纤中只要光纤射在光纤表面的入射角足够大，就能产生全反射现象。因此，在一条光纤中，会存在多条入射角不同的光线，这种光纤被称为多模光纤。</li><li>由于光脉冲在多模光纤中传输时，会逐渐展宽造成失真，所以多模光纤只适合于近距离传输。</li><li>如果将光纤的直径减小到只有一个光的波长，那么光纤就能向波导那样使光线一直向前传输，而不会产生多次反射，这种就是单模光纤。</li><li>单模光纤的制作成本高，光源必须使用半导体激光器，但损耗小，适合长距离传输。</li></ol></li><li>光纤特点<ol><li>依靠光波承载信息，衰减少，传输距离远</li><li>抗雷电和电磁干扰性能好</li><li>无辐射，保密性好</li><li>体积小，重量轻</li><li>光纤断裂的检测和修复比较困难</li></ol></li></ul></li><li>光缆，<img src="/img/article_img/computer_network29.png" alt=""><ol><li>光缆结构：<img src="/img/article_img/computer_network30.png" alt=""><ul><li>加强芯，填充物，包层和保护套可以是机械强度达到几公斤</li></ul></li><li>光线联网：<img src="/img/article_img/computer_network31.png" alt="">LED<ul><li>将点到点的链路串联起来构成一个环路，通过T形接头连接到计算机上</li><li>T形接头分<strong>无源</strong>和<strong>有源</strong>两种，上面图片的是有源T形接头的内部结构</li><li>光信号经过<strong>光电二极管</strong>变为电信号，再生放大后，经过<strong>发光二极管LED</strong>变成光信号继续向前传输，相当于一个<strong>转发器</strong>，一旦<strong>T形接头</strong>出现故障，整个光纤环路就会断开</li></ul></li></ol></li></ol></li><li>非导向传输媒体<ol><li>无线传输使用的频带分布：<img src="/img/article_img/computer_network32.png" alt=""></li><li>短波，<img src="/img/article_img/computer_network33.png" alt=""><ol><li>短波通信主要是利用大气中电离层对无线电波的反射进行传输，电离层的不稳定所产生的衰弱现象和电离层反射所产生的多径效应使得短波通信的质量比较差，因此必须使用短波无线电台进行数据传输时，一般都是低速传输</li></ol></li><li>微波<ol><li>空间中直线传播，可以穿透电离层进入太空</li><li>微波通信方式主要有两种，店面微波接力通信和卫星通信</li><li>地面微波接力通信，<img src="/img/article_img/computer_network34.png" alt=""><ol><li>由于地球表面是球面，微波是直线传输，为了实现远距离传输就在地球表面的高处建立天线塔作为中继站，把前一站发送过来的信号放大后发送给下一站这个过程就是微波接力</li><li>可以传输电话、电报、图像、数据等信息</li><li>主要特点<ul><li>频带宽，信道容量大，信号受干扰小</li><li>建设投入少</li><li>相邻站之间不能有障碍物，受天气影响大，保密性差</li></ul></li></ol></li><li>卫星通信<ol><li>利用高空中人造卫星作为中继站进行的微波接力通信，<img src="/img/article_img/computer_network35.png" alt=""></li><li>特点<ul><li>通信距离远，适合光波通信，保密性差，与地面微波接力通信特点差不多</li><li>在赤道上空一定高度放置三颗卫星可实现全球通信</li></ul></li></ol></li></ol></li><li>常用的还有蓝牙技术、红外通信、光波通信等</li></ol></li></ol><h3 id="三、物理层标准举例">三、物理层标准举例</h3><ol><li>EIA-232-E标准<ol><li><img src="/img/article_img/computer_network36.png" alt=""></li><li>DTE（数据终端设备）：具有一定数据处理能力及数据收发能力的设别，如计算机</li><li>DCE（数据电路端接设备）：在DTE和传输线路之间提供信号变换和编码功能，并负责建立、保持和释放数据链路的连接，如MODEM（调制解调器）</li><li>232标准是上图中计算机与调制解调器连接时的标准</li><li>232标准规定了物理层的4个特性<ol><li>机械特性，规定插头有25针引脚</li><li>电气特性，规定逻辑1用-3V或更低电压来表示，逻辑0用+3V或更高电压表示。两台设备直接相连时最大距离不能超过15米，接口数据传输率不超过20K比特每秒</li><li>功能特性，规定DTE和DCE之间个信号线的功能及连接情况，<img src="/img/article_img/computer_network37.png" alt=""></li><li>规程特性，规定DTE和DCE之间信号持续的应答关系和操作过程<ul><li>232标准将数据传输过程分为3个阶段<ol><li>建立连接阶段</li><li>数据传输阶段</li><li>释放连接阶段</li></ol></li><li>具体操作过程<ol><li><img src="/img/article_img/computer_network38.png" alt=""><ol><li>连接建立阶段：<ul><li>发送方A的DTE设备首先向DCE A发出DTE就绪信号</li><li>然后向DCE B进行拨号</li><li>接收方的DCE B以振铃的形式通知DTE B</li><li>然后DTE B发出就绪信号通知DCE B</li><li>DCE B在发出就绪信号响应DTE B</li><li>之后将接收方准备就绪的消息以载波的形式发送给发送方</li><li>发送方通过载波检测获得了对方准备就绪的消息之后</li><li>DCE A向DTE A发送就绪信息，同时以载波的形式将发送方就绪的消息告知接收方</li></ul></li><li>数据传输阶段：<ul><li>A首先发送数据，DTE A向DCE A发出发送请求</li><li>DCE A回送允许发送信号</li><li>数据从DTE A发送出来，被DTE B接收</li><li>接下来B发送数据和上面一样</li></ul></li></ol></li></ol></li></ul></li></ol></li></ol></li><li>568标准：美国电子工业协会和电信行业写回联合发布的一个关于双绞线的标准（下面重点为双绞线线序标准）<ol><li>双绞线中一共有8根信号线，按照标准的线序插入到RJ45的水晶头中</li><li>568B标准：<img src="/img/article_img/computer_network39.png" alt=""><ol><li>大多数情况下四个引脚传输数据，另外四个作为备用引脚</li><li>1号引脚：发送高电平数据</li><li>2号引脚：发送低电平数据</li><li>3号引脚：接收高电平数据</li><li>6号引脚：接收低电平数据</li><li>使用双绞线的设备，其接口的功能特征和双绞线的功能特征一一对应<ol><li><img src="/img/article_img/computer_network40.png" alt=""></li><li>要实现计算机与集线器之间的数据传输的话，集线器接口的功能特征就要与双绞线的功能特征在发送和接收上刚好相反的，这样才能左到计算机发送的数据被集线器接收，集线器发送的数据也能被计算机接收</li><li>考虑到兼容性，目前大多数网线都是按照568B的标准制作的<ul><li><img src="/img/article_img/computer_network41.png" alt=""></li></ul></li><li>但是如果我们要用网线将两个相同的设备连接起来（如两台计算机），由于同类设备接口功能特性相同，如果采用两端线序相同的网线直连的话，就没有办法将数据的发送引脚和对方的接收引脚对应上，也就不能实现数据传输了。因此根据网线两端连接设备的不同，网线分为<strong>直通线</strong>和<strong>交叉线</strong><ol><li>直通线：网线两端采用相同的线序</li><li>交叉线：网线两端的线序刚好相反，<img src="/img/article_img/computer_network42.png" alt="">，后面新产生的标准也就是568A标准</li><li>实际应用中关于直通线和交叉线的使用：<strong>不同类型的设备之间采用直通线，相同类型的设备采用交叉线</strong>这个原则<ul><li>类型主要是按照DCE和DTE进行划分的，常见的网络设备中，计算机和路由器属于DTE设备，交换机和集线器属于DCE设备</li></ul></li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="四、信道复用技术">四、信道复用技术</h3><ol><li>信道复用技术就是通过复用的手段让多个用户共享一个信道进行通信，这样可以充分利用信道资源，降低通信成本。</li><li>按照复用实现的方式上可以划分四类<ol><li>时分复用<ol><li><img src="/img/article_img/computer_network43.png" alt=""></li><li>特点<ul><li>将时间划分成一个个等长的时分复用帧，每一个时分复用帧的用户在每个时分复用帧中占的固定序号的时系</li><li>如图中有1，2，3，4四个用户，每个用户所占用的时系是周期性出现的，这个周期就是时分复用帧的长度。</li><li>数据在发送方通过多路复用器实现对高速信道的复用，之后在接收方再复用多路解复用器对数据进行分用，分别送给相应的用户</li><li>时分复用的所有用户是在不同的时间占用同样的频带资源</li></ul></li></ol></li><li>频分复用<ol><li><img src="/img/article_img/computer_network44.png" alt=""></li><li>特点<ul><li>将信道的带宽划分为小的频带，为每个用户分配一个固定的频带，之后这个用户就始终占用这个频带进行通信</li><li>可见频分复用的用户是在相同的时间占用不同的带宽资源</li></ul></li></ol></li><li>波分复用<ol><li>光纤通信中，在同一根光纤中同时传输具有不同波长的光载波信号技术</li><li>波分复用为每个用户分配相互隔离的光谱频带，所以也称为光的频分复用</li><li>由于光信号的频率非常高，所以人们习惯上用波长而不是频率来表示光信号，因此也就有了波分复用这个名称</li><li><img src="/img/article_img/computer_network45.png" alt=""></li><li>在发送端具有不同波长的光信号经过棱柱或衍射光栅汇总在一起，并耦合到一根光纤上进行传输，到了接收端再经过棱柱或衍射光栅分离出来</li></ol></li><li>码分复用<ol><li>更常用的名称是码分多址，简称CDMA</li><li>特点<ul><li>每个用户可以在相同的时间使用同样的频带进行通信，由于个用户使用经过特殊挑选的不同码型对发送的数据进行编码，所以个用户之间不会造成干扰</li><li>码分复用最初用于军事通信，因为信号具有很强的抗干扰能力，其频谱类似白噪声，不易被敌人发现，随着价格和体积的降低，码分复用逐渐普及</li></ul></li><li>CDMA工作原理<ol><li>CDMA系统中，每个用户共享全部的时间和带宽资源，所以数据必然会在信道中碰撞叠加，但在接收方通过利用发送方选择的特殊码型对数据进行内积计算就能过滤除掉除了发送站以外的其余各站的数据信息，这样就能将个用户的信息分离开来<ul><li>经过运算后，将其他站的信息过滤掉</li><li>利用内积运算进行过滤</li></ul></li><li>具体实现<ol><li>将每个比特时间再细分为m个短间隔，每个短间隔称作码片（chip），一般m=64或128，这里为了说明方便，令m=8</li><li>对每个站制定唯一的码片序列<ul><li>一个站要发送比特1就要发送它的m比特的码片序列，如果要发送比特0就要发送它的m比特的码片序列的反码序列</li><li>例如给某站分配的码片序列是00011011，发送1时就发送00011011，发送0时就发送11100100</li></ul></li><li>重要特点：系统中每个站的码片序列不同且正交<ol><li>如果用S和T分别表示两个站的码片序列，那么有：<ul><li>正交：S与T向量内积为0，即$\vec S \cdot \vec T = \frac{1}{m}\sum_{i=1}^{m}S_{i} \times T_{i} = 0$（这种情况下编码中的0是-1，1是1来表示）</li></ul></li><li>任何一个码片向量和该码片向量自己的规格化内积都是1，任何一个码片向量和该码片向量的反码向量自己的规格化内积都是-1</li></ol></li><li>在CDMA系统中，利用全球定位系统GPS可以使每个站发送的码片序列都是同步的。系统中的每个站必然会处在下面三种状态之一<ul><li>发送码片序列相当于发送比特1</li><li>发送码片序列的反码序列就相当于发送比特0</li><li>或者什么都不发</li></ul></li><li>对于每个站的状态，在接收端可以利用该站的码片序列和收到的数据进行内积运算推断出来<ul><li>接收站使用S站的码片序列与接受到的向量做内积运算，必有：<ol><li>所有其他站的信号都被过滤掉（内积为0）</li><li>运算结果为+1：S站发送1</li><li>运算结果为-1：S站发送0</li><li>运算结果为0：S站没有发送数据</li></ol></li></ul></li></ol></li></ol></li></ol></li></ol></li></ol><h2 id="三、数据链路层">三、数据链路层</h2><h3 id="一、数据链路层的基本概念">一、数据链路层的基本概念</h3><ol><li><p>链路：一条无源的，点到点的物理线路段，中间没有任何其他的交换节点（链路是通信通路的一个组成部分）</p></li><li><p>数据链路：物理链路+链路控制规程幸成的数据管道</p></li><li><p>数据链路层的三个基本功能</p><ol><li><p>分装成帧</p><ol><li>封装成帧（framing）就是在一段数据前后分别添加首部和尾部，然后就构成了一个帧</li><li>首部和尾部的一个重要作用就是进行帧定界，此外首部和尾部还包括很多控制信息</li><li><img src="/img/article_img/computer_network46.png" alt=""></li><li>帧的发送是从首部开始的，到尾部结束。为了提高数据传输效率，应该使帧的数据部分长度尽可能地大于首部和尾部的长度，但是每种数据链路层协议都对帧的数据部分长度设置了上限，我们把这个值称为<strong>最大传输单元</strong>，简称MTU。</li></ol></li><li><p>透明传输</p><ol><li>由于帧的首部和尾部通常会采用一些特殊字符和比特组合来作为帧开始和结束的标记，所以在帧的数据部分就不允许再出现与这些定界符号相同的内容，否则就会出现帧定界的错误</li><li><img src="/img/article_img/computer_network47.png" alt=""></li><li>上图中，数据部分出现了与帧结束部分相同的内容，接收方就会误认为这是真的结尾而把它接受下来，然而真正的帧并没有传输结束，后续的数据部分就只能成为一个无效帧被丢弃。</li><li>为解决上述这个问题，在<strong>发送方的数据链路层</strong>就需要对数据部分出现的与帧定界符相同的字符进行处理。比如我们可以在这些字符前面插入一个转义字符，接收方在接收时，再将这些转义字符去点，同时忽略其后面字符的含义。如果转义字符也出现在数据部分，那么就在转义字符前面也插入一个转义字符，接收方收到连续的两个转义字符后，删掉前面一个就好<ul><li><img src="/img/article_img/computer_network48.png" alt=""></li></ul></li></ol></li><li><p>差错控制</p><ol><li><p>数据在传输过程中受到噪声和外界环境的干扰，可能就会出现比特差错，也就是0变成了1，1变成了0。为了保证数据的可靠性，在计算机网络的传输过程中，必须采取各种差错检测的措施，其中**循环冗余校验（CRC）**是数据链路层上广泛使用的一种差错检验方法</p></li><li><p>循环冗余校验（CRC）的原理</p><ul><li><img src="/img/article_img/computer_network49.png" alt=""></li></ul><ol><li>在发送端，先把数据划分成组，假定每K个比特</li><li>M是要发送的数据（K bit），运算就是将M与一个n+1位的除数P进行除法运算，得到n位余数R</li><li>将R连接再数据M后面，是用于差错检验的冗余码，它将和M一起构成一个帧发送出去</li><li>CRC进行差错检验的数学基本原理：<ol><li>若<code>m / p = n 余 r</code>，则有<code>(m-r)能被p整除</code>。CRC中除法采用的是<strong>模2除法</strong>，即加法不产生进位，减法不产生借位，所以模2运算的加减法运算结果是相同的，由此可知，如果之前的除法采用模2除法一定有<code>(m+r)/p余数为0</code></li><li>基于上述原理，CRC在进行计算式，先对原数据$M \times 2^n$，相当于在M的后面添加n个0，然后再与P进行模2除法运算，最后把运算得到的R附加在M的后面，相当于$M \times 2^n + R$</li></ol></li></ol></li><li><p>在数据后面添加的冗余码，称为帧检验序列FCS（Frame Check Sequence），通常是数据帧当中用于差错检验的一个字段。</p><ul><li>帧检验序列和CRC的冗余码并不是同一个概念</li><li>帧检验序列可以通过CRC计算得出，但这不是唯一的方法，还有其他方法也可以</li></ul></li><li><p>利用CRC进行检验的工作是在接收方完成的，接收方将收到的每一帧数据再与除数P进行模2除法运算</p><ul><li>如果余数为R = 0，则判定这个帧没有差错，接收</li><li>如果R != 0，则判定这个帧有差错，就丢弃</li><li>CRC只能检测是否有错误，但不能确定错误出现的位置。同时也可能数据在传输过程中出错了，但凑巧的是，这个错误的帧经过计算余数为0，出现对错误的漏检，这种可能性在理论上是存在的，但是只要经过严格的挑选，并使用位数足够多的除数P，这种概率就会很小很小</li><li>为了表示方便，除数P采用生成多项式表示</li><li>仅使用循环冗余检验技术只能做到无差错接收，但是<code>“无差错接受 != 可靠传输”</code>，因为数据传输过程中还可能出现帧丢失，帧重复，帧乱序等问题，所以还必须加上<strong>确认和重传机制</strong>才能保证可靠传输</li></ul></li></ol></li></ol></li></ol><h3 id="二、数据链路层的可靠传输">二、数据链路层的可靠传输</h3><ol><li><p>在OICI参考模型中，关于数据链路层功能的定义是：通过一些数据链路层协议，在不太可靠的物理链路上，实现可靠的数据传输</p></li><li><p>停止等待协议</p><ol><li>基本原理<ol><li>正常情况，<img src="/img/article_img/computer_network50.png" alt=""><ul><li>接收方接受到发送发发来的一帧正确的数据后，将其提交给主机</li><li>然后向发送方发送一个<strong>确认帧ACK</strong></li><li>发送方收到确认帧之后，才能发送下一帧数据</li></ul></li><li>数据帧出错，<img src="/img/article_img/computer_network51.png" alt=""><ul><li>如果传输过程中数据出现差错，接收方收到数据后，通过循环冗余校验可以很容易的发现错误</li><li>此时接收方向发送方发出一个<strong>否认帧NAK</strong></li><li>接下来发送方会重传这一帧数据，知道收到确认帧为止</li><li>这种处理方式交错<strong>差错重传</strong></li></ul></li><li>数据帧丢失，<img src="/img/article_img/computer_network52.png" alt=""><ul><li>数据帧在传输过程中可能会丢失，由于接收方收不到数据，所以不会发出确认帧。而发送放如果一直等待下去就会出现<strong>死锁</strong></li><li>为了防止这种情况的出现，发送方没法送出一帧数据，都要启动一个超时计时器</li><li>如果在计时器所设置的时间内，没有收到接收方发来的确认帧的话，就重传之前发出的这一帧数据，知道收到确认帧为止</li><li>这种处理方式称为<strong>超时重传</strong></li></ul></li><li>数据帧被接收方接收了，但确认帧却丢失了，<img src="/img/article_img/computer_network53.png" alt=""><ul><li>由于确认帧丢失，发送方也会进行超时重传，但<strong>问题是接收方已经接受过这一帧数据了</strong>，这样就会出现重复帧的问题</li><li>为了解决重复帧的问题，我们可以给每一个发送的不同的数据帧都带上不同的序号，根据序号，接收方就可以很容易的判断重复帧</li><li>当收到重复帧时，接收方将重复帧丢弃，同时向发送方发送一个确认帧以防止发送方在超时重传</li></ul></li><li>由于上述确认和重传机制就可以在不可靠的通信链路上实现可靠的数据传输。由于发送方对出错的数据帧的重传是自动完成的，所以这种可靠传输协议又称为ARQ（Automatic Repeat Request）</li></ol></li><li>信道利用率<ol><li>停止等待协议的优点是简单易实现，但是缺点是信道利用率太低<ul><li><img src="/img/article_img/computer_network54.png" alt=""><ol><li>假设发送方发送一帧数据的时间是$T_D$，数据在发送方和接收方之间的信道上往返的传输时间是$RTT$，发送方接收确认帧的时间是$T_A$，从上图中可以看出发送方在每一帧数据发送的过程中有效数据占用信道传输的时间仅为$T_D$，而整个过程需要的时间远大于$T_D$，所以停等协议的信道利用率很低，从图中发现这个问题出现的原因是<strong>发送方在等待接收方确认的过程中信道一直出于空闲状态</strong></li><li>为了解决上述问题，出现了连续ARQ协议</li></ol></li></ul></li></ol></li></ol></li><li><p>流水线传输（连续ARQ协议）</p><ul><li><img src="/img/article_img/computer_network55.png" alt=""></li></ul><ol><li><p>采用流水线传输思想，即发送方可以连续发送多个分组，不必每发完一个分组就停下来等待对方的确认</p></li><li><p>由于信道上一直有不间断的数据传送，所以这种传输方式可以获得很高的信道利用率</p></li><li><p>连续ARQ原理</p><ol><li><p>边发送边接收确认</p></li><li><p>帧编号</p><ol><li>由于连续发送，则需要连续编号</li><li>确认帧也需要编号</li></ol></li><li><p>接收端接受到有差错的数据帧的处理方式</p><ol><li>向发送端发送否认帧</li><li>不响应，通常选用这种，实现起来更方便✔️</li></ol></li><li><p>接收端采用只按照序接收的工作方式------Go-back-N（回退N）</p><ol><li><strong>如果前面序号的数据帧出错或丢失了，那么其后面的数据帧只能被接收方丢弃</strong></li><li>因此如果发送方因计时器超时对某一帧数据进行重传的话，除了要重传这一帧数据外，还要把在超时之前发送的所有没有接受到确认帧的数据都重传一遍（称为回退N）</li><li>回退N会严重影响传输效率。在信道传输质量不好的情况下，甚至不如停等协议</li></ol></li><li><p>接收端采用<strong>累积确认</strong>的方式</p><ol><li>为了减少开销，接收方不必对每个接收到的分组都发送一个确认，而是对按序接收到的最后一个帧发送确认，这样就表示到这个分组为止的所有分组都已经正确收到了</li></ol></li><li><p>使用连续ARQ协议时，发送方在等待确认帧的过程中，实际上并不能无限制的发送数据帧。因为一旦有数据帧出错，那么发出去的数据帧越多，需要回退重传的数据帧也就越多，重传的开销也就越大；而且为了给发出去的大量数据帧编号，就需要占用较多的比特位，进而增加了更多的传输开销，因此引入<strong>滑动窗口机制</strong>，对发送发已经发送出去但没有确认的数据帧的数量加以限制很有必要</p></li></ol></li><li><p>滑动窗口机制</p><ol><li><p>窗口：就是指在发送方和接收方分别设置的可以移动的发送窗口和接收窗口。通过对窗口的设置可以对已经确认的帧的序号进行循环利用，同时加入适当的控制机制来避免二义性</p></li><li><p>发送窗口的作用</p><ul><li><img src="/img/article_img/computer_network56.png" alt=""></li></ul><ol><li>对发送方的流量加以控制，只有在发送窗口内的帧才能被连续发送出去。<ul><li>比如连续ARQ中发送序号占3比特，就有8个不同的序号从0到7。</li><li>又假设窗口大小为5，那么刚开始时只有0到4号帧可以被发送出去</li><li>之后在没有收到任何确认的时候，窗口停止不动，发送方也停止发送</li><li>当收到0号帧的确认后，窗口向前移动一个号，此时5号帧就落在了窗口里，可以发送出去了</li><li><strong>随着确认帧逐渐被收到</strong>，发送窗口逐渐向前移动，更多的数据帧逐渐被发送出去</li></ul></li></ol></li><li><p>接收窗口的作用</p><ol><li>控制哪些帧可以接收。接收方只有接收到发送序号在接收窗口里的数据帧时才能将该帧收下，否则一律丢弃</li><li>在连续ARQ协议中接收窗口的大小为1<ul><li>当收到0号帧后，窗口向前滑动1个号，准备接收1号帧，同时发送对0号帧的确认</li><li>随着数据帧逐渐被按序接收，接收窗口逐渐向前移动</li><li><strong>当发送窗口和接受窗口的大小都为1时，就是最初讨论的停等协议</strong></li><li>为了提高对信道的利用率，我们可以设法只对出现的差错或丢失的数据帧进行重传，但是此必须加大接收窗口，先收下那些发送序号不连续但在接收窗口内的数据帧，等所有窗口内的帧都到达后，在一起提交，这就是<strong>选择重传ARQ</strong>。<ol><li>可以避免重传已经确认的帧，但付出的代价是需要在接受方设置相当容量的缓冲区</li></ol></li></ul></li></ol></li></ol></li></ol></li></ol><h3 id="三、PPP协议（一种点对点协议）">三、PPP协议（一种点对点协议）</h3><ol><li>PPP协议应满足的需求<ol><li>简单：首要要求<ul><li>因为因特网工程任务组在设计因特网体系结构时，把最复杂的部分放在了运输层的TCP协议中。而网络层的IP协议相对简单，只提供不可靠的传输服务。在这种情况下，数据链路层的协议就没有必要比IP协议更复杂</li></ul></li><li>封装成帧<ol><li>PPP协议必须规定特殊的字符作为帧定界字符，以便于接收方从比特流中提取出完整的数据帧</li></ol></li><li>透明性<ol><li>如果数据中出现与帧定界符相同的比特组合，必须采取一定的措施来解决，保证数据的透明传输</li></ol></li><li>多种网络层协议<ol><li>要能够在一条物理链路上同时支持多种网络协议的运行</li></ol></li><li>多种类型的链路<ol><li>串/并行、低/高速、同/异步</li><li>PPP协议必须能够在多种类型的链路上运行</li></ol></li><li>差错检测<ol><li>必须能够对接收方收到的数据进行差错检测，并丢弃有差错的帧，以防止差错帧继续在网络中传输造成资源浪费</li></ol></li><li>检测连接状态<ol><li>要能够及时自动检测出链路是否处于正常工作状态</li></ol></li><li>最大传送单元（MTU）<ol><li>必须对每一种类型的<strong>点对点链路</strong>设置最大传输单元MTU的默认值</li></ol></li><li>网络层地址协商<ol><li>必须提供一种机制使通信的两个网络层实体能够通过协商知道或配置彼此的网络层地址</li></ol></li><li>数据压缩协商<ol><li>要提供用来协商数据压缩算法的办法</li></ol></li><li>此外，在标准中还明确了PPP协议不需要的功能<ul><li>纠错（只检错，不纠错）</li><li>流量控制</li><li>序号（不需要使用帧的序号）</li><li>多点线路（不支持多点线路）</li><li>半双工或单工链路（只支持全双工链路）</li></ul></li></ol></li><li>PPP协议的三个组成部分<ol><li>一个将IP数据报封装到串行链路的方法</li><li>一个用来建立配置和测试数据链路连接的链路控制协议LCP（Line Control Protocol）</li><li>一套用来支持不同网络层协议的网络控制协议NCP（Network Control Protocol）</li></ol></li><li>PPP协议的帧格式<ul><li><img src="/img/article_img/computer_network57.png" alt=""></li><li>首部和尾部部分分别为4个字段和2个字段。首部的第一个字段和尾部的最后一个字段都是标志字段，规定值是十六进制的<code>7E</code>，二进制形式<code>01111110</code>，表示一个帧的开始和结束，也就是帧的定界符。首部中的地址字段A设置为十六进制的<code>FF</code>，控制字段设置为十六进制的<code>03</code>，事实上这两个字段并没有真正的意义</li><li>PPP首部的第四个字段是一个协议字段，占2个字节<ul><li>当协议字段为0x0021时，PPP帧的信息字段就是IP数据报</li><li>当协议字段为0xC021时，PPP帧的信息字段就是PPP链路控制数据</li><li>当协议字段为0x8021时，PPP帧的信息字段就是网络控制数据</li></ul></li><li>信息段的内容就是PPP协议要封装的主体部分，通常是网络层交下来的IP数据报，长度可变，但最长不能超过1500个字节</li><li>在PPP帧的尾部，第一个字段是使用循环冗余校验的<strong>帧校验序列</strong>，占2个字节</li></ul></li><li>PPP协议对透明传输问题的处理<ol><li>PPP协议有两种实现透明传输的办法<ol><li>PPP用在<strong>异步传输</strong>时，就使用一种特殊的字符填充法</li><li>PPP用在同步传输时，规定采用硬件来完成0比特的填充</li></ol></li><li>字符填充法<ol><li>PPP协议将十六进制的<code>7D</code>定义为转义符，使用它来进行字符填充</li><li>将信息字段中出现的每一个0x7E字节转变成2字节序列（0x7D，0x5E）</li><li>若信息字段中出现一个0x7D的字节，则将其转变为2字节序列（0x7D，0x5D）</li><li>若信息字段中出现ASCII码的控制字符（即数值小于0x20的字符），则在该字段前面要加入一个0x7D字节，同时将该字符的编码加以改变</li><li>接收端收到数据帧后进行反向操作即可</li></ol></li><li>0比特填充法<ol><li>在发送端先扫描整个信息字段，<strong>只要发现5个连续的1</strong>则立即填入一个0。这样就能保证在信息字段中不会出现6个连续的1，也就不会出现与标志字段相同的比特组合。<ul><li><code>10110111110100</code> -&gt; <code>101101111100100</code></li></ul></li><li>接收端在收到数据帧后，先找到标志字段确定帧的边界，然后再用硬件对其中的比特流进行扫描，每当发现5个连续的1，就将其后面的一个0删掉，这样就能还原原来的比特流<ul><li><code>101101111100100</code> -&gt; <code>10110111110100</code></li></ul></li></ol></li></ol></li><li>PPP协议的工作过程<ol><li>PPP协议最典型的应用就是用户通过向ISP拨号介入Internet的过程。在这个过程中PPP的工作可以用下面状态图来描述：<ul><li><img src="/img/article_img/computer_network58.png" alt=""></li><li>PPP链路的起始和终止状态永远是图中的静止状态，此时在用户的PC机和ISP的路由器之间是不存在物理连接的</li><li>当用户向ISP的路由器发出呼叫时，路由器就能检测到呼叫的载波信号</li><li>在双方建立了物理层连接后，PPP就进入链路建立状态。它的目的时建立链路层的LCP连接。这时LCP通过请求配置帧，开始协商一些配置选项，包括链路上最大帧长、所使用的鉴别协议等等</li><li>协商结束后，双反就建立了LCP链路</li><li>接着就进入鉴别状态，这一状态主要是对双方的身份进行鉴别。如果鉴别失败，就转到静止状态；如果鉴别成功就转到网络状态</li><li>在网络状态下，PPP的双方通过网络控制协议NCP，根据网络层的不同协议交换特定的网络控制分组，用来协商网络层的相关配置</li><li>配置完毕后，链路层就进入了可以进行数据通信的打开状态，链路两端的用户就可以相互发送数据了</li><li>数据传输结束后，一端发出终止请求，在收到对方的终止确认后，就进入到链路终止状态</li><li>当线路上的载波停止后，就回到了静止状态</li></ul></li></ol></li></ol><h2 id="四、信道共享技术">四、信道共享技术</h2><h3 id="一、信道共享技术之受控接入">一、信道共享技术之受控接入</h3><ol><li><p>在多点接入共享信道上，有不同用户同时发出的信号在信道上会出现叠加和碰撞的情况，这就导致接收方无法从接受到的信号中提取出正确的信息，因此对信道共享技术<strong>最基本的要求</strong>—<em>就是在某一时刻只有唯一有效的信息在信道上传递</em>。另外作为一个公共的信道，信道共享技术还必须保证平等的对待信道上面的每一个用户，也就是要让他们有平等的发送机会、接收时会，对它们的请求做出实时的反应</p></li><li><p>信道共享技术特点与要求</p><ol><li>信号的碰撞和叠加</li><li>要求某一时刻只有唯一信息有效传递</li><li>要求平等对待用户<ul><li>平等发送</li><li>平等接收</li><li>实时反应</li></ul></li><li>用户好像独享网络</li></ol></li><li><p>信道共享技术也称<strong>多点接入技术</strong>，更具技术的控制复杂度和可维护性可分为<strong>受控接入</strong>和<strong>随机接入</strong></p></li><li><p>受控接入</p><ol><li><p>特点</p><ol><li><p>各个用户不能任意的接入信道而必须服从一定的控制（控制分为两种）</p><ul><li><p>集中式控制：轮询</p><ol><li><p>网络中的接入点被分为主机和站两种类型。</p><ol><li>主机：主要负责接入的管理。按一定顺序询问各站有没有信息要发送。如果有，被询问的站立即将信息发送给主机</li><li>站：主要参与数据传输</li></ol></li><li><p>具体来讲轮询分为：</p><ul><li><p>轮叫轮询</p><ol><li><p>工作原理：每个站只能接收主机的信息，也只能向主机发送信息</p></li><li><p>机制：主机从1站开始，逐个询问各站是否有数据要发送。</p><ul><li><p><img src="/img/article_img/computer_network59.png" alt=""></p></li><li><p>如果1站没有数据要发送，就发送一个空指帧给主机表示没有数据</p></li><li><p>然后主机在询问2站，2站如果有数据要发，就可以立即发送给主机</p></li><li><p>然后主机在询问下一站，知道询问完N站后，又重新从1开始</p></li><li><p>当然在这个过程中，主机也可以主动将数据发送给各站</p></li></ul></li><li><p>轮叫轮询最大的缺点是：<strong>轮询帧在多点线路上不停的循环往返形成了很大的开销，增加了帧的等待时延</strong>。为了克服上述缺点可以采用下述传递轮询的方法</p></li></ol></li><li><p>传递轮询</p><ol><li>工作原理：每个循环从主机向N站发送轮询帧开始，当N站发送数据完毕，会以控制帧的形式告诉主机；没有数据发送时，会将N-1站的地址附加在控制帧中，这样控制帧就会被N-1站接收，也就是说，不是再由主机向N-1站发轮询帧，而是由N站向N-1站发送轮询帧…直到最后再由1站把主机地址附加控制帧中，询问全就又回到了主机手里，完成一个循环</li><li>传递轮询的帧时延总是小于同样条件下的轮叫轮询，而且站间的距离越大，传递轮询的效果就越好。但由于传递轮询的协议比较复杂，实现成本高，所以在站间距离比较小且通信量较大的环境下，它的优势就不是那么明显</li></ol></li></ul></li></ol></li><li><p>分散式控制：令牌环网</p><ul><li><img src="/img/article_img/computer_network60.png" alt=""></li></ul><ol><li>工作原理：<ol><li>令牌环网的<strong>拓扑结构</strong>是一个闭合的环。所谓的令牌实际上是一种特殊的帧，它平时不停的在换上流动，当有一个站有数据要发送时，必须先截获这个令牌，然后再将数据发送出来。</li><li>当发出的数据在环路上经过目的站时，目的站一方面要复制这个帧，表示手下这个数据；另一方面还要将这个数据帧转发给下一站，让它在换路上继续流动。</li><li>转了一圈之后这个帧一定会回到发送站，发送站对返回的数据帧进行检查，以判断数据是否发送成功</li><li>数据帧接收完之后，发送站在生成一个新的令牌，将它发送给下一站。这样换路上就又有了令牌去等待其他站去截获它</li></ol></li><li>令牌环的工作原理体现了公平的接入原则，而且由于网络中不会出现几个站同时发送数据的情况，所以在重载环境下也不会因为冲突而影响效率。另外令牌环网还规定了每个站占用等待时间的上限，以保证一些实时性的应用。但是由于令牌环网的拓扑结构是闭合的环路，而且环路中使用了很多干线耦合器，一旦这些器件出现了故障，就会导致整个网络瘫痪。由于断点的检测比较困难，所以修复成本高（特点如下）<ul><li>公平原则，适合重载环境</li><li>确定每个站占用信道的等待时间上限</li><li>闭合环路一点断多点瘫，不易检查出断点</li></ul></li><li>针对上述令牌环网的缺点，利用总线型局域网的优势，令牌总线网就产生了<ul><li><img src="/img/article_img/computer_network61.png" alt=""><ol><li>令牌总现网在物理上是一个总线型的网络，但在逻辑上却构成了一个环，使令牌可以像在令牌环网中那样在网络中流动。</li><li>与环形的网络相比，令牌总现网具有更高的可靠性。比如在上述的7个站中，如果C站出现了故障，而G站未工作，剩下的5个站在逻辑上依旧可以组成一个令牌环网。这里令牌传递的顺序与站的物理位置无关</li><li>由此可见，令牌总线网既具有总现网的接入方便和可靠性高的有点，也具有令牌环网的无冲突和发送时延有确定上限值得有点。但是由于令牌在总线网中得传递顺序与站的物理位置无关，因此必须要有一个有效的<strong>麦克层协议</strong>来管理令牌，这就使得令牌总线网的协议非常复杂，所以推广应用比较差（特点如下）<ul><li>同时具有总现网和令牌环网的有点</li><li>协议复杂、推广应用困难</li></ul></li></ol></li></ul></li></ol></li></ul></li></ol></li></ol></li></ol><h3 id="二、信道共享技术之随机接入">二、信道共享技术之随机接入</h3><ol><li><p>纯ALOHA</p><ol><li><p>工作原理：想发就发。规定时间内若收到应答，表示发送成功；否则重发</p></li><li><p>重发策略</p><ol><li>若立即重发，则显然要再次冲突</li><li>等待一段随机时间，然后重发；若再次冲突，则再等待下一段随机的时间，知道重发成功为止</li></ol></li><li><p>工作过程</p><ul><li><img src="/img/article_img/computer_network62.png" alt=""></li></ul><ol><li>上图中主机A和主机B共享同一个信道。主机A先发送数据帧1，没有冲突</li><li>接下来A发送数据帧2，在数据帧2发送的同时，B发送数据帧3。显然数据帧2和数据帧3发生冲突，因此这两帧数据都要重传</li><li>主机A和主机B都随机等待一段时间后重传数据</li><li>显然，在ALOHA机制下，信道上接入的站点越多，负载越重，发生冲突的概率就越大，因此性能也就越差</li></ol></li></ol></li><li><p>时隙ALOHA</p><ol><li>工作原理：为了提高ALOHA的性能，将各站的时间都同步起来，并且将时间划分为一段段等长的时隙，一个时隙长度正好发完一帧。同时规定，无论帧何时产生，都只能在每个时隙开始的时候发送到信道上，这就是<strong>时隙ALOHA</strong></li><li>重发策略：同纯ALOHA</li><li>工作过程<ul><li><img src="/img/article_img/computer_network63.png" alt=""></li><li>以上面情况为例，主机A在发送数据帧2时，主机B产生了数据帧3，但按照时隙ALOHA的要求，数据帧3不能立即发送，而是要等到下一个时隙开始时才能发送。这样就避免了冲突</li><li>由此可见，与纯ALOHA相比，时隙ALOHA可以提高信道的吞吐量，改善性能</li></ul></li></ol></li><li><p>从ALOHA演变而来的CSMA（载波侦听多点接入—Carrier Sense Multiple Access）：</p><ol><li>工作原理：与ALOHA相比最大的差比就是增加了一个载波监听装置，每个站在发送数据之前都先监听一下信道上的其他站是否正在发送数据，如果有数据正在发送，那么该站就暂时不发送数据，这样就可以降低冲突发生的概率，把这个过程描述为“先听后发”</li><li>CSMA的分类（根据监听的方式可分为）<ol><li>非坚持CSMA：一旦监听到信道忙，就不再监听；延迟一个随机事件后再次监听<ol><li>一个缺点：随机一段时间后，再次监听前，信道就已经空闲了，也就是说无法在信道空闲的第一时间把数据发送出去，影响了信道利用率的提高，针对这个问题可以采用下面的坚持CSMA来解决</li></ol></li><li>坚持CSMA：监听到信道忙时，仍继续监听，直到信道空闲<ol><li>两种不同的发送策略<ol><li>1-坚持CSMA：一旦听到信道空闲就立刻发送数据（以概率1发送）<ul><li>问题：如果两个或更多的站同时采用这种方式监听信道，一旦信道空闲就会有多个站同时发送数据，这样就会发生冲突。</li></ul></li><li>p-坚持CSMA：因此就有了另外一种这种的策略，就是当听到信道空闲时，以概率p来发送数据，而以概率1-p来延迟一段时间重新监听信道</li></ol></li></ol></li><li>CSMA的缺点<ol><li>传播时延</li><li>仍然存在冲突的可能。比如：两个距离很远的站，其中一个站发送的数据在传输到另外一个站的附近之前是不会被监听到的。如果此时另外一个站也发送了数据，那么一段时间之后它们会碰撞在一起，如果两站没有发现这种碰撞而继续发送数据，那么后续的发送就是在拜拜浪费时间和资源</li><li>在冲突发生时，站不知道是否出现冲突，这样，发送数据的站将一直把数据发出，但显然这些数据是有错的，因此这段时间是浪费的</li></ol></li></ol></li></ol></li><li><p>CSMA/CD（Carrier Sense Multiple Access/Collision Detection）</p><ol><li>工作原理：边发送边监听（冲突检测）。若监听到冲突，则冲突双方都立即停止发送。信道很快空闲，从而提高效率。“先听后发，边发边听”</li><li>冲突检测的方法<ol><li>比较接受到的信号电压的大小：一旦信号经过叠加，其电压的摆动值就要比正常值大一倍</li><li>检测曼彻斯特编码的过零点：采用曼彻斯特编码时，电压的过零点是在每个比特的正中央。如果发生冲突，过零点的位置会发生偏移，所以根据过零点的位置也可以判断冲突</li><li>发送的同时也接受，将收到的信号逐个比特的与发送的信号进行比较，如果有不同就是发生了冲突。</li></ol></li><li>检测到冲突后，停止发送数据，并且发送人为干扰信号，强化冲突。<strong>目的</strong>：让信道上的每个站都能知道冲突的发生，这样信道就能很快地空闲下来</li><li>从前面的介绍中可以发现，由于电磁波的传播时延，在每个站刚刚发送数据开始的一段时间间隔内，仍然有发生冲突的可能，因此把这段时间称为冲突检测时间<ul><li><img src="/img/article_img/computer_network64.png" alt=""></li><li>总线一端的A站在$t=0$时刻向F发送数据帧</li><li>假设数据帧在A和F两站之间单程的传播时间为$T$.</li><li>F站在A站发出数据帧的某一时刻也想发送数据，于是就监听信道</li><li>由于A站发送的数据还没有到达F站附近，所以F站发现信道是空闲的，于是在$t=T-\tau$时刻向A发送数据帧（$\tau$是非常小的一个值），可见这两个数据帧一定会发生冲突，而且冲突会发生在F站附近</li><li>冲突首先会被F站发现，之后F站立即停止数据的发送，并发送人为干扰信号强化冲突</li><li>大约在$t=2T$的时刻，冲突信号会传到A站</li><li><strong>通过上述分析可知，如果两个最远站点间传输时间为$T$，那么信道的最大冲突检测时间为$2T$。</strong></li></ul></li><li>碰撞槽时间（Slot time）—最大冲突检测时间：<ol><li>指的是从发出数据开始，到检测到信号冲突的时间间隔的上限</li><li>假设最远主机之间的传输媒体长度为$S$，帧在媒体上的传输速度为$0.7C（C为光速）$，物理时延为$t_P$，那么两个站点间单程的传输时间为$T=\frac{S}{0.7C} + t_p$，$Slot time = 2T = \frac{2S}{0.7C} + 2t_p$.</li><li>显然碰撞槽时间越是小于一个帧的发送时间，CSMA/CD的优越性就越明显。相反，如果一个帧的发送是时间小于碰撞槽时间的话，那么即便冲突发生也无法检测出。因此在采用CSMA/CD的信道上，对链路上的最小帧长进行了限制</li><li>假设$L_{min}$是最小帧长，$R$是数据传输率，则必须满足$\frac{L_{min}}{R} \geq Slot \ time$；由上知$L_{min} = (\frac{2S}{0.7C} + 2t_p) \times R$.</li></ol></li></ol></li></ol><h2 id="五、局域网技术">五、局域网技术</h2><blockquote><p>tips：这一块的内容，我看的这个老师讲解的稀巴烂，感觉他说话罗里吧嗦的，还没有结构，然后下面的笔记就贼乱！！！不过我过段时间会看书直接给它补充完整。</p><p>真tm恶心，遇到讲课的老师，真tm吐了，连个英文单词都给你读一遍，三岁小孩？？？</p><p>有这个时间把课内容讲好不好吗？？？</p></blockquote><h3 id="一、局域网体系结构">一、局域网体系结构</h3><ol><li><p><strong>IEEE802参考模型</strong></p><ol><li><p>有别于传统的OSI模型以及5层体系结构</p></li><li><p>IEEE802参考模型对应于OSI参考模型的物理层和数据链路层。数据链路层又分为逻辑链路控制子层和介质访问控制子层</p></li><li><p>将数据链路层分为两个子层</p><ol><li>MAC：Media Access Control</li><li>LLC：Logical Link Control</li></ol><ul><li>原因：媒体介入方法太多，分成两层后便于简化系统的实现</li></ul></li></ol></li><li><p>局域网802参考模型和OSI/RM的对比</p><ol><li><p>在5层体系结构中，把数据链路层分为两个子层</p><ul><li><img src="/img/article_img/computer_network65.png" alt=""></li></ul><ol><li><p>两个子层</p><ol><li>偏上的<strong>逻辑链路控制LLC子层</strong>：主要向上层提供连接的环境</li><li>偏下的是<strong>媒体访问控制MAC子层</strong>：对下层提供媒体访问的具体方法</li><li>两者通过统一的物理层来传输数据</li></ol></li><li><p>最下面的是物理层：作为传输介质</p></li><li><p>在数据链路层中需要提供SAP（service access point—服务访问点），服务访问点应该出于偏上层的LLC子层上</p></li><li><p>各层的功能</p><ol><li><p>物理层：负责信号的编码译码、同步码的产生和去除、比特的传输和接收</p><ul><li>物理层的功能和传统的五层体系结构是一致的</li></ul></li><li><p>MAC层：成帧和拆帧、实现和维护MAC协议、比特差错检验、寻址</p><ul><li><p>注意，在差错检验中，一旦检验出差错进行后处理时，差错控制机制是交给LLC子层来处理</p><p>的</p></li></ul></li><li><p>LLC层：建立和释放逻辑链路、与高层的接口、差错的控制、给帧加（减）序号</p><ul><li>由于MAC子层负责媒体传输访问的细节，所以局域网的传输介质访问细节对于LLC子层是透明的</li></ul></li></ol></li><li><p>这样分成两个不同的子层，在IEEE802参考模型中存在两个不同的PDU</p><ul><li><img src="/img/article_img/computer_network66.png" alt=""></li></ul><ol><li>LLC-PDU：高层数据首先被交给LLC子层，加上LLC首部幸成LLC的PDU</li><li>向下会交给MAC子层，将LLC-PDU当成MAC子层的数据部分，然后分别加上MAC的首部和尾部，封装成帧，这是就会出现两个不同的PDU</li></ol></li><li><p>IEEE802参考模型的架构</p><ul><li><img src="/img/article_img/computer_network67.png" alt=""></li><li>将802参考模型分成若干个子标准</li><li>802.1是一个总述，用来描述OSI模型与网络管理在IEEE802参考模型中发挥的作用</li><li>802.2用来描述LLC子层。在IEEE802参考模型中只有一个802.2文档是用来描述LLC子层的<ul><li>其他802.3之后的是描述MAC子层的</li></ul></li><li>802.3是用来描述CSMA/CD—以太网</li><li>802.4用来描述令牌总线网</li><li>802.5用来描述令牌环网</li><li>还有802.6用来描述城域网，802.11用来描述无线网–WIFI的</li></ul></li><li><p>在802体系结构定义下局域网的地址结构</p><ul><li><img src="/img/article_img/computer_network68.png" alt=""></li></ul><ol><li>局域网中，地址表示采用二进制来进行描述。在IEEE802的体系结构中，局域网的地址使用的是MAC地址，使用的是48比特的二进制数来进行定义的，实际记录采用的是十六进制</li><li>MAC地址是网卡地址或者说只要是网络接口上的都有MAC地址的信息。在实际的记录和表示时，6组十六进制数也采用点进行分割</li><li>MAC地址作为网络设备接口的标识，它在记录地址信息的时候需要保证全球的唯一性<ul><li>MAC地址分为两部分。前24比特叫制造商ID，有IEEE统一分配；后24比特由公司企业内部自己确定它的唯一性</li></ul></li></ol></li></ol></li></ol></li></ol><h3 id="二、以太网">二、以太网</h3><ol><li><p>以太网V2的MAC帧格式</p><ol><li>802.3采用CSMA/CD（先听后发，边听边发的策略），称为以太网Ethernet，重载下性能差。分类如下：<ul><li>10 BASE 5、10 BASE 2、10 BASE T、10 BASE F</li><li>BASE：表示采用基带的信号进行传递。BASE前面的数值描述当前技术的网络带宽的大小，BASE后面的字符表示所使用的细节。如10 BASE 5，10MBPS的基带粗缆以太网</li></ul></li></ol><ul><li><img src="/img/article_img/computer_network69.png" alt=""></li></ul><ol start="2"><li>上图就是以太网的MAC帧格式。第一个字段6字节是目的地址，第二个字段6字节是源地址，第三字段2字节用来标识这个帧所携带的数据部分它封装的高层协议，最后一个字段4字节是它的校验字段，合到一起就成为了一个以太网的帧格式。然后被物理层发送出去</li><li>以太网的帧被物理层发送出去前，需要在前面增加8字节的比特同步。在实际传输要比MAC帧多8个字节，起到同步和前挡的作用<ul><li>根据以太网的帧格式就能很好的分析以太网所携带的数据的含义</li></ul></li></ol></li><li><p>标准以太网（10 BASE 5）</p><ul><li>传输媒体10mm粗缆（铜缆）</li><li>特性抗阻50$\Omega$.</li><li>曼彻斯特编码</li><li>总线拓扑</li><li>10Mbps</li><li>单段最长500m<ul><li>方波在传输时随着距离的增加会有信号的衰减和变形，当达到500m时信号就可能衰减的不可识别</li></ul></li></ul><ol><li>Repeater（中继器）：在物理层上实现局域网互联的设备，负责连接各个电缆段，对信号进行放大和整形，驱动长线电缆连接。<ul><li>不能无线增加长度，<strong>“543”规则</strong></li><li><img src="/img/article_img/computer_network70.png" alt=""></li><li>使用中继器续连时，500m最多5段；4个中继器；最多三段500米可以连接计算机</li></ul></li></ol></li><li><p>细缆以太网10 BASE 2</p><ul><li>传输媒体：细缆</li><li>特征抗阻：50$\Omega$.</li><li>曼彻斯特编码</li><li>总线拓扑</li><li>单端最长185m</li><li>185*5=925m，网络跨距最大长度</li></ul><ol><li>细缆和网卡的连接方式<ul><li><img src="/img/article_img/computer_network71.png" alt=""></li><li>通过BNC的T型头直接与网卡连接，省去了连接的电缆</li></ul></li></ol></li><li><p>10 BASE T（T（twisted pair）—双绞线）</p><ul><li>传输媒体：UTP</li><li>RJ-45连接器<ul><li><img src="/img/article_img/computer_network72.png" alt="水晶头"></li></ul></li><li>星形拓扑结构<ul><li><img src="/img/article_img/computer_network75.png" alt="星形拓扑和级连"></li><li>扩展网络距离，两个集线器连接一条级连线</li></ul></li><li>单段最长100m</li><li>曼彻斯特编码</li><li>使用HUB互连<ul><li><img src="/img/article_img/computer_network73.png" alt="集线器"></li></ul></li><li>网络跨距500m</li><li><img src="/img/article_img/computer_network74.png" alt="集线器和计算机的互连"></li></ul><ol><li>在使用双绞线的网络中，如果要扩展网络距离，就要使用级连的方式</li><li>级连的规则（10 BASE T 要求）<ol><li>距离最远的两排主机之间最多只能间隔4个集线器<ul><li><img src="/img/article_img/computer_network76.png" alt=""></li><li><img src="/img/article_img/computer_network77.png" alt=""></li><li>很显然第一张图可以，第二张图不行</li></ul></li></ol></li></ol></li></ol><h3 id="三、快速以太网">三、快速以太网</h3><ol><li><p>采用的是100Mbps的带宽。100 BASE TX</p><ul><li>传输介质：5类UTP</li><li>传输速率：100Mbps</li><li>CSMA/CD</li><li>单段线路最长100m</li><li>使用HUB连接</li></ul><ol><li><p>网络跨距问题</p><ul><li><p><img src="/img/article_img/computer_network78.png" alt=""></p></li><li><p>系统中最多两个集线器，且距离不大于5m，两台主机之间最大距离205m</p></li></ul></li></ol></li><li><p>除了是用双绞线作为传输介质，也可以使用光纤作为传输介质。100 BASE FX</p><ul><li>传输介质：光纤</li><li>传输速率：100Mbps</li><li>CSMA/CD</li><li>使用<strong>一对</strong>光纤进行连接传输<ul><li>因为光纤只能单向传输数据，而网络通信需要双向传输数据</li></ul></li></ul></li></ol><h3 id="四、局域网的扩展">四、局域网的扩展</h3><ol><li><p>网桥</p><ol><li><p>网桥基本原理</p><ul><li><img src="/img/article_img/computer_network79.png" alt=""></li><li>网桥可以连接多段不同的网络。上图中的网络有2个口（端口A和端口B）。端口A连接了一个集线器所连接的网络，端口B连接了另一个集线器所连接的网络将这个网络分成了两个部分。一个是1，2，3三台主机，另外一个是4，5，6三台主机</li><li>网桥内部和中继器不同的是，网桥有一个表，这个表就是MAC地址表。网桥内部的MAC地址表记录的是它的端口和主机的对应关系。比如上图中，记录下来端口A对应主机1，2，3，端口B对应主机4，5，6.</li><li>网桥可以依据上述表记录的消息来决策是否转发数据</li><li>比如透明网桥<ol><li>帧的转发策略（先查看帧的地址DA/SA（目的地址/源地址））<ol><li>相同网络数据交换，丢弃帧，不转发</li><li>不同网络数据交换，接收处理帧，转发</li></ol></li><li>帧转发规则（查看MAC地址表）<ol><li>DA在表内，按表的指定端口转发帧</li><li>DA不在表内，用扩散Flooding方式转发帧（向所有其他端口转发帧）</li></ol></li></ol></li></ul></li><li><p>在上图网桥进行工作的时候</p><ol><li>如果1向2发送数据时。这个信号将通过端口A到达网桥时，网桥通过查表，发现原MAC地址和目的MAC地址是相同网络的，这时候网桥将不会把这个数据通过B口转发出去。</li><li>而如果是当1向4发送数据时，网桥通过查找MAC地址表，发现这是不同网络之间的数据传输，才会转发这个数据。</li><li>如果1向2发送数据的同时，4也向5发送数据时，由于网桥的隔离效果，使得1，2发送数据的同时，4，5也能同时发送数据，<strong>这样就使得网桥有效的隔离了传输的数据流量</strong>。</li></ol></li><li><p>网桥在工作时能有效的对各个不同的网络区域进行分隔</p><ul><li><img src="/img/article_img/computer_network80.png" alt=""></li></ul><ol><li>上图中，B1和B2是两个网桥，它们不同口上所连接的局域网都可以在独立的进行数据传输，数据通信可以同时进行，大大的提高了数据传输效率。</li><li>而如果中间不是网桥而是中继器，显然只能同时有两台主机之间进行通信，这样网桥就可以有效的隔离冲突域</li></ol></li><li><p>网桥的优点</p><ol><li>过滤通信量</li><li>扩大物理传输范围</li><li>可以连接不同的物理层</li><li>提高传输的可靠性</li></ol></li><li><p>网桥的缺点</p><ol><li>增加了传输延迟</li><li>没有流量控制功能，可能产生溢出</li><li>帧的处理耗费时间</li><li>只适合比较小的局域网，大规模的局域网中可能产生广播风暴</li></ol></li></ol></li><li><p>最常用的**“局域网交换机”**</p><ol><li><p>局域网交换机与网桥的关系类似HUB和中继器的关系，HUB/集线器是多端口的中继器，而局域网交换机可以说是多端口的网桥。</p></li><li><p>局域网交换机的基本工作原理和网桥是类似的，只不过在工作过程中采用了交换技术。一般来说是目前局域网的常用阻抗设备</p></li><li><p>局域网交换机的原理</p><ul><li><img src="/img/article_img/computer_network81.png" alt=""></li><li>如上图，与网桥类似，局域网交换机的内部也有一个MAC地址表来记录每个端口与对应主机之间的关系。与网桥也类似的是当进行决策转发时，交换机也可以去根据源地址和目的地址是否在同一网络内来决策是否转发这个数据。与此同时交换机还采用了交换技术</li></ul></li><li><p>局域网交换机的主要特点</p><ol><li>所有端口平时都不连通</li><li>当接入交换机的设备之间需要通信时，交换机能够同时连通许多对端口</li><li>每一对相互通信的设备都能像独占通信介质那样进行无冲突的数据传输</li><li>双方完成通信后，会断开这种连接</li></ol><ul><li>这样就使得网络中不同端口对之间可以同时进行数据传输，这就是所谓的<strong>交换</strong>。</li></ul></li><li><p>局域网交换机在进行帧的转发过程中，需要首先去决定到底如何缓存这个帧。因为只有当局域网交换机先缓存好帧之后，才有可能根据帧里面的字段来决策是否转发这个数据。具体缓存策略分为3中</p><ol><li><p>Store &amp; Forward（存储转发式）</p><ul><li>最早期的局域网缓存设备是需要将整个的帧完全缓存后，去识别目的MAC地址的信息与原MAC地址的信息进行比对，然后决策是否进行转发。</li><li>当然，如果将全部的帧尽心缓存后，可以通过CRC校验的方式来确保所转发帧的正确性，不会转发废弃的数据和错误的数据。可以提高数据转发的效率</li><li>反过来说，又会降低数据转发的效率。因为缓存本身所花费的延迟时间比较长</li></ul></li><li><p>Cut Through（直通式）</p><ul><li>考虑存储转发式需要缓存全部的数据帧，代价太大。因此考虑缓存比较少的数据量，比方说根据前面的以太网帧的结构，实际上交换机只需要去识别所接到帧的目的MAC地址信息就可以了</li><li><img src="/img/article_img/computer_network82.png" alt=""></li><li>而目的MAC地址正好出现在以太网帧的前6个字节，因此没有必要缓存全部的数据帧，而只需要缓存前6个字节就可以获取所需要的目的MAC地址。</li><li>由于上面缓存的数据量少，缓存所花费的时间少</li><li>但也存在问题，无法进行CRC校验，可能会转发报文碎片</li></ul><ul><li>[x] 报文碎片：局域网中小于64字节的数据帧一定是报文碎片。前面有对以太网数据帧的最小长度限定为64字节，所以当某个数据帧字节数小于64那么就一定是一个错误的数据帧</li></ul></li><li><p>Fragment Free</p><ul><li>为了确保以太网交换机不转发报文碎片，所以出现了这种转发策略</li><li>仅缓存前面64个字节的数据</li><li>缓存前64字节数据时，一方面可以获取目的MAC地址的信息，另一方面也可以尽量减少所缓存的总的数据量，因此性能在一定程度上是提高的</li></ul></li></ol></li></ol></li></ol><h3 id="五、千兆位以太网">五、千兆位以太网</h3><ol><li><p>最早采用的技术是1000 BASE CX</p><ul><li><p>使用特殊标准的短距离屏蔽铜缆来进行连接，最长25m</p></li><li><p>使用9芯的D型连接器</p></li><li><p><img src="/img/article_img/computer_network83.png" alt=""></p></li><li><p>但是与百兆和10兆的技术不兼容，只是一个临时的过度技术</p></li></ul></li><li><p>采用光纤连接的千兆位以太网包括1000 BASE LX和1000 BASE SX</p></li><li><p>1000 BASE LX（L-&gt;long，长波激光光源）</p><ul><li>传输媒体为光纤</li><li>长波激光光源（LWL）</li><li>波长1270nm—1355nm</li><li>可以驱动的单模或者多模的光纤</li><li>使用SC型光纤连接器，与100 BASE FX相同（可以支持由百兆到千兆的平滑升级）</li></ul></li><li><p>1000 BASE SX（S-&gt;Short，短波激光光源）</p><ul><li>传输媒体为光纤</li><li>短波激光光源（SWL）</li><li>波长770nm—860nm</li><li>只支持多模的光纤</li><li>使用SC型光纤连接器，与100 BASE FX相同（可以支持由百兆到千兆的平滑升级）</li></ul></li><li><p>1000 BASE T（T，双绞线）</p><ul><li>传输媒体为双绞线</li><li>IEEE802.3ab</li><li>RJ-45连接器，与100 BASE T相同（可以支持由百兆到千兆的平滑升级）</li><li>跨距100m，兼容其他双绞线连接方式</li></ul></li><li><p><img src="/img/article_img/computer_network84.png" alt=""></p></li><li><p>帧扩展</p><ul><li>千兆位以太网的挑战—它的最小帧长度需要做一个扩充</li><li>把最小帧长度一直扩展为512字节</li><li>对于小于512字节的小帧，添加扩展位</li><li><img src="/img/article_img/computer_network85.png" alt=""></li></ul></li><li><p>帧突发</p><ul><li>作为千兆以太网，仅仅做了帧扩展后是不够的，因为帧扩展使用的扩展位是无效数据，会降低网络传输的效率。这样会造成总体的有效数据量比例下降，因此造成总的带宽浪费。因此帧扩展需要另外一个技术来进行支持，以提高数据传输的效率，这就是所谓的帧突发<ul><li>帧扩展在大量的短帧环境中容易造成宽带浪费</li></ul></li><li>如果一个站点需要连续发送短帧，则第一个帧需要增加扩展位到512字节后再发出去。一旦第一个帧成功发送，那么后续短帧就可以连续发送，直到1500字节<ul><li><img src="/img/article_img/computer_network86.png" alt=""></li><li>允许站点连续发送多个短帧，直到1500字节</li><li>在后续短帧进行发送的时候，短帧与短帧之间要通过帧间隙来进行分隔，帧间隙是既非0又非1的符号，这就是帧突发技术</li></ul></li></ul></li></ol><h2 id="六、网络层与网络互连">六、网络层与网络互连</h2><h3 id="一、互联网">一、互联网</h3><ol><li>因特网（Internet）：全球最大的、开放的，由众多网络相互连接而成的特定计算机网络，采用TCP/IP协议簇，前身位ARPANET</li><li>互联网（Internet）：泛指多个计算机网络互连形成的计算机网络</li><li><img src="/img/article_img/computer_network87.png" alt=""></li></ol><h3 id="二、IP地址和子网掩码">二、IP地址和子网掩码</h3><ol><li><p>IP地址（IP协议的地址），IP协议----Internet Protocol</p></li><li><p>在网络层当中，可以提供两种不同的服务模式</p><ul><li>可靠的面向连接的服务</li><li>不可靠的无连接服务</li></ul></li><li><p>IP协议是Internet中不可靠的无连接服务</p></li><li><p>IP协议的特点</p><ul><li>采用“尽力传递”的设计思想：因为IP协议无法提供可靠的数据传输，主要原因在于IP协议采用无连接的分组传输机制<ul><li>面向连接：指的是在通信之前需要建立连接，在通信当中需要维护连接，在通信后需要释放连接，如下图的打电话</li><li><img src="/img/article_img/computer_network88.png" alt=""></li><li>无连接就是无需去建立维护和断开连接，最典型的例子就是发短信</li><li>无连接方式的通信双方无法知道对方的状态，所以不可靠（没有差错恢复，同时可能有数据丢失）</li><li>纠错重传问题交给传输层解决</li></ul></li><li>快速、简单、效率高（牺牲数据传输的可靠性来获取数据传输的快速简单和高效性，IP协议的高层具有其他协议来帮助进行纠错和重传）</li><li>实现IP的路由</li></ul></li><li><p>IP层的主要协议</p><ul><li>应用层、运输层、网络层、链路层、物理层</li></ul><ol><li>TCP/IP协议簇的网络层，可以称为IP层。在IP层中，最核心的协议是IP协议。还有一些辅助的其他协议，比如偏下层的ARP和RARP协议，偏上层的ICMP和IGMP协议</li></ol></li><li><p>IP地址</p><ol><li><p>IP地址的组成：</p><ul><li><p>IP地址典型的是由：网络（ID）地址和网络上计算机地址（ID）两部分组成</p></li><li><p>IP地址是使用4个8位（32位）二进制字节表示。实际记录用4个点分的十进制数表示如<code>202.118.100.196</code>，其中每个十进制数都会对应一个8位的2进制数，所以范围是<code>0~255</code>。</p></li><li><p>32比特的二进制数被人为的分为两部分</p><ul><li><img src="/img/article_img/computer_network89.png" alt=""></li></ul><ol><li>网络ID</li><li>主机ID</li></ol><ul><li>原因是：这和IP地址的寻址方式相关。IP地址寻址时首先会根据网络号寻找网络，找到网络后，再在网络当中根据主机号来寻找主机，因此需要把IP地址分为网络号和主机号</li></ul></li></ul></li><li><p>IP地址的分类</p><ol><li><p>原因：网络号和主机号占用的比特数会影响网络数和网络中主机数的变化</p></li><li><p>IP地址一般被分为A、B、C、D、E，共5类，且常用的有A，B，C类（可以分配主机号）</p><ol><li>A类地址<ul><li><img src="/img/article_img/computer_network90.png" alt=""></li><li>前8个比特为网络号，后24个比特为主机号</li><li>0作为第一个比特</li></ul></li><li>B类地址<ul><li><img src="/img/article_img/computer_network91.png" alt=""></li><li>前16比特为网络号，后16比特为主机号</li><li>前两个比特位10</li></ul></li><li>C类地址<ul><li><img src="/img/article_img/computer_network92.png" alt=""></li><li>前24比特为网络号，后8比特为主机号</li><li>前三比特为110</li></ul></li><li>D类地址<ul><li><img src="/img/article_img/computer_network93.png" alt=""></li><li>1110开始的为D类地址，为多个地址</li></ul></li><li>E类地址<ul><li><img src="/img/article_img/computer_network94.png" alt=""></li><li>以11110开始的是E类地址，E类地址是保留做未来使用的</li></ul></li></ol></li><li><p><img src="/img/article_img/computer_network95.png" alt=""></p><ul><li>通过第一个十进制数就可以很清楚的分别属于哪类IP地址</li></ul></li><li><p><img src="/img/article_img/computer_network96.png" alt=""></p><ul><li>全0表示自己，全1表示所有</li><li>Host：本机（不能参与通信，仅在主机未获得自身IP地址时临时使用的一个IP地址）</li><li>A host on this network：本网络的某个主机号</li><li>Broadcast on the local network：本网络内的广播（只能向本网络内的所有主机发送信息）</li><li>Broadcast on a distant network：某网络的广播地址<ul><li>如果<code>network|0000...0000</code>：表示某网络的网络号</li></ul></li><li>Loopback address：简单的说表示本机（可以向这个发送数据，但是向这个地址发送数据时，这个数据包不会通过数据链路层和物理层的封装和转发，直接会在网络层作为一个Loopbacks的转发，直接发给接收方的模块）</li></ul></li><li><p>总结</p><ul><li><p>分配给主机的IP地址，其主机号不能全为‘0’</p></li><li><p>分配给主机的IP地址，其主机号不能全为‘1’</p></li><li><p>主机号为全‘0’的，表示某网络的网络号</p></li><li><p>主机号为全‘1’的，表示某网络的广播地址</p></li><li><p>如果主机号为n位，则能容纳$2^n-2$台主机</p></li></ul></li></ol></li></ol></li><li><p>子网掩码</p><ul><li>新问题，作为主机，如何判断一个IP地址它的网络号到底是多少？（计算机不擅长逻辑，擅长计算）</li><li><strong>子网掩码</strong>是由连续的若干个二进制“1”组成的代码，而组成子网掩码的“1”的个数与网络号比特数相同</li><li>确定网络ID和主机ID的方法：<code>子网掩码 and IP地址 = 网络地址（ID）</code>。</li><li>主机使用子网掩码判断目的IP地址是否与主机处在同一个网络中</li><li>主机在发送数据前使用目的IP地址与子网掩码进行与运算，再把本机的IP地址和子网掩码进行一次与运算，比较两次结果<ol><li>结果相同，则是在本网络中进行数据传输</li><li>结果不同，不是在本网络中进行数据传输，则需要将发送的数据发送到网络的出口，发到其他网络中去</li></ol></li></ul></li></ol><h3 id="三、ARP协议">三、ARP协议</h3><ol><li><p>ARP协议（Address Resolution Protocol—地址解析协议）</p><ol><li><p>功能：MAC地址和IP地址之间的地址转换功能</p></li><li><p>网络中两个层都有自己的地址，数据链路层有自己的MAC地址，网络层TCP/IP协议中有自己的IP地址。面临一个问题，这两个地址如何进行映射？</p><ul><li><img src="/img/article_img/computer_network97.png" alt=""></li><li>换句话说，在传输过程中，很可能我已经知道对方的IP地址，却不知道MAC地址，这时候就需要做一个转换。为什么IP地址和MAC地址需要进行转换？形象点：IP地址相当于人名，MAC地址相当于人本身</li></ul></li><li><p>基本原理</p><ul><li><img src="/img/article_img/computer_network98.png" alt=""></li><li>比如上图中，绿色箭头两端的电脑需要从尾端向箭头端的主机发送数据，发送主机已经知道对方主机的IP地址，却不知道MAC地址</li><li>由于局域网是一个易于传播的环境，因此，请求主机只需要向网络发送一个广播的ARP请求，并且等待对方的这个请求主机的返回一个ARP应答即可</li><li>其中有个小问题：为何要广播发送请求，得到应答后，然后再单播的通信呢？直接广播发送数据就行了。<ol><li>原因：人的大脑是有记忆的，也就是说只要问过一次张三是谁后，就可以记住张三的名字和这个人对应的关系，下此就可以直接找张三这个人就行，不需要再次广播了。网络中和这是类似的，尤其是在局域网中一般来说要尽量避免广播通信的产生，要尽量减少广播通信量。因此作为ARP协议，基于这样的思想，做了些改进。</li></ol></li></ul></li><li><p>ARP协议的改进</p><ul><li><img src="/img/article_img/computer_network99.png" alt=""></li></ul><ol><li>首先给参与通信的每台主机都分配了一个ARP Cache，这个ARP Cache实际上就是一个IP地址和MAC地址的映射表，它就相当于进行人的记忆。</li><li>同时，ARP协议还采用了<strong>捎带技术</strong>，比方说A向B发送数据的时候，往往意味着B过一段时间也要向A发送数据。这时当A向整个网络去发送广播ARP请求的时候，它就简单的捎带着本机的IP地址和MAC地址的对应关系也发送出去就可以了。这样，A主机当它捎带发送本机的IP地址和MAC地址的对应关系后，B主机接收到这个ARP请求，B主机就可以先将A主机的IP地址和MAC地址的对应关系存放在本机的ARP Cache中，然后B主机再向A主机返回自己得IP地址和MAC地址对应得关系，由A主机存放在本机得ARP Cache当中。这样一次请求和应答A，B两台主机都知道了对方得IP地址和MAC地址得对应关系。接下来，两台主机就可以再继续通信了，并且在通信过程当中，就可以避免再次发送广播ARP请求了。</li></ol></li><li><p>ARP协议得工作原理小结</p><ul><li>ARP协议进行得是IP地址和MAC地址得转换</li><li>首先查找本机得ARP Cache，如果存在记录则直接使用本地得记录</li><li>如果ARP Cache当中没有记录，则发送ARP请求报文进行询问</li><li>被询问得主机由于捎带技术得原因，会记录下请求方得IP地址和MAC地址得对应关系，并返回应答</li><li>询问得计算机收到应答后，修改本机得Cache内容</li><li>ARP工作原理是基于**”信任机制“**而工作的</li></ul></li><li><p>基于<strong>信任机制</strong>/利用ARP协议漏洞的入侵方式</p><ul><li><img src="/img/article_img/computer_network100.png" alt=""></li></ul><ol><li>B，C之间进行敏感数据的操作，这时A主机想要冒充C来与B进行通信。A主机IP地址为<code>202.118.1.3</code>，它就可以主动的向B主机发送一个虚假的ARP请求，告诉B主机<code>202.118.1.1</code>所对应的MAC地址是我A的MAC地址。当然B主机比较老实，高速A主机<code>202.118.1.2</code>是我B主机的MAC地址，这时候B主机试图向C主机发送数据，也就是向<code>202.118.1.1</code>发送数据，实际上这个数据会发送给A。因为B主机会把<code>202.118.1.1</code>所对应的A的MAC地址进行使用，最终数据就发送给了A主机</li><li>上述还存在一些其他情况，B，C主机的管理员可能会在平时进行沟通。很可能B主机向C主机发送数据后，管理员会高速C主机说，我把这个数据已经发过去了，这时候C主机可能发现没有接受到数据从而发现A主机所进行的攻击.</li><li>上面的攻击模式可以更进一步：A主机先向B主机发送一个假得ARP请求，告诉B主机<code>202.118.1.1</code>所对应的MAC地址是A的MAC地址；接下来A主机再向C主机发送一个假得ARP请求告诉C主机<code>202.118.1.2</code>所对应的MAC地址是我A的MAC地址。这时候可以发现A主机出于一个镶嵌再B，C主机之间的位置。如果A主机上运行一个非常良好的转发程序—也就是说当B把数据给A的时候，A把数据传给C；当C把数据传给A时，A再把数据传给B。这样B，C之间的所有数据都会被A主机截获，甚至于A主机可以篡改B，C之间的所有数据通信，这样所造成的危害及其严重。------这就是ARP协议所面临的非常严重的攻击漏洞<ul><li><img src="/img/article_img/computer_network101.png" alt=""></li></ul></li></ol></li><li><p>Arp命令</p><ol><li><p>从上面可以发现ARP Cache非常关键，那么如何获取ARP Cache的内容呢？</p></li><li><p>任何一个操作系统都有一个ARP指令，比如Windows下，运行<code>arp -a</code>时，就可以获取本机的ARP Cache里面的值。那么这个ARP Cache里面所显示的值是什么值呢？</p><blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">C</span>:\&gt;arp -a<br><br><span class="hljs-attribute">Interface</span>: <span class="hljs-number">192.168.56.1</span> --- <span class="hljs-number">0</span>x<span class="hljs-number">5</span><br>  <span class="hljs-attribute">Internet</span> Address      Physical Address      Type<br>  <span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">56</span>.<span class="hljs-number">255</span>        ff-ff-ff-ff-ff-ff     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">22</span>            <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-<span class="hljs-number">16</span>     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">251</span>           <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-fb     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">252</span>           <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-fc     static<br>  <span class="hljs-attribute">239</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">250</span>       <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">7</span>f-ff-fa     static<br><br><span class="hljs-attribute">Interface</span>: <span class="hljs-number">192.168.2.190</span> --- <span class="hljs-number">0</span>xf<br>  <span class="hljs-attribute">Internet</span> Address      Physical Address      Type<br>  <span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">2</span>.<span class="hljs-number">1</span>           d<span class="hljs-number">8</span>-c<span class="hljs-number">8</span>-e<span class="hljs-number">9</span>-<span class="hljs-number">80</span>-b<span class="hljs-number">6</span>-d<span class="hljs-number">9</span>     dynamic<br>  <span class="hljs-attribute">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">2</span>.<span class="hljs-number">255</span>         ff-ff-ff-ff-ff-ff     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">22</span>            <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-<span class="hljs-number">16</span>     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">251</span>           <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-fb     static<br>  <span class="hljs-attribute">224</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">252</span>           <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">00</span>-<span class="hljs-number">00</span>-fc     static<br>  <span class="hljs-attribute">239</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">250</span>       <span class="hljs-number">01</span>-<span class="hljs-number">00</span>-<span class="hljs-number">5</span>e-<span class="hljs-number">7</span>f-ff-fa     static<br>  <span class="hljs-attribute">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>       ff-ff-ff-ff-ff-ff     static<br></code></pre></td></tr></table></figure></blockquote></li><li><p>它显示的是近期与本机通信过的对方主机的IP地址和MAC 地址的对应关系</p></li></ol></li><li><p>ARP协议的漏洞如何防范</p><ul><li>ARP协议的漏洞很大一部分原因是ARP协议支持的IP地址到MAC地址的动态映射。要想在一定程度上避免这种问题，就需要使用<strong>静态地址映射</strong>。</li><li>实现静态地址映射的方案也很简单：<ol><li>我们可以使用ARP指令的-S参数来实现IP地址到MAC地址的静态映射关系。<code>C:\&gt;arp -s 157.55.85.212 00-aa-00-62-c6-09</code>。</li><li>-s:static</li></ol></li><li>这种方案并没由完全解决ARP协议的漏洞，是通过牺牲ARP协议的方便性来获取安全性。</li></ul></li></ol></li></ol><h3 id="四、IP协议">四、IP协议</h3><ol><li>IP数据报（datagram）：是IP协议的PDU（协议数据单元），是Internet上数据传输的基本单元。</li><li>路由器在不同的网络间转发IP分组，实现IP数据报的“寻路”功能。</li></ol><ul><li><img src="/img/article_img/computer_network102.png" alt=""></li></ul><ol start="3"><li><p>上图是<strong>IP数据报文的格式</strong></p><ol><li><p>Version：版本号，目前为4（IPV4）</p></li><li><p>HLen：Header length—首部长度，以4字节为单位记录（比如20个字节的首部，记录5）</p></li><li><p>TOS：Type of service—服务类型字段。这个字段8比特中，前3个比特是优先级比特（也就是可以给出IP数据报的8个优先级），其余的5个比特中，有4个比特是目前有意义的，分别为D T R C，最后一个比特是保留比特</p><ul><li><p><img src="/img/article_img/computer_network103.png" alt=""></p></li><li><p>D为1：低时延服务</p></li><li><p>T为1：高吞吐率的服务</p></li><li><p>R为1：高可靠性服务</p></li><li><p>C为1：低费用服务</p></li><li><p>特定情况下，只能有一个为1</p></li></ul></li><li><p>TotalLength：总长度，以字节为单位</p></li><li><p>TTL：Time To Live----网络数据传输中，可能会出现异常情况，使得IP数据报误入歧途，走到某一个未知的网络中，并且找不到出口，这个时候的IP数据报即废弃的IP数据报，那么在Internet当中，会产生大量的废弃IP数据报，如果这些废弃的IP数据报不及时处理掉，就会导致在Internet当中塞满这种废弃的IP数据报，这时候TTL值会发生作用。在初始时，当一个主机发出IP数据报时TTL=255，每经过一个路由器，TTL的值就减1，当路由器知道TTL=0时，IP数据报就会被处理掉。这样就能避免在Internet当中出现大量的废弃的IP数据报。</p></li><li><p>协议：指这个IP数据报它的数据部分所封装的高层的协议类型</p></li><li><p>checksum：首部校验和字段。主要功能是对IP数据报的首部进行校验和的计算</p></li><li><p>option：选项/填充字段。一般情况，IP数据报的首部不携带选项字段，除非某些个在特殊应用的场合。这时候IP数据报它的首部长度会大于20字节；如果IP数据报首部不携带option字段，IP数据报首部长度默认为20字节。</p></li><li><p>还有三个字段没有包括进来：identification、flags、fragment offset----标识、标志、分片偏移量。这三个字段与IP数据报的分片相关的字段</p></li></ol></li><li><p>IP数据报文的分片</p><ol><li>分片的问题：IP数据报是被链路层的帧所封装的，因此IP数据报的长度实际上受限于数据链路层的帧的长度。而数据链路层的帧的最大长度一定不是无限长的，上限值即MTU。这个最大长度最终限制了IP数据报所能携带的数据的数据量。因此在传输过程中可能发生—由于不同部分的网络它的MTU不同，可能会导致网络传输当中出现分片的问题。<ul><li>MTU：最大传输单元，指局域网中的最长帧。</li><li><img src="/img/article_img/computer_network104.png" alt=""></li><li>如上图，A，B所在网络和C，D所在网络它们的两端网络MTU=1500，但是这两个网络之间，通过路由器连接的这段中转网络它的MTU是620字节。某一时刻A主机发送一个IP数据报时，长度很可能会超出中间网络的MTU。这时候，通过中转的MTU=620的网络进行中转时，就会面临中转网络的MTU小于要传输的IP数据报的长度，此时要想完成数据的传输，就要在<strong>路由器</strong>上对IP数据报进行分片。</li></ul></li><li>小结<ol><li>不同局域网的MTU是不同的</li><li>当较大的报文经过MTU小的局域网之前，应该对该报文进行分片</li><li>分片由路由器完成</li><li>分片时，应该对IP数据报的数据段进行操作，IP数据报的首部要进行微调，并不参与IP数据报的分片过程<ul><li><img src="/img/article_img/computer_network105.png" alt=""></li><li>如上图，A主机想要把一个数据报发给D主机。初始的时候，A发出的数据报由于它要最大限度地使用网络地MTU，因此可能发出这样一个IP数据报—首部长度20字节，数据部分为1400字节，总长度1420字节。这个数据报就会被A主机发到中转路由器，路由器接受到这个IP数据报时，下一段网络地MTU=620小于要传输地数据报地长度。</li><li>此时，路由器会将IP数据报的数据部分（<strong>注意，不含首部</strong>）分成若干份。让前两份数据都是600字节，最后一个200字节，整成若干个小数据段发送。<strong>但是，显然是不能直接发送的，因为最后还要进行排序和连接</strong>。</li><li>给每个数据段前面加上一个分片的首部，通过分片首部的数据来描述和记录当前分片在原始IP数据报中的位置等相关信息。一旦组合后，原来分段后的数据前面加上20字节的首部就形成了一个IP数据报，恰好能在下一段网络中转发出去</li><li>接下来，当这个数据通过重复的转发，到达接收方的D主机之后，D主机需要将接受到的分片进行重组，恢复为原来的IP数据报。对于D主机来说，它需要一个<strong>接收方的缓冲区</strong>。</li><li>接受方缓冲去区中，它一旦接到一个分片，会分析首部的信息，并且把对应的分片的数据放到主机D的接收缓冲区的对应位置中，把这个数据重新组合起来，然后加上原始的首部，恢复原始的IP数据报。这样D主机就可以接到分片重组后的数据。</li><li>从上面可以知道，每一个分片需要记录它的分片偏移量<ul><li><img src="/img/article_img/computer_network106.png" alt=""></li></ul></li><li>分片的重组<ol><li>位置：目的主机</li><li>依据：IP对数据报中的字段（标识、标志、分片偏移量）</li></ol></li><li>标识（identifier）：重组时，同一原始数据报的标识。当分片的时候，每一个分片的identifier都和原始IP数据报的标识字段相同</li><li>标志（flag）：<code>[][DF][MF]</code>，总共三个比特，第一个比特保留。MF比特为1时表示“还有分片，当前分片并不是最后一个分片”，MF=0表示本分片是最后一个分片。DF为1时表示“当前IP数据报不能进行分片”。</li><li>片偏移：某片在原分组数据中的相对位置。<code>注意：在IP数据报首部当中记录的时候是以8字节为单位进行记录的---真正记录在分片偏移量的值需要把真实值除以8才能获得---意味着每一个分片的长度为8字节的整数倍</code>。</li></ul></li></ol></li></ol></li></ol><h3 id="五、路由与寻址">五、路由与寻址</h3><ol><li><p>IP路由主要是要解决在网络中传输的<strong>最佳路径</strong>的问题。</p></li><li><p>IP路由</p><ul><li><img src="/img/article_img/computer_network107.png" alt=""></li></ul><ol><li>路由器转发数据的时候，以<strong>路由表</strong>为依据。（路由表类似带有距离的路标）</li><li>直接寻址（源与宿在相同的网络）：在物理网络内部确定主机—主机的数据传输路径。</li><li>间接寻址：源与宿不在相同网络</li><li>直接寻址和间接寻址的关系<ul><li>确定到达目的的网络的数据传输路径</li><li>在目的网络中用直接寻址方法到达信宿</li><li><img src="/img/article_img/computer_network108.png" alt=""></li></ul></li><li>如果需要进行间接寻址，就需要经过中转的路由设备的转发。很有必要的在中转的每一站中都要去设置它的下一站的转发地址—（下一站的转发地址：网关）。尤其是在主机的相关配置中，网关的概念需要明确。因为在给主机配置IP地址的时候，都要指定这个主机的网关的IP地址。</li><li>网关<ul><li><img src="/img/article_img/computer_network109.png" alt=""></li><li>直白点：指的是这个设备所在网络的默认出口地址</li></ul></li><li>一个IP数据报在一个网络中，经过中转路由器转发的时候的转发策略以及如何工作<ul><li><img src="/img/article_img/computer_network110.png" alt=""></li><li>比方说在当前的网络当中，H1要向H2发送数据。</li><li>作为H1这个主机，首先需要查找本机的路由表，把这个数据发给他所在的默认网关—就是它出口路由器R1的IP地址</li><li>接下来，R1路由器需要去查找本机的路由表。首先对第一行的掩码与目的IP地址进行与运算，发现结果与路由表对应的目的IP地址不匹配；然后进行第二行的同样运算，发现匹配。所以将数据从接口1（路由表右边）转发给H2这个主机。</li></ul></li><li>实际传输过程中，IP数据报经过路由表时，并不知道网络的整体状况，只能看到一个路由表，这是决策过程如下：<ul><li><img src="/img/article_img/computer_network111.png" alt=""></li><li>路由器会将目的IP地址同子网掩码从第一行开始，一行一行进行与运算，并与表格的目的网络列地址进行比对，找到相同的一行，然后将数据从对应的从下一站转发出去。</li><li>注意，最后一行是默认路由，在任何情况下都会匹配。即前面所有的信息都没匹配时，最后一个一定会匹配。</li></ul></li></ol></li><li><p>路由表的维护</p><ol><li><p>选择最佳路径</p><ol><li><p>静态路由</p><ol><li>由网络管理员来设置路由表</li><li>需要管理员经常手工维护</li><li>简单、有效，适用于结构简单的网络</li><li>不适合于拓扑结构和传输流量经常改变的复杂网络</li><li>最大的问题：当网络状态发生变化时，路由表的信息仍然保持不变，这时候会导致网络运行出现异常<ul><li><img src="/img/article_img/computer_network112.png" alt=""></li><li>上图中，三台路由器以环形方式连接三个网络。所构成的网络分别配置路由之后，网络是完全通畅的，即A，B，C之间可以相互传输数据。但是网络可能会出现故障，比如Ra和Rb这两台路由器所连接的网络出现了故障，网线断了。这时会导致这个网线所对应的两台路由器的两个路有消息出现失效。这时候对于Ra和Rb这两台路由器来说，它们并不知道实际上它们可以通过Rc来转发来完成数据的传输。这时候如果管理员不进一步的去手工维护路由表的话，那么对于网络A到网络B之间的所有数据传输都是无法进行的。只有当管理员进行手工维护后，修改对应路由信息，这个网络才能保证畅通。</li><li>当网络很复杂是，网络出现故障时，网络管理员进行手工维护是困难极大的。</li></ul></li></ol></li><li><p>通过算法实现动态路由</p><ol><li><p>距离向量算法—Distance-Vector</p><ol><li><p>基本概念</p><ul><li><img src="/img/article_img/computer_network113.png" alt=""></li></ul><ol><li>每个路由器都会周期性的向它相邻的路由器发送一个它到所有其他路由器的距离的向量</li><li>距离向量：方向和对应的路径的代价</li><li>每一台路由器接收到它相邻路由器发来的<strong>距离–向量</strong>的数据后，将会启动对应的算法，来更新路由表。</li></ol></li><li><p>更新路由表的原则</p><ol><li>发现新路由，则更新路由表</li><li>发现更短路由，则更新路由表</li><li>发现必经之路上的距离有变化，则更新路由表</li></ol></li></ol></li><li><p>Router Information Protocol（RIP协议）：</p><ul><li>使用D-V算法。这个所谓的距离在RIP协议中是以站点数即跳数HOP为度量的D-V算法。默认一个路由器就是1跳，并且在RIP协议HOP=16时为距离无穷大，目的不可达。即RIP协议所支持的网络它间隔最多15台路由器。刷新周期为30s----相邻路由器传输的路由表的间隔时间为周期性的30s。</li><li>1988年RFC1058正式定义</li><li>适用于小型网络的内部路由协议</li></ul><ol><li><p>跳数—HOP</p><ol><li>HOP数可以认为时路由器的个数</li><li>IP路由系统中使用HOP来计量站间距离，即间隔的HOP数越小，站间距离就越短</li><li>特殊情况下，可以定义1个路由器的HOP数大于1</li></ol></li><li><p>RIP协议的动态特性</p><ol><li><p>RIP协议建立路由表的初始过程</p><ul><li><img src="/img/article_img/computer_network114.png" alt=""></li><li>上图有A，B，C三台路由器，连接了四个网络。对于每台路由器来说，在刚刚启动时，都会在自己的路由表中记录下来本路由器所直接连接的网络信息。</li><li>初始化后，对应网络之间想要进行数据传输是不可能的，因为路由信息并不完整</li></ul></li><li><p>当三台路由器的初始化阶段结束后，接下来会启动RIP协议的距离向量算法来传递自己的路由表。</p><ul><li><p><img src="/img/article_img/computer_network115.png" alt=""></p></li><li><p>比如，A，B之间交换路由表，当A接到B路由器的路由表后，发现B路由表中它到10.3的这个网络的路由信息A是不知道的，遵循新路由则更新，所以A路由器需要把10.3.0.0这个路由信息添加到本机的路由表中。它接到B到10.3.0.0是0跳，那么A就需要先把数据发给B，然后再到目的的10.3.0.0.这时就需要增加1跳，后续则同理。</p></li><li><p>经过几个更新周期后，路由表稳定下来（受列）</p></li></ul></li></ol></li></ol></li><li><p>具体例子描述更新三原则</p><ul><li><img src="/img/article_img/computer_network116.png" alt=""></li><li>某一时刻，R路由器的路由表如左图所示，那么它的邻居R6向自己发送了一个路由表。</li><li>根据R6的路由表NET1的信息，可以发现不需要R的NET1 hops=0，所以不需要更新❌.</li><li>R6的NET4的hops=3，而R的NET4的hops=8，所以需要更新✔️.</li><li>R6的NET17的hops=6，而R的NET17的hops=5，不需要更新❌.</li><li>R6的NET21的hops=4，而R没有NET21的信息，所以需要更新✔️.</li><li>R6的NET24的hops=5，而R的NET24的hops=6，所以需要更新✔️.</li><li>R6的NET30的hops=10，而R没有NET21的hops=2，不需要更新❌.</li><li>R6的NET42的hops=3，而R的NET42的hops=2，不需要更新❌.</li></ul></li></ol></li></ol></li></ol></li></ol><h2 id="七、传输层">七、传输层</h2><h3 id="一、传输层的作用">一、传输层的作用</h3><ol><li><p>上述网络层的问题解决后，并不是万事大吉，还涉及两个问题：</p><ol><li>当前计算机安装的操作系统大多是多任务操作系统，也就是说同一台主机上允许同时运行多个具有网络通信功能的进程，那么通过网络层寻址到达目的主机的报文是如何被目的主机精准的交付给目的进程的呢？</li><li>网络层为用户提供了传输服务并不都是可靠的，由物理层知网络层提供的两种服务为可靠的蓄电路服务，另一种是不可靠的数据报服务。若网络层的协议采用了数据报服务，那么用户交给这个协议实体的数据是否就没有服务质量的保证了呢？</li></ol></li><li><p>传输层在网络体系结构中的重要位置</p><ul><li><img src="/img/article_img/computer_network117.png" alt=""></li><li>传输层位于应用层的下端，为上层的应用进程提供传输层的实体传输服务，同时被下一层的网络层调用它的功能来实现点到点之间的主机之间的通信。</li><li>传输层之间传输的协议数据单元称为TPDU，这里用message代替</li></ul></li><li><p>传输实体（Transport Entity）：在收/发两端的传输层实现对等实体通信的硬件或软件。</p><ul><li>利用网络层提供的点到点的分组传输服务</li><li>向高层提供端到端的TPDU（传输协议数据单元）传输服务（报文的可靠投递服务）</li></ul></li><li><p>为什么会出现网络层的数据丢失和乱序呢？网络层的下一层，也就是数据链路层不是已经保证数据真的可靠传输了嘛？而网络层的协议数据单元也就是分组时封装在数据帧当中传输的，而帧的传输的可靠性已经由数据链路层保证了，为什么还要考虑分组的丢失和乱序的情况呢？必须要先明确两个概念—点到点的传输、端到端的传输</p><ul><li><p><img src="/img/article_img/computer_network118.png" alt=""></p></li><li><p><img src="/img/article_img/computer_network119.png" alt=""></p></li><li><p>主机A要向主机B发送一个报文，从上图可以看出，可以选择的路径很多。比如R1到R2，或者R1，R3，R2；同时如果主机C要向主机A发送一个报文的话，它也可以选择多条路径。那么在这些路径里，假设主机A和主机B之间选择了R1到R2这条路径，那么很显然A要向B投递一个报文时需要有四段这样的路程。首先A要形成一个报文；然后A将报文从A传递到R1；再从R1传递到R2；再从R2投递到B。那么在这个过程中我们称A到B之间的通信是端到端的，而A到R1，R1到R2，R2到B的通信是点到点的通信。</p></li><li><p>我们知道链路层可以保证一定的通信的可靠性，那么链路层保证的是点对点的通信可靠性。而端到端的通信可靠性是由传输层来保证的。</p></li></ul></li><li><p>所以，传输层的存在使应用进程无需关心网络层的服务质量，而可以成功的将应用程序从源端进程可靠的投递到目的进程。那么传输层的协议应该如何设计才能实现不可靠的分组投递基础上完成可靠的报文传输的呢？又是如何实现进程寻址的呢？</p></li></ol><h3 id="二、面向连接的TCP协议">二、面向连接的TCP协议</h3><ol><li><p>传输层的TCP协议（Transmission Control Protocol），它为应用进程提供了可靠的端到端的面向连接的字节流通性，解决分组的重传和排序问题，由FC793正式定义。为Internet中许多著名的应用提供服务。</p></li><li><p>TCP协议的基本概念</p><ol><li>为应用进程提供可靠的、端到端的、面向连接的字节流通信的协议</li><li>它是利用网络层IP协议提供的不可靠的分组传输服务，在此基础上解决分组的重传和排序问题</li><li>为Internet的许多著名应用提供传输服务</li></ol></li><li><p>TCP连接的性质</p><ol><li>面向连接：就是在传输数据之前要明确知道接收方的存在，以及要与接收方商议传输的一些性质比如缓冲区的大小，发送序号的初始值等等。</li><li>全双工：在TCP连接建立好后，发送方和接收方是可以同时双方向进行数据传输的</li><li>Unicast：也叫单波通信协议，只支持两个端点间的一对一的通信，不支持多波（multicast）和广波（broadcast）的通信</li><li>面向字节流：TCP协议本身是面向字节流的流逝协议</li></ol></li><li><p>TCP协议的传输实体</p><ul><li><img src="/img/article_img/computer_network120.png" alt=""></li><li>可以是一个软件：也就是一个用户进程</li><li>也可以是操作系统中的某一部分，用来管理TCP字节流，实现与IP层的接口</li></ul></li><li><p>TCP的端口</p><ol><li><p>端口的定义</p><ol><li>端口是用来标识一个进程的，在一台主机当中，我们必须能够区分多个进程，而必须给进程进行编号，这个编号我们称之为端口（port）</li><li>在Internet的TCP协议当中用16bit区分$2^{16}$个端口</li></ol></li><li><p>端口的分配</p><ol><li><p>采用众所周知的端口：全局分配，用于标准服务器，取值小于1024</p><ol><li><p>优点：能简单知道与你通信的其他进程的端口号，这样比较有利于进行点到点的通信</p></li><li><p>缺点：没有在国际组织注册的进程不会获得端口号，这样新的进程的出现它的端口号的获得会变得非常复杂。</p></li></ol></li><li><p>临时分配端口：由本地的操作系统在启动进程时临时为这个进程分配一个端口（本地分配，主机建立连接时为用户进程动态分配端口号），等这个进程结束使用后会释放这个端口号，取值大于1024。</p><ol><li>优点：可以将端口号资源充分利用</li><li>缺点：当临时启动一个端口号时，与你通信的其他主机并不知道你的端口号是什么，所以你没有办法将你临时获得的端口号通知给对方</li></ol></li><li><p>解决方法：将临时端口号和众所周知的端口号进行搭配分配。对于标准服务器的服务进程，为它分配固定端口号；对于临时启动的客户进程，由操作系统为它临时分配端口号。当前的TCP/IP协议中，小于1024的端口号已经全部分配给标准服务器了。大于等于1024的端口号可以由操作系统动态的分给客户进程来使用。</p></li></ol></li><li><p>用套接口创建通信端点</p><ol><li>什么是套接口socket：有了端口号后，我们可以知道在internet当中访问唯一进程的方法就变成了两部分：第一部分就是要通过对方的ip地址访问到对方主机。第二部分是然后再根据端口号访问到对方主机的某个进程。这种分两步走的动态模式称为<strong>socket通信</strong>。socket通信是由Unix操作系统首先提出来的。</li><li>socket构成就是由端口号和主机ip地址动态绑定形成的。</li><li>socket通信当中，端口号是一个重要指标，用于进程寻址的。<ul><li><img src="/img/article_img/computer_network121.png" alt=""></li></ul></li><li>FTP应用连接端口举例说明进程间如何利用端口号实现进程寻址<ul><li><img src="/img/article_img/computer_network121.png" alt=""></li><li>假设这里有个FTP服务器，我们知道FTP服务器打开的服务端口是21号端口，也就是一个众所周知的端口。假设它的ip地址是18.22.67.7。客户端假设它的ip地址为128.8.6.4.194，那么它打开的端口应该是一个临时端口，也就是操作系统为它动态分配的一个端口。当客户端连接服务器端时，作为初始的连接请求，客户端连接请求会将21号端口作为自己的目的端口号，这样的话它就会将自己的源端口号也就是1234捎带给对方主机。也就是ftp服务器，这样ftp服务器就能够获得客户端的通信端口号了，从而与对方建立连接，实现1234端口与21号端口之间的连接的数据通信。</li></ul></li></ol></li><li><p>TCP协议的报文格式：tcp协议的报文格式分为两部分：</p><ol><li>TCP头部<ul><li>固定长度20字节（有些特殊的可以超过20字节（加上tcp头部的可选部分））</li></ul></li><li>数据：承载的是用户的数据报文<ul><li>适应IP的载荷能力（小于65535Byte）</li><li>适应网络的MTU</li></ul></li></ol></li><li><p>TCP的封装</p><ul><li><img src="/img/article_img/computer_network123.png" alt=""></li><li>TCP报文格式在这里应该说是它的数据部分承载了用户的数据，并且在应用数据的基础上增加了一个TCP的头部，我们称它为一个报文/报文段。整个tcp报文/报文段再向下调用网络层功能，封装成ip分组，分别加上ip的头部。再继续向下交给链路层，这就是tcp报文的封装过程。</li><li>那tcp头部包含那些字段，这些字段有什么作用呢？</li></ul></li><li><p>TCP首部</p><ul><li><img src="/img/article_img/computer_network124.png" alt=""></li></ul><ol><li>源端口号和目的端口号：是整个TCP报文段来自于哪一个应用进程，要到目的主机的哪一个进程去，由源端口号和目的端口号来标识出来，分别占用16个bit。</li><li>序列号和确认号：TCP的报文段是要被封装在IP分组当中投递的，而IP分组在投递的过程中是有可能乱序和丢失的，为了能够使乱序和丢失的报文重传重排TCP报文段，必须自己给自己编号才行。所以这个序列号就是TCP报文段自己给自己的编号；而确认号是接收端的TCP实体。用于向对方确认已经收到了哪一个序列号的报文，而希望收到的下一个报文段的编号。</li><li>偏移：偏移字段占用4个bit，这四个bit实际上是TCP报文的头部长度，单位是4字节。如果偏移字段是10，那么整个TCP报文段的长度是40字节。</li><li>保留：保留字段6bit，目前没有具体应用功能。</li><li>标志字段：标志字段字段也是6bit。<code>[URG][ACK][PSH][RST][SYN][FIN]</code><ul><li>URG----urgent：为1时，整个报文段头部中的<strong>紧急指针字段</strong>有效；为0，紧急指针字段无效。紧急指针字段是一个16bit的字段，里面存放的是数据部分需要被紧急处理的那一部分的最后一个字节的字节编号。</li><li>ACK----acknowledge：为1时，<strong>确认字段</strong>有效；为0，确认字段无效，即当前发送的TCP报文段只有序列号没有确认号。</li><li>PSH----push：指的是在整个TCP报文段中，接收方在接收了多个TCP报文段时会将TCP报文段进行缓冲，缓冲到一定长度后才会向上交给应用层去处理。当某一个TCP报文段需要被整段的紧急处理时，很显然它不希望被缓冲在接收方的缓冲区里，这时候它就将它的PSH比特设置为1，这是TCP接收方在接受到这个TCP报文段时就会不用等缓冲区满而将他上传给它的上一层应用程序来处理。</li><li>RST----reset：适用于当连接崩溃或出现错误连接时，用于连接复位的</li><li>SYN----synchronous：用于建立连接时使用。TCP协议是一个面向连接的协议，很显然，发送方在发送数据之前要与对方建立连接，这时候它就希望接收方要给它一些回应。首先它就给对方发送一个SYN=1的TCP报文，如果对方同意建立连接就向它返回一个SYN=1且ACK=1的TCP报文；如果对方不同意建立连接就返回一个SYN=1且ACK=0的TCP报文段；这样接收方就能区分发送方是否请求与它建立了连接，而发送方也可以区分接收方是否同意与它建立连接。</li><li>FIN----finally：适用于断开连接时使用。当发送方没有数据要向对方发送时，它就要请求与对方断开这个连接，这时候它就向对方发送一个FIN=1的TCP报文段，如果对方也同意断开连接就返回一个FIN=1的TCP报文段，不同意则返回一个FIN=0的TCP报文段。</li></ul></li><li>窗口：窗口字段是窗口的尺寸，占16bit，是接收端向发送端发送的用于控制发送端的发送的报文段的尺寸，防止接收端的缓冲区溢出。</li><li>校验和：校验和字段的用途类似于IP数据报的头部当中的校验和字段的用途。IP头部的校验和字段只校验头部，而TCP头部当中的校验和字段是对整个的TCP报文段的校验，运算原理相同。</li><li>到紧急指针字段一共20字节，这是TCP头部的固定长度，也就是说任何一个TCP报文段起码要包含这20个字节的头部，其他还有任选的部分。</li></ol></li><li><p>TCP的流量控制–滑动窗口</p><ul><li><img src="/img/article_img/computer_network125.png" alt=""></li></ul><ol><li><p>使用选择重传的ARQ</p></li><li><p>发送段可以连续发送多个TCP报文段，只要是在发送窗口中的都可以发送走。而接收端也有一个接收窗口，只有在接收窗口中的TCP报文段接收方才会接收成功，并且返回ACK给发送方，这样发送方就可以确认这一报文段已经被成功接收。那么已经被ACK过的报文段就可以出发送端口，使得发送端口继续向下滑动。</p></li><li><p>窗口字段如何实现流量控制的呢？</p><ul><li><img src="/img/article_img/computer_network126.png" alt=""></li><li><img src="/img/article_img/computer_network127.png" alt=""></li></ul><ol><li>发送端发送了一个Seq=1也就是发送序号等于1的TCP报文段，假设长度为100B。由于第一个报文段和第二个报文段都在发送窗口，显然可以不用等待应答而继续发送第二个报文段，假设发送序号是101，长度100B。<ul><li>序号为什么不是1，2，3…，？因为发送序号是字节编号，TCP是面向字节流的流逝协议，那么在每一个报文段中，它的发送序号都是这个报文段当中第一个字节的字节编号。第一个报文段的第一个字节是1的话，且长度为100B，显然这个报文段的序列号是1，下一个报文段的序列号是101。<strong>这个第一个序列号是0还是1看文档怎么给出它的定义的</strong>。</li></ul></li><li>第三个报文段Seq=201，100B。假设在传输时第三个报文段发生了丢失。显然接收方只能对前两个报文段进行确认，那么它发回的ACKno.=201，200B，也就是希望收到的下一个报文段的发送序号。</li><li>这里接收端就会向发送段发回一个窗口尺寸，这个窗口尺寸就是接收端的缓冲区当中还有的剩余空间的量。有了这个发送尺寸后，发送段可以连续发送TCP报文段但是长度不能超过这200个字节。这很显然就实现了对发送端流量的控制。</li></ol></li></ol></li></ol></li><li><p>TCP运行原理</p><ol><li><p>在TCP的运行中，还有两个问题必须考虑：一个是超时计时器的初值设定问题、第二是TCP如何利用滑动窗口原理来实现拥塞控制的</p></li><li><p>超时计时器的设定</p><ol><li><p>计时器设置的过短时，当计时器超时了，这时候可能正常的一个TCP报文段还没有传到接收端，而在发送端就已经超时了，这样会导致额外的重复发送。而超时计时器设置的过长时，就是会产生已经丢失了，但是由于计时器还没有超时这样还会多等待一些时间造成时间的浪费。</p></li><li><p>加权平均进行设定</p><ul><li>至于权数多大，不同系统有不同设定，具体情况具体分析。</li></ul><ol><li>$RTO=RTT_s + 4 \times RTT_D$.</li><li>$RTT_s = (1-a) \times RTT_{s_{old}} + a \times RTT_{new}$.</li><li>$RTT_D = (1-\beta) \times RTT_{D_{old}} + \beta \times |RTT_S - RTT_{new}|$.</li></ol></li></ol></li><li><p>TCP拥塞控制</p><ol><li>当TCP报文段发送过程中产生拥塞时，我们希望发送端减少发送或减缓发送，使得发送的压力不是那么大。</li><li>一般情况：在发送端设定一个拥塞窗口，拥塞窗口初值cwnd=发送窗口大小swnd。</li><li>在一个超时计时器时间内最多能发送的报文段的多少就由这个拥塞窗口来决定。</li><li>除此之外还要设定阈值，用于控制拥塞窗口的大小，拥塞窗口的大小应该小于等于这个阈值。$cwnd \le ssthresh$.</li><li>TCP报文段传输的是否顺利看：如果顺利，在规定的RTT时间里，发送段就会收到一个应答；如果在RTT时间内没有收到应答，我们可以判定线路上在传输TCP报文段时一定出现了问题，这时候认为是拥塞问题，这是拥塞窗口就要产生变化。cwnd是变化的，由小变大，初值为1.</li><li>cwnd变化规则：<ol><li>首先拥塞窗口的初值为1。</li><li>如果拥塞窗口小于所给的阈值时—$cwnd &lt; ssthresh$，若在每一个RTT时间内，都能接受到应答报文，说明这个报文段已经这却被接受了，cwnd加倍；若超时—没有在RTT时间内收到应答，说明出现了拥塞，启动拥塞避免算法。</li><li>若拥塞窗口大于所给的阈值时—$cwnd &gt; ssthresh$，若在每一个RTT时间内，都能接受到应答报文，则cwnd加1.否则，启动拥塞避免算法。</li><li>若$cwnd = ssthresh$，加倍加1都可以。</li></ol></li><li>拥塞避免算法（慢启动算法）<ol><li>只要没有在规定时间内收到ACK，ssthresh立刻减半，但不小于2.</li><li>并且将cwnd重新置为1.</li><li>执行上述cwnd变化（拥塞控制）算法。</li></ol></li></ol></li></ol></li><li><p>TCP的连接和释放</p><ol><li><p>为了保证TCP协议运行过程中双方为这次通信预留足够多的资源，TCP采用面向连接的方法—连接之前，有一方发起连接请求，在双方明确同意的情况下，才开始数据的通信；数据传输结束后亦然。</p></li><li><p>之所以讲解TCP的连接和释放的原理，因为TCP提供的是可靠的端到端传输服务，为了能够保证一次数据传输的可靠性，必须要明确知道通信双方为这次通信准备了什么资源，这就需要在真正的数据通讯之前，双方要与对方打好招呼，为这次通信预留资源，这个过程就叫做建立连接。</p></li><li><p>如何能在网络层提供不可靠的IP分组投递的基础上，能够使对方明确的知道自己的存在，并且能够明确的为这次通信分配预定的资源呢？</p><ol><li><p>典型例子----两军问题</p><ul><li><img src="/img/article_img/computer_network128.png" alt=""></li></ul><ol><li>假设有两伙蓝军分别位于两个山峰之上，而它们的敌人—一伙白军位于山谷之中。两伙蓝军分别向白军发起进攻时，它们都不能取胜。如果它们协同作战则可以战胜白军。</li><li>假设蓝军派出通信兵穿越白军的阵地，去到另一伙蓝军的阵地通风报信。那么如果这个通信是不可靠的，如何找出一种方法使得两伙蓝军能够同时发起进攻，确保这次战争的胜利？</li></ol></li><li><p>上述例子就是可靠的建立连接的TCP传输所要面临的问题—也就是说当服务器和客户机即TCP连接的两端想要知道对方的状态和发起这一次连接请求时，他们的目的是确保对方知道自己的存在，并且能够确保为这次通信预留它们所需要的传输资源。</p></li></ol></li><li><p><strong>三次握手建立TCP连接</strong></p><ul><li><img src="/img/article_img/computer_network129.png" alt=""></li></ul><ol><li><p>假设主机A是发起通信请求的客户端，那么它就会向服务器端也就是主机B发送一个请求建立连接的TCP报文，这个TCP报文的SYN=1。假设它的序号是SEQ=x。</p></li><li><p>这是主机B收到这个请求就要向主机A发送一个应答来表明它已经接收了这个请求。</p><ul><li><blockquote><p>当然主机A如果收到了这个应答，就应该知道主机B同意这次连接，可以开始双方通信了。但是前提就向两军问题一样，这个应答报文是有可能丢失的，所以主机B在发出应答报文时，并不知道这个报文是否能够到达主机A。也就是说主机B在发出应答时，并不确定主机A是否能够开始这一次通信，所以在主机B发出应答报文时，就为这次传输预留空间很显然是一件莽撞的决定。</p></blockquote></li></ul></li><li><p>所以为了能够保证主机B发给主机A的应答报文被主机A正确接收，所以主机A还要再向主机B发送一个对于应答报文的应答，这就是第三个报文。</p><ul><li><blockquote><p>这个过程称为三次握手。因为在连接过程中需要传输三个TCP报文段分别用于请求、应答、对于应答的应答才能够建立起一次TCP连接。如果这三个报文都正确接受了，这时才说TCP连接建立起来了，才可以开始下此真正的数据通信。</p></blockquote></li></ul></li></ol></li><li><p>释放连接</p><ol><li><p>释放TCP连接同样很重要：必须在数据传输结束后由发送方和接收方同时将用于这次通信的资源释放掉，这样这些资源才能被其他进程所继续使用。</p></li><li><p>非对称释放</p><ol><li>发送释放请求后单方终止连接</li><li>有可能丢失对方发送的数据</li></ol></li><li><p>对称释放</p><ol><li>各自独立发出释放连接请求</li><li>收到对方的释放确认后才可以释放连接</li><li>Two-army问题</li></ol></li><li><p><img src="/img/article_img/computer_network130.png" alt=""></p><ol><li><p>当结束了向主机B的数据发送时，显然A希望与主机B断开连接释放本地资源。这是主机A就向主机B发送一个FIN=1的TCP报文段，请求与主机B断开连接。</p></li><li><p>主机B如果同意与主机A断开连接，这时候主机B就发回一个应答报文。</p></li><li><p>主机A在收到这个应答报文后，为了告诉主机B它以经收到了这个应答报文，显然它还要对应答报文进行应答。</p><ul><li><blockquote><p>这是一种情况，考虑如果主机B不同意与主机A断开连接，这种情况也是经常发生的。主机A的发送缓冲区中已经没有数据了，而主机仍有数据要向主机A发送。因为TCP连接是一个全双工通信，所以前面描述的情况是有可能的。</p></blockquote></li></ul></li><li><p><img src="/img/article_img/computer_network131.png" alt=""></p><ol><li>主机A向主机B提出断开连接的请求，发送FIN=1的TCP报文段。</li><li>主机B尽管收到了这个报文段，并且给出了回答，但是主机B不同意断开连接，所以这个应答报文段的FIN=0。</li><li>在FIN=0的应答报文段发出后，主机B仍然可以向主机A发送TCP报文段。只有主机B的发送缓冲区也清空的情况下，也就是主机B要发送的所有报文段都已经发送完毕时，主机B才向主机A再发送一个FIN=1的TCP报文段进行再次的确认。</li><li>这时主机A才能确认主机B也没有数据向主机A发送了，也就是说主机B同意断开连接。这时，主机A再对这个FIN=1的应答报文进行再次确认，这是双方的连接才最终断开。</li></ol></li></ol></li></ol></li></ol></li></ol><h3 id="三、无连接的UDP协议">三、无连接的UDP协议</h3><ol><li><p>UDP协议提供的是无连接的数据报服务----对于UDP的用户来说，它交给UDP的数据，UDP协议将在没有与对方建立连接的情况下发送出去，并且也不提供序号服务和流量控制功能。</p></li><li><p>UDP协议概述</p><ol><li>为应用进程提供无连接的数据传输服务</li><li>使用于传输实时数据</li><li>主要特点：节省了建立和释放连接和重传的开销</li><li>由应用层解决纠错和丢失问题</li><li>由RFC768定义</li></ol></li><li><p>UDP的端点标识（Port）：在UDP中仍然完成了端口寻址问题</p><ol><li><p>用16bit区分$2<sup>{16}$个端口—区分$2</sup>{16}$个不同的应用进程</p></li><li><p>发送端</p><ul><li><p>分配的16bit端口是由操作系统随机分配的</p></li><li><p>分配源端口，指定宿端口，构造UDP数据报，交IP</p></li><li><p>节省建立和释放连接和重传的开销</p></li></ul></li><li><p>接收端</p><ul><li>而连接的另外一端也就是接收端，如果是服务器得话，服务器的端口仍然是固定端口</li><li>匹配UDP头部宿端口的应用进程</li><li>匹配成功，数据报排入相应的队列，若端口队列满，则丢弃数据报</li><li>匹配不成功，丢弃数据包，回送“宿端口不可达”的ICMP报文</li></ul></li><li><p>UDP保留端口举例</p><ul><li><img src="/img/article_img/computer_network132.png" alt=""></li></ul></li></ol></li><li><p>由于没有建立连接、序号确认、流量控制等功能，UDP报文格式简化很多，运行起来也简单很多。</p></li><li><p>UDP数据报的封装</p><ul><li><img src="/img/article_img/computer_network133.png" alt=""></li></ul></li><li><p>UDP首部</p><ul><li><img src="/img/article_img/computer_network134.png" alt=""></li></ul><ol><li>源端口号：16bit，用于标识源进程</li><li>目的端口号：16bit，用于标识UDP报文段的目的进程</li><li>UDP报文长度：16bit（最小为8）</li><li>UDP校验和：16bit，校验和运算方法同IP分组头部以及TCP头部中的校验和运算方法相同。<strong>注意</strong>：由于UDP是一种乐观的协议，当UDP校验和全0时，表示不适用校验和校验。全1表示校验和0.</li></ol></li><li><p>UDP伪首部</p><ul><li><img src="/img/article_img/computer_network135.png" alt=""></li></ul><ol><li>伪头部12字节，伪头部只参与校验和的运算，不被真正的发送出去。因为接收端也可以从接收端的头部组成一个伪首部。这是因为UDP头部过短所造成的校验和容易产生差错的情况而故意增加的用于运算的一个伪首部。</li><li>4字节源IP地址，4字节宿IP地址，8bit0，8bit协议字段值固定17，16bitUDP长度。</li></ol></li><li><p>UDP传输某种报文的过程-----传输RIP报文</p><ul><li><img src="/img/article_img/computer_network136.png" alt=""></li></ul><ol><li><p>路由请求</p><ul><li><img src="/img/article_img/computer_network137.png" alt=""></li></ul></li><li><p>RIP：请求路由信息</p><ul><li><img src="/img/article_img/computer_network138.png" alt=""></li><li>假设RIP报文的数据格式如上图，即24字节的RIP协议报文。里面是一个请求，是发给邻居路由器请求邻居路由器将自己的路由信息填在这个报文当中的空白位置的一个RIP请求路由信息。</li></ul><ol><li><p>UDP分配端口：</p><ul><li><img src="/img/article_img/computer_network139.png" alt=""></li><li>首先将这24个字节作为UDP的数据部分，加上UDP的8字节头部。由于RIP协议固定的目的端口号是520，源端口号也是520，所以源端口和目的端口被填上了520。数据部分24字节加上头部8字节，所以长度32字节。校验和就是按照Check sum的方法计算的校验和。</li></ul></li><li><p>IP：赋予IP地址</p><ul><li><p><img src="/img/article_img/computer_network140.png" alt=""></p></li><li><p>上述的UDP报文向下交给IP协议，再由IP协议封装成IP报文，那么这个IP报文的数据部分就是刚才封装好的UDP的32字节的数据报。而IP的头部是固定的20字节的头部，相应的值也填进去。</p></li></ul></li><li><p>Ethernet：赋予以太网地址</p><ul><li><img src="/img/article_img/computer_network141.png" alt=""></li><li>再将IP报文封装在物理网络数据帧中，以太网帧的数据部分就是上述封装好了的IP分组。IP头部20字节，IP数据部分是UDP报文32字节，所以总体长度52字节。还有就是数据链路层的数据帧的头部当中的各个字节把它填充好。由于这个RIP协议需要广播发送，所以目的地址填全1。这样一个以太网的数据帧可以在以太网中进行传输了。任何接受到这个数据帧的主机由于目的地址是全1，就会将它接受到自己的缓冲区当中，然后逐层解析，最终拿到RIP报文。</li></ul></li></ol></li></ol></li></ol><h2 id="八、应用层">八、应用层</h2><h3 id="一、电子邮件Email">一、电子邮件Email</h3><ol><li><p>Internet Email的工作模型</p><ul><li><img src="/img/article_img/computer_network142.png" alt=""></li><li>首先Email的服务提供者一定要向用户提供一个用户接口。假设用户现在要发送一封邮件，它要先在用户接口中输入必要的信息，然后将发送的邮件放在发出邮件缓冲区，由客户机进行后台发送。这时客户机要做的工作就是立即与原邮件服务器建立TCP连接，再由原邮件服务器与对方的接收邮件的服务器建立TCP连接，最终将这个邮件传送给目的端的邮件服务器，这是发送一封邮件的过程。</li><li>在接收一封邮件时，我们要在自己的邮件服务器当中提供用户名和密码，也是通过用户接口的方式。然后到自己的邮箱当中按照一定的规则取出自己想要的邮件，这是一封邮件在传输过程中的工作模型。</li><li>上述存在的问题：传输过程中各个协议如何协调工作的、email格式是什么样子的</li></ul></li><li><p>Email格式</p><ol><li><p>Internet Email的格式在RFC822中定义，由两部分组成：header、body</p></li><li><p>header：</p><ul><li><img src="/img/article_img/computer_network143.png" alt=""></li><li><img src="/img/article_img/computer_network144.png" alt=""></li></ul></li><li><p>Body：内容是任意的，但必须是7位标准ASCII字符集。</p></li><li><p>扩展Email的格式：扩展Email称为MIME（Multipurpose Internet Mail Extensions），最初在RFC1314中定义的，修订版发布在RFC1521中。主要是Email中存在诸多不足和限制而提出的。</p></li><li><p>RFC822Email的缺点</p><ol><li><p>不能传送可执行文件或其他二进制对象。</p><blockquote><p>人们试图将二进制文件转换成SMTP使用的ASCII文本，例如流行的UNIX UUencode/UUdecode 方案，但这些均未形成“正式标准或事实上的标准”。</p></blockquote></li><li><p>限于传送7位的ASCII字符。</p><blockquote><p>许多非英语国家的文字（如中文、俄文、甚至带重音符号的法文或德文）就无法传送。即使在SMTP转换成ASCII码时也会遇到一些麻烦。</p></blockquote></li><li><p>服务器会拒绝超过一定长度的邮件。</p><blockquote><p>RFC822对于超长的邮件是拒绝发送的，所以MIME中对这个问题也进行了修复。</p></blockquote></li><li><p>某些实现并没有完全按照的标准。</p><blockquote><p>常见问题如下：</p><ul><li>回车、换行的删除和增加</li><li>超过76个字符时的处理：截断或自动换行</li><li>后面多余空格的删除</li><li>将制表符转换为多个空格</li></ul></blockquote></li></ol></li><li><p>MIME的处理方法：MIME利用了RFC822的格式，但又加入了一个扩展的头部（实际上位于RFC822的header中）。主要是为了克服RFC822只能传输标准7位ASCII文本的缺点，使Email既可以传输标准ASCII码文本，也可以传输像图片、声音、各种语言文本等。</p></li></ol></li><li><p>邮件的传送是一种客户服务器的交互模式，为了保证邮件传输的可靠性，邮件传输协议都是基于TCP协议的。</p><ul><li><img src="/img/article_img/computer_network145.png" alt=""></li><li><img src="/img/article_img/computer_network146.png" alt=""></li></ul><ol><li>上图中分为三个阶段，前两个阶段有一个共同点—接收方都是服务器，这就使得在传输邮件时，可以以比较简单的方式去链接服务器上WLAN的端口来传输一封Email。这种传输邮件的协议称为SMTP协议（Simple Mail Transfer Protocol，Defined in RFC 821）。</li><li>SMTP协议的服务器是在本机的25号端口上进行监听，当有连接请求进来时，接受链接，然后传输邮件，传输完毕后再将连接断开。</li><li>SMTP是一个纯ASCII字符的协议，所有命令和数据均以标准ASCII字符传输。</li></ol></li><li><p>邮件传输例子</p><ul><li><img src="/img/article_img/computer_network147.png" alt=""></li><li>假设某个用户—mail.neu.edu.cn这个邮件服务器的用户，现在他想发送一封邮件给xyz@126.net这样的用户。首先用户在自己的客户机上打开一个进程，这个进程是由操作系统随机分配的进程号。那么与本地的服务器的25号端口建立连接，将这样的Email按照上文822数据格式组织好发送给本地的Email服务器的25号端口。本地的Email服务器在收到这个Email后就会再随机打开本地的一个端口号，假设是5000，然后去链接目的邮件服务器，也就是126.net的25号端口，将这样的邮件发送给126.net的25号端口，然后这个邮件服务器收到了这个邮件之后就会保存在本地的邮箱当中，等待接收端即xyz这个用户来取邮件。</li></ul></li><li><p>取邮件</p><ul><li><p><img src="/img/article_img/computer_network148.png" alt=""></p></li><li><p>大多数用户是在个人计算机上来收邮件的，而个人计算机不能长时间连网，即使连接在网上也不一定有固定的域名或ip地址，因此不能作为smtp服务器。这一点是个人计算机和服务器的本质区别。因此如果需要在Internet上面来接收邮件，那么用户就一定要将自己的PC机主动的与Email服务器建立连接，提供自己的用户名、密码、以及接收邮件的请求，这时候才能接收邮件，显然这个接收邮件的协议与SMTP协议不同。这个协议就是POP3（第三个版本）协议----邮局协议。</p></li><li><p><img src="/img/article_img/computer_network149.png" alt=""></p></li><li><p><img src="/img/article_img/computer_network150.png" alt=""></p></li></ul><ol><li>POP3工作过程：POP服务器监听110号端口，等待用户连接请求。用户发出链接请求后，POP3服务器接受请求并与之建立TCP连接。客户端在建立连接后就要提供用户名、密码、以及它需要取出的邮件的序号等等。POP3服务器更具用户民、密码确定邮箱入口地址，同时将用户要求的邮件返回给用户。</li></ol></li><li><p>总结：发信人的用户代理向源邮件服务器发送邮件，源邮件服务器向目的邮件服务器发送邮件使用的都是SMTP协议；POP3等协议只是从目的邮件服务器上读取邮件。</p></li></ol><h3 id="二、文件传输协议FTP">二、文件传输协议FTP</h3><ol><li>File Transfer Protocol，一种文件传输协议，支持异构的计算机进行文件传输，支持ASCII文件和纯二进制文件的传输，是在RFC的959中定义的。</li><li>例子：QQ这种即时通讯软件中，常用离线文件传输的功能。你的朋友同你分隔两地并且需要向你发送一个600M的文件，如何实现？</li><li>FTP协议的宗旨是允许我们在Internet的范围内上传和下载文件，这就需要有一个文件服务器，它有一个大大的存储空间，并且打开固定端口，等待用户的上传和下载的需求，同时FTP服务还应该包含一些用户名的验证，这样才能防止非法上传和下载。</li><li>FTP的工作模式<ul><li><img src="/img/article_img/computer_network151.png" alt=""></li><li>客户端首先要有一个用户接口，在用户接口用户提出上传某个文件或是下载某个文件的需求，然后由用户的协议的解析器来解析这些命令是上传还是下载，文件的位置具体在哪，这是文件的解析器就能够理解用户的需求了。然后按照用户的需求与文件服务器建立连接，而文件服务器这时一定要打开的是21号端口等待用户的连接请求。同时FTP协议还有另外一个固定端口就是20号端口。21号端口用于命令传输，20号端口用于数据的传输。在20号端口即server端，接受了用户的请求和命令后，就将命令进行解析，然后来到本地的文件系统找到用户要上传或者下载的文件的位置，然后将文件交到20号端口，再由20号端口与对方建立连接，将数据下载给客户端。客户端收到下载数据后，再将它存放在本地的文件系统中。这就完成了一次数据的下载，数据上传基本一样。</li></ul></li></ol><h3 id="三、WWW应用">三、WWW应用</h3><ol><li><p>WWW起源</p><ul><li><img src="/img/article_img/computer_network152.png" alt=""></li></ul></li><li><p>WWW系统必须解决的问题</p><ul><li><img src="/img/article_img/computer_network153.png" alt=""></li></ul></li><li><p>WWW的工作模式</p><ul><li><img src="/img/article_img/computer_network154.png" alt=""></li></ul><ol><li>WWW的工作模型中，首先要有一个WWW的服务器，它是等待用户的连接请求的。用户想要访问一个WWW服务器，那么就要连接它的80端口与他建立TCP连接，然后将自己要访问的WWW文档的地址发给这个服务器，这个服务器再到自己的WWW文档库中找到相应的文档返回给客户端，在这个过程中就要解决刚才的3个问题。</li></ol></li><li><p>如何标识一个WWW文档：标识的方法就是----URL（Uniform Resource Locator—统一资源定位符）的缩写，用来解决上述第一个问题。</p><ul><li><p>URL是能对从Internet上得到的资源的位置和访问方法的一种简洁的表示。</p></li><li><p><img src="/img/article_img/computer_network155.png" alt=""></p></li><li><p>格式：<code>&lt;访问方式&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</code>。</p></li><li><p>访问WWW服务器是http的方式，由于统一资源定位符还允许我们采用其他方法访问其他类型的主机的其他端口，所以实际上的访问方法很多。</p></li></ul><ol><li>URL访问方式<ul><li><img src="/img/article_img/computer_network156.png" alt=""></li><li>访问www服务器时并没有给出端口号，这是因为访问所使用的用户接口将这个端口号进行了默认设置，默认80。但如果一个www服务器它使用的不是80端口等待用户等的请求，有些是8080或是3128，这时候我们就一定要在浏览器中用冒号8080或冒号3128的形式指明端口号</li></ul></li></ol></li><li><p>如何标识一个www文档使得再异构计算机上通过浏览器或是翻译器使它能展现相同的风格：方法是采用HTML语言—超文本的标记语言</p><ul><li><img src="/img/article_img/computer_network157.png" alt=""></li></ul><ol><li>HTML Tags<ul><li><img src="/img/article_img/computer_network158.png" alt=""></li></ul></li></ol></li><li><p>客户和服务器之间传输www文档使用的协议：http超文本传输协议</p><ul><li><img src="/img/article_img/computer_network159.png" alt=""></li><li>基于Client &amp; Server模式的交互协议，也是一个纯文本协议。是由客户端发送请求，Server端相应这个请求按照客户的要求在将相应的www文档返回给客户的这样一种协议，基于TCP连接的。</li></ul></li></ol><h3 id="四、DNS应用">四、DNS应用</h3><ol><li>Internet上每台主机的唯一标识是它的IP地址，当要访问某台主机时，必须要知道它的IP地址才行。实际上，我们更多的是通过主机的名字而不是地址来访问的，这是因为在Internet当中提供了一种可以将主机的名字和IP地址互相转换的应用层协议，这就是DNS协议。</li><li>DNS概述<ol><li>DNS应用也叫域名字系统的应用，主要任务是将一个域名翻译成对应的IP地址。<ul><li>如何实现这种翻译呢？简单想法是：设计一个大大的数据库，里面存放所有的域名和IP地址的对应关系。如果某个客户想要知道这一个对应关系，那么就发来传输请求来进行查询。这种方式在Internet中不可行，原因是：第一—没办法保证数据库的完整性，数据库的更新非常频繁；第二—这个数据库要接受来自全Internet的访问要求，这是非常大的负担。</li></ul></li><li>Internet的域名系统：DNS被设计成为一个联机分布数据库系统、DNS采用客户服务器模式、DNS由若干台域名服务器组成（1.太多域名的转换都是在本地映射；2.少数域名在Internet网上通信映射）。</li></ol></li><li>Internet域名结构：采用层次树状结构的名命方法<ol><li>说明：<ol><li>域名的结构由若干个分量组成，各分量之间用点隔开；如<code>.qcxy.hb.cn</code>：最右边的是顶级域名，从右往左域名等级依次下降。</li><li>每一级的域名都由英文字母和数据组成（&lt;63个，不分大小写）</li><li>级别最低的域名在最左边，最高的在最右边。（整个域名长度&lt;255）</li></ol></li><li><img src="/img/article_img/computer_network160.png" alt=""><ul><li>域名只是逻辑概念，并不反映出计算机所在的物理地点/网络信息。</li></ul></li><li>顶级域名由Internet的有关机构ICANN管理决定。</li><li>目前顶级域名分为3类：<ol><li>国家顶级域名：采用ISO3166规定。cn：中国、us：美国、uk：英国、jp：日本、sg：新加披</li><li>国际顶级域名：采用int国际性组织可在int下注册</li><li>通用顶级域名：根据[RFC1591]规定（最早6个+新增7个=13个）<ul><li><img src="/img/article_img/computer_network161.png" alt=""></li></ul></li></ol></li><li>二级域名由国家自行确定<ul><li><img src="/img/article_img/computer_network162.png" alt=""></li></ul></li><li>三级域名的申请注册<ol><li>我国三级域名的管理和申请（除edu网外），应向中国互联网信息中心CNNIC申请。</li><li>域名有相对域名和绝对域名之分<ol><li>相对域名：至某一级的域名的下属域名，如：nju是edu下属的一个相对域名。</li><li>绝对域名：是一个完整的域名，一直写出根域名（又称：完全合格的域名.FQDN）如：<a href="http://nju.edu.cn">nju.edu.cn</a></li></ol></li></ol></li></ol></li><li>DNS查询流程<ul><li><img src="/img/article_img/computer_network163.png" alt=""></li><li><img src="/img/article_img/computer_network164.png" alt=""></li><li>xyz、abc都是小范围的DNS服务器—本地域名服务器，在其之上有顶级/二级域名服务器（com）。</li><li>在主机M上，它作为DNS服务的一个客户，想向本地的域名服务器询问<code>w.x.abc.com</code>的IP地址是什么，本地的域名服务器也就是<code>xyz.com</code>这个域当中的域名服务器也许只保存了本地的域名与IP地址之间的关系，那么这时它并不知道<code>abc.com</code>这个域名下的其他主机的IP地址。这时候他就必须将这个请求回溯到比它更高一级的顶级域名服务器去。<code>.com</code>这个顶级域名服务器当中是否一定保存了<code>abc.com</code>和<code>xyz.com</code>下的所有主机域名和IP的对应关系的呢？显然这时不一定的。这时候<code>.com</code>的顶级域名服务器并不知道<code>w.x.abc.com</code>的域名所对应的IP地址。但它却知道<code>abc.com</code>的域名服务器的地址，所以这时候顶级域名服务器就会将<code>abc.com</code>的域名服务器IP地址发送给本地DNS服务器。这时本地的DNS服务器就可以根据从顶级域名服务器上获得的<code>abc.com</code>的服务器的地址去向<code>abc.com</code>的服务器查询<code>w.x.abc.com</code>的IP地址，结果一定可以查询到，因为<code>abc.com</code>的服务器当中就应该包含有它所在域的所有主机的域名域IP的对应关系。那么<code>abc.com</code>的域名服务器当中一定存有<code>w.x.abc.com</code>的域名和IP地址的对应关系。并且将IP地址返回给本地的DNS服务器。本地的DNS服务器将这个对应关系缓存后将结果返回给主机M。这样就完成了一次DNS域名到IP的查询。<strong>同时DNS也提供了IP到域名字转换</strong>。个人主机在使用DNS服务时，就要在本机配置一个默认的DNS服务器。有时这个服务器的IP地址是由手工配置的，也有自动获取的，有时是由ISP来提供的。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>cs</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>预测：方法与实践</title>
    <link href="/2021/01/30/%E9%A2%84%E6%B5%8B%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2021/01/30/%E9%A2%84%E6%B5%8B%EF%BC%9A%E6%96%B9%E6%B3%95%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1>预测：方法与实践</h1><p><a href="https://otexts.com/fppcn/">电子书</a></p><h2 id="一、入门">一、入门</h2><h3 id="1-主要内容和概念">1.主要内容和概念</h3><ol><li>事件（或数量）的可预测性取决于以下几个因素：<ol><li>我们对它的影响因素的了解程度;</li><li>有多少数据是可用的;</li><li>预测是否会影响我们试图预测的事物。</li></ol></li><li><strong>预测</strong>：它是指在考虑到所有可用信息的前提下，包括历史数据和可以影响预测的任何未来事件的知识，尽可能准确地预言。</li><li><strong>目标</strong>：它是指你想要发生的事情。目标理应与预测和计划联系在一起，但是这并不经常发生。很多时候，设定目标时没有任何如何去实现这些目标的计划，也没有目标是否切合实际的预测。</li><li><strong>计划</strong>：它是对预测和目标的回应。计划包括制定使得你的预测符合你的目标的适当行动。</li><li><strong>短期预测</strong>：人员、生产和运输的安排调度需要短期预测。作为安排过程中的一部分，需求预测常常也是必须的。</li><li><strong>中期预测</strong>：确定未来的资源需求需要中期预测，以便购买原材料、雇用人员或购买机器和设备。</li><li><strong>长期预测</strong>：在战略规划中会使用长期预测。此类决定必须将市场机会、环境因素和内部资源纳入考量。</li><li>在满足以下两个条件的时候可以使用<em>定量预测</em> ：<ol><li>关于过去的数字化信息是可以用的；</li><li>有理由假设过去的一些模式会在未来延续下去。</li></ol></li><li>预测过程的主要步骤**：**<ol><li>步骤1：定义问题。</li><li>步骤2：收集信息**：一般至少需要两种信息收集方式：(a) 统计数据，(b) 收集数据和进行预测方面专家的积累经验。**</li><li>步骤3：初步（探索性）分析**：总是以图形开头。有一致的模式吗？有明显的长期趋势吗？季节性重要吗？是否有证据表明商业周期存在？数据中是否包含需要专业知识解释的异常值？用于分析的变量之间的相关性有多强？**</li><li>步骤4：**选择及拟合模型。</li><li>步骤5：<strong>使用及评估预测模型。</strong></li></ol></li><li>统计预测的观点：<ol><li>我们试图预测的东西是未知的，此时可以看成一个随机变量</li><li>当某个数据是已知的时候，我们把它看成一个样本</li></ol></li></ol><h3 id="2-练习">2.练习</h3><ol><li><p>假设相关数据可以得到，列出<a href="https://otexts.com/fppcn/case-studies.html#case-studies">1.5</a>节案例3和案例4中可能有用的预测变量。</p><p>答：</p><ol><li>对于案例3：汽车类型、汽车品牌、汽车采购价格、汽车转售价格、汽车转售数量、对应的转售政策</li><li>对于案例4：乘客类型、学校假期时间、重大体育赛事时间、广告活动时间、竞争行为</li></ol></li><li><p>描述<a href="https://otexts.com/fppcn/case-studies.html#case-studies">1.5</a>节案例3中项目预测的五个步骤。</p><p>答：</p><ol><li>定义问题</li><li>收集信息</li><li>初步（探索性）分析</li><li>选择及拟合模型</li><li>使用及评估预测模型</li></ol></li></ol><h2 id="二、时间序列图形">二、时间序列图形</h2><h3 id="1-主要内容">1.主要内容</h3><ol><li>对于任何数据分析工作而言，其首要任务是数据可视化。图示化数据可以清晰地展现数据的特征，包括数据的形态、异常值、随时间变化情况以及变量间的相互关系。</li><li>时间序列是一组按照时间发生先后顺序进行排列，并且包含一些信息的数据点序列。</li><li>上述这些信息被存储在<code>ts</code>对象中</li><li>时间序列的频率：“频率”是季节模式重复之前的观测值个数。</li><li><strong>时间图</strong>：对于时间序列数据而言，我们从最简单的时间图开始。时间图是用将观测值与观测时间点作图，散点之间用直线连接。</li><li>时间序列模式：我们通常使用例如“趋势”、“季节性”等词语描述时间序列。在深入研究时间序列模式时，应该更精确的定义这些词语。<ol><li><strong>趋势</strong>：当一个时间序列数据长期增长或者长期下降时，表示该序列有 <em>趋势</em> 。在某些场合，趋势代表着“转换方向”。</li><li><strong>季节性</strong>：当时间序列中的数据受到季节性因素（例如一年的时间或者一周的时间）的影响时，表示该序列具有 <em>季节性</em> 。季节性总是一个已知并且固定的频率。</li><li><strong>周期性</strong>：当时间序列数据存在不固定频率的上升和下降时，表示该序列有 <em>周期性</em> 。这些波动经常由经济活动引起，并且与“商业周期”有关。周期波动通常至少持续两年。</li><li>当数据的波动是无规律时，表示序列存在周期性；如果波动的频率不变并且与固定长度的时间段有关，表示序列存在季节性。一般而言，周期的长度较长，并且周期的波动幅度也更大。</li></ol></li><li><strong>季节图</strong>：季节图和时间序列图很相似，不同之处是季节图是针对观察数据的“季节性”绘制的。</li><li><strong>子系列季节图</strong>：子系列季节图可以清晰的描绘出数据的潜在季节性形态，并且显示了季节性随时间的变化情况。这类图可以很好地查看各时期内数据的变化情况。是观察季节性变化最有用的方式。</li><li><strong>散点图</strong>：<img src="img%5Carticle_img%5Cprecast1.png" alt=""></li><li><strong>相关性</strong>：我们经常会用 <em>相关系数</em> 衡量两个两个变量之间的相关强度。假如已知两个变量$x$和$y$，那么它们之间的相关系数为$r = \frac{\sum (x_t-\overline{x})(y_t-\overline{y})}{\sqrt{\sum{(x_t-\overline{x})^2}} \sqrt{\sum(y_t-\overline{y})^2}}$,$r$的值始终在-1到1之间。当两个变量完全负相关时，$r$值为-1；当两个变量完全正相关时，$r$为1。<ul><li>需要注意的是，相关系数仅仅衡量了变量之间的线性关系，并且有时会导致错误的结果。</li><li>在分析变量之间关系时，不仅要看相关系数值，而且要关注生成的图形。</li></ul></li><li><strong>散点图矩阵</strong>：<ul><li>当所分析的数据有多个变量时，将每个变量与其他变量进行比较也很有意义。</li><li>对于图中的每一块区域，其行变量是垂直轴行的变量，列变量是水平轴的变量。有许多设置可以控制生成的图形的形态。在默认设置中，相关系数在图的右上方显示，散点图在左下方显示，对角线上是密度曲线。</li><li>可以通过散点图矩阵快速查看所有变量之间的相关关系。</li></ul></li><li><strong>滞后图</strong></li><li>自相关：正如相关系数可以衡量两个变量之间的线性相关关系一样，自相关系数可以测量时间序列 <strong>滞后值</strong> 之间的线性关系。<ul><li>$r_k$定义如下:$r_k = \frac{\sum_{t=k+1}<sup>{T}(y_t-\overline{y})(y_{t-k}-\overline{y})}{\sum_{t=1}</sup>{T}(y_t-\overline{y})^2}$</li><li>通过绘制自相关系数图可以描绘 <em>自相关函数</em> 或者是ACF。因此也被称为相关图。</li></ul></li><li><strong>ACF 图中的趋势性和季节性</strong>:<ul><li>当数据具有趋势性时，短期滞后的自相关值较大，因为观测点附近的值波动不会很大。时间序列的ACF一般是正值，随着滞后阶数的增加而缓慢下降。</li><li>当数据具有季节性时，自相关值在滞后阶数与季节周期相同时（或者在季节周期的倍数）较大。</li><li>当数据同时具有趋势和季节性时，我们会观察到组合效应。</li></ul></li><li><strong>白噪声</strong>：“白噪声”是一个对所有时间其自相关系数为零的随机过程。<ul><li>对于白噪声而言，我们期望它的自相关值接近0。但是由于随机扰动的存在，自相关值并不会精确地等于0。对于一个长度为TT的白噪声序列而言，我们期望在0.95的置信度下，它的自相关值处于±2/√T±2/T之间。我们可以很容易的画出ACF的边界值。如果一个序列中有较多的自相关值处于边界之外，那么该序列很可能不是白噪声序列。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>数学建模</category>
      
    </categories>
    
    
    <tags>
      
      <tag>预测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Matlab入门</title>
    <link href="/2021/01/18/Matlab%E5%85%A5%E9%97%A8/"/>
    <url>/2021/01/18/Matlab%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1>Matlab入门</h1><ol><li><p><code>向上的箭头</code>：表示回到上一个变量</p></li><li><p><code>save file</code>：将当前内容保存到<code>file.mat</code>文件内</p></li><li><p><code>load file</code>：加载<code>file.mat</code>的内容</p></li><li><p>当您关闭 MATLAB 时，工作区将被清空。可以使用 MAT 文件来保存变量。这样，当您重新打开 MATLAB 时，可以将变量加载到工作区中。</p><p>如果您只想加载或保存<em>部分</em>变量，可以使用函数的两个输入。尝试从文件 <code>myData.mat</code> 中仅加载变量 <code>m</code>：<code>&gt;&gt; load myData m</code></p><p>然后尝试将变量 <code>m</code> 保存到名为 <code>justm.mat</code> 的新 MAT 文件中：<code>&gt;&gt; save justm m</code></p></li><li><p>命令行窗口通常只显示4位小数，可以使用<code>format long</code>函数控制显示的精度</p><p><code>&gt;&gt; format long</code></p><p><code>&gt;&gt; x = pi/2</code></p><p><code>x = 1.570796326794897</code></p><p>使用<code>format short</code>可以切换回默认显示</p></li><li><p>有一些解包含虚数<code>i</code>,这是MATLAB中的内置常量</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Matlab</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内存</title>
    <link href="/2021/01/07/%E5%86%85%E5%AD%98/"/>
    <url>/2021/01/07/%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1>内存</h1><h3 id="一、-Review：Memory">一、 Review：Memory</h3><ol><li>存储器由一定数量的单元构成，每个单元可以被唯一标识，每个单元都有存储一个数值的能力<ul><li>地址：单元的唯一标识符（采用二进制）</li><li>地址空间：可唯一标识的单元总数</li><li>寻址能力：存储在每个单元中的信息的位数<ul><li>大多数存储器是字节寻址的，而执行科学计算的计算机通常是64位寻址的</li></ul></li></ul></li><li>寻址能力的影响因素：主要由设计时地址的位数决定<ul><li>地址总线的根数</li><li>寻址机制的不同</li></ul></li><li>计算机内存真正能使用的内存大小的影响因素：<ol><li>地址空间</li><li>寻址能力</li></ol></li><li><strong>注意</strong>：4G内存的电脑插入8G的内存条并不会变化，因为寻址能力并不会变强，也就是说插入8G的内存条后，受到了寻址能力的制约。</li><li>地址空间越大，内存的容量就会越大嘛？<ul><li>不一定，因为每个单元的存储大小可能会发生改变</li></ul></li></ol><p><img src="/img/article_img/InternalMemory1.png" alt=""></p><h3 id="二、Semiconductor-Main-Memory">二、Semiconductor Main Memory</h3><ol><li>几乎所有的主存储器都采用半导体芯片</li><li>Memory cell（存储器位元）：半导体存储器最基本的元件</li><li>半导体元件所具有的一些性质：<ul><li>呈现出2种稳定的状态，分别表示0和1</li><li>能够至少写入一次信息来改变状态</li><li>能够读取出信息</li></ul></li></ol><p><img src="/img/article_img/InternalMemory2.png" alt=""></p><p><img src="/img/article_img/InternalMemory3.png" alt=""></p><h3 id="三、READ-WRITE-MEMORY">三、READ-WRITE-MEMORY</h3><h4 id="1-RAM">1. RAM</h4><ol><li>Random Access Memory（随机访问存储器）：通过编排的寻址逻辑，存储器的单个字直接被存取</li><li>明显特征是：<ul><li>可以便捷的从存储器中读取数据和向存储器中写入新数据，且读出操作都是通过使用电信号来完成的</li><li><strong>volatile（易失性）：一旦断电，数据就会丢失</strong></li></ul></li><li>类型：<ul><li>DRAM：Dynamic RAM（动态指的是由一种存储电荷被丢失的趋势）</li><li>SRAM：Static RAM</li></ul></li><li>DRAM<ul><li>存储数据是通过对电容器进行充电<ul><li>对一个电容器充电或放电后的状态解读为1或0</li></ul></li><li>需要周期性的充电去刷新保存数据<ul><li>原因：电容器有一种丢失电荷的趋势</li><li>通过一个电荷量的阈值来决断它的状态是0还是1</li><li>本质上是：模拟设备</li></ul></li><li><img src="/img/article_img/InternalMemory4.png" alt=""></li></ul></li><li>SRAM<ul><li>用传统的触发器逻辑门配置存储数据<ul><li>与处理器中使用的逻辑元件相同</li></ul></li><li>只要有电的时候，让就会存储数据</li><li>不会漏电，只要有电，不需要刷新数据就可以保存</li><li><img src="/img/article_img/InternalMemory5.png" alt=""></li></ul></li><li>DRAM和SRAM的比较<ol><li>相同点：<ul><li>Volatile（易失性）</li><li>电被持续性地供给存储器来保持其中数据的值</li></ul></li><li>不同点：<ul><li>DRAM有比SRAM更简单更小的单元，但是需要周期性的刷新</li><li>DRAM相对于SRAM更加高密度并且廉价</li><li>通常来说，SRAM的访问比DRAM的访问快</li><li>SRAM可以用来做Cache，DRAM用来做内存</li></ul></li></ol></li><li>Advanced DRAM Organization（高级DRAM组织）<ul><li>问题：<ul><li>传统的DRAM芯片被它内部的结构和与处理器相连接的总线所限制</li></ul></li><li>类型：<ul><li>Synchronous DRAM（SDRAM）</li><li>DDR SDRAM</li></ul></li></ul></li><li>Synchronous DRAM<ul><li>传统的DRAM通常是异步的<ul><li>处理器向处理器提供地址和控制级别内存，指示在特定位置的一组数据内存应该从DRAM中读取或写入</li><li>DRAM执行各种内部功能，比如激活高电容的行和列行，感应数据，并通过输出缓冲区将数据路由出去，以及处理器必须等待这个延迟</li><li>在延迟之后，DRAM要么写数据，要么读数据</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>不想复习毛概所以水文章</title>
    <link href="/2021/01/05/%E4%B8%8D%E6%83%B3%E5%A4%8D%E4%B9%A0%E6%AF%9B%E6%A6%82%E6%89%80%E4%BB%A5%E6%B0%B4%E6%96%87%E7%AB%A0/"/>
    <url>/2021/01/05/%E4%B8%8D%E6%83%B3%E5%A4%8D%E4%B9%A0%E6%AF%9B%E6%A6%82%E6%89%80%E4%BB%A5%E6%B0%B4%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1>不想复习毛概所以水文章</h1><h3 id="一、毛泽东思想的主要内容和活得灵魂">一、毛泽东思想的主要内容和活得灵魂</h3><ol><li>毛泽东思想的主要内容：<ul><li>新民主主义革命理论</li><li>社会主义革命理论和社会主义建设理论</li><li>革命军队建设和军事策略理论</li><li>政策和策略的理论</li><li>思想政治工作和文化工作理论</li><li>党和建设理论</li><li>国际战略和外交工作的理论</li></ul></li><li>毛泽东思想的活得灵魂：<ul><li>实事求是：坚持一切从实际出发，实事求是</li><li>群众路线：坚持一切从群众中来，到群众中去，一切依靠群众，一切为了群众；把党的正确政策方针融入到群众中去</li><li>独立自主：坚持独立思考，走自己的路，坚持维护民族独立和国家主权</li></ul></li></ol><h3 id="二、新民主主义革命的总路线和基本纲领">二、新民主主义革命的总路线和基本纲领</h3><ol><li>新民主主义革命的总路线：<ul><li>总路线是具体路线的根本指导</li><li>新民主主义革命总路线反映了中国革命的基本规律，指明了革命的“对象，动力和领导力量”，是新民主主义革命的指导路线。</li><li>对象：帝国主义（首要对象）、封建主义、官僚资本主义</li><li>动力：无产阶级、农民阶级、城市小资产阶级、民族资产阶级<ul><li>无产阶级：基本动力</li><li>农民阶级：主力军</li><li>城市小资产阶级：同盟军</li><li>民族资产阶级：动力之一</li></ul></li><li>领导力量：无产阶级政党<ul><li>无产阶级的领导权是中国革命的中心问题。无产阶级的强大和革命的彻底性，所以新民主主义革命必须在无产阶级政党的领导下才能取得成功</li><li>加强无产阶级政党的建设是实现无产阶级政党领导权的根本保证</li></ul></li></ul></li><li>新民主主义革命的基本纲领：<ul><li>政治纲领</li><li>经济纲领</li><li>文化纲领</li></ul></li></ol><h3 id="三、社会主义改造理论">三、社会主义改造理论</h3><ol><li>社会主义和社会主义改造之间的关系以及评价（key）</li><li>社会主义制度确定的意义</li></ol><h3 id="四、邓小平理论的基本问题和主要内容">四、邓小平理论的基本问题和主要内容</h3><ol><li>基本问题</li><li>主要内容</li></ol><h3 id="五、习近平新时代中国特色社会主义思想及其地位">五、习近平新时代中国特色社会主义思想及其地位</h3><ol><li>历史性成就和历史性变革</li><li>社会主要矛盾的变化</li><li>新时代的内涵和意义</li></ol><h3 id="六、坚持和发展中国特色社会主义的总任务">六、坚持和发展中国特色社会主义的总任务</h3><ol><li>中华名族近代以来最伟大的梦想</li><li>中国梦的科学内涵</li><li>奋力实现中国梦</li></ol><h3 id="七、五位一体总体布局">七、五位一体总体布局</h3><ol><li>贯彻新发展理念</li><li>深化供给侧结构性改革</li><li>建设现代经济体系的主要任务</li><li>坚持人与自然和谐共生</li><li>形成人与自然和谐发展新格局</li><li>加快生态文明体制改革</li></ol>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HotTopicOfWeiBo</title>
    <link href="/2021/01/02/HotTopicOfWeiBo/"/>
    <url>/2021/01/02/HotTopicOfWeiBo/</url>
    
    <content type="html"><![CDATA[<h1>Hot Topic Of Wei Bo</h1><blockquote><p>emm! 这是一篇水文，主要是debug太难受了，所以我决定记录下这个错误！</p></blockquote><p><a href="https://pintia.cn/problem-sets/15/problems/893">原题–PTA 新浪微博热门话题(30分)</a></p><blockquote><p>其实我主要是感觉题目说的有点不明不白的！</p><p>最后给几个大佬的测试用例，就明白了！</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs wiki">Input<br>4<br>This is a #test of topic#.<br>Another #Test of topic.#<br>This is a #Hot# #Hot# topic<br>Another #hot!# #Hot# topic<br><br>Output<br>Hot<br>2<br>And 1 more ...<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs wiki">Input<br>4<br>This is a #test of 1 topic#.<br>Another #Test of (1)topic.#<br>This is a #Hot# topic<br>This is a test of 1 topic<br><br>Output<br>Test of 1 topic<br>2<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs wiki">Input<br>3<br>Test #for@ diff words#<br>Test #ford iff words#<br>#more than# one #topics.#<br><br>Output<br>For diff words<br>1<br>And 3 more…<br></code></pre></td></tr></table></figure><p>最后贴个通过代码！✔️</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(<span class="hljs-built_in">string</span> str1, <span class="hljs-built_in">string</span> str2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= str1.length() - <span class="hljs-number">1</span> &amp;&amp; i &lt;= str2.length() - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (str1[i] &lt; str2[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str1[i] &gt; str2[i]) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (str1.length() &lt; str2.length()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;n);<br>    <span class="hljs-comment">//cin &gt;&gt; n;</span><br>    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; HashMap;<br>    <span class="hljs-built_in">string</span> str;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>        -- n;<br>        <span class="hljs-built_in">string</span> forStr = <span class="hljs-string">&quot;.&quot;</span>;<br>        <span class="hljs-built_in">string</span> curStr;<br>        <span class="hljs-keyword">bool</span> start = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">bool</span> end = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">bool</span> blankEnd = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span>.peek() != <span class="hljs-string">&#x27;\n&#x27;</span>) &#123;<br>            <span class="hljs-keyword">char</span> ch = <span class="hljs-built_in">cin</span>.get();<br>            <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!start) &#123;<br>                    start = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    end = <span class="hljs-literal">true</span>;<br>                    start = <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start &amp;&amp; <span class="hljs-built_in">isalnum</span>(ch)) &#123;<br>                curStr += <span class="hljs-built_in">tolower</span>(ch);<br>                blankEnd = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start) &#123;<br>                <span class="hljs-keyword">if</span> (!blankEnd &amp;&amp; curStr.length() &gt; <span class="hljs-number">0</span>) &#123;<br>                    curStr += <span class="hljs-string">&#x27; &#x27;</span>;<br>                    blankEnd = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (end &amp;&amp; <span class="hljs-built_in">isalpha</span>(curStr[<span class="hljs-number">0</span>])) &#123;<br>                curStr[<span class="hljs-number">0</span>] = <span class="hljs-built_in">toupper</span>(curStr[<span class="hljs-number">0</span>]);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (end &amp;&amp; curStr != forStr) &#123;<br>                <span class="hljs-keyword">if</span> (blankEnd) &#123;<br>                    curStr = curStr.substr(<span class="hljs-number">0</span>, curStr.length() - <span class="hljs-number">1</span>);<br>                &#125;<br>                end = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">auto</span> search = HashMap.find(curStr);<br>                <span class="hljs-keyword">if</span> (search != HashMap.end()) &#123;<br>                    search-&gt;second += <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    HashMap.insert(<span class="hljs-built_in">make_pair</span>(curStr, <span class="hljs-number">1</span>));<br>                &#125;<br>                forStr = curStr;<br>                curStr = <span class="hljs-string">&quot;&quot;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">cin</span>.get();<span class="hljs-comment">// 读取最后一个换行符</span><br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> begin = HashMap.begin();<br>    <span class="hljs-built_in">string</span> res = begin-&gt;first;<br>    <span class="hljs-keyword">int</span> cnt = begin-&gt;second;<br>    <span class="hljs-keyword">int</span> nums = <span class="hljs-number">0</span>;<br>    ++ begin;<br>    <span class="hljs-keyword">while</span> (begin != HashMap.end()) &#123;<br>        <span class="hljs-keyword">if</span> (begin-&gt;second &gt; cnt) &#123;<br>            res = begin-&gt;first;<br>            cnt = begin-&gt;second;<br>            nums = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (begin-&gt;second == cnt) &#123;<br>            <span class="hljs-keyword">if</span> (cmp(begin-&gt;first, res)) &#123;<br>                res = begin-&gt;first;<br>            &#125;<br>            nums += <span class="hljs-number">1</span>;<br>        &#125;<br>        ++ begin;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="hljs-built_in">endl</span>;<br>    <span class="hljs-keyword">if</span> (nums != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;And &quot;</span> &lt;&lt; nums &lt;&lt; <span class="hljs-string">&quot; more ...&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>睡了，晚安！</p>]]></content>
    
    
    <categories>
      
      <category>PTA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Happy-Coding-PTA</title>
    <link href="/2021/01/01/Happy-Coding-PTA/"/>
    <url>/2021/01/01/Happy-Coding-PTA/</url>
    
    <content type="html"><![CDATA[<h1>Happy-Coding-PTA</h1><blockquote><p>AAA, 刚结束PTA的跨年挑战赛，感觉还是蛮不错的！</p></blockquote><h2 id="关于为什么我会参加PTA的跨年挑战赛">关于为什么我会参加PTA的跨年挑战赛</h2><p>这个得从去年寒假的天梯赛说起！大一的时候，科协组织的天梯赛，我也算是每天都在跟着做吧！但实在是能力太差太差，就现实版“一杯茶，一个bug改一天”。但是当时却不知道我应该要去学什么，也不知道这个专业到底是干什么的！</p><p>嗨，可能就是信息差吧！在大部分同学都知道应该去学习数据结构的时候，我自己可以说全然不知！更主要的是，我这个智障儿童居然不太会使用搜索引擎去探寻我想要的信息！！！气死我了！</p><p>然后就是计基的期末上机，两道字符串的题目，4个小时！我一道题目都写不出，当时就很想转专业，感觉我不太适合写代码！大家都实在是太强了。</p><p>在之后就是长久的陷入的自卑、自闭、等等恶心循环！对于学习没有丝毫自信！尽管我也在认真学，但这种心态导致我总在考场上溃败！就一个普普通通的考试，我居然中午都能睡不着觉！实在是太想证明自己了！</p><p>这学期的计组和数据科学大作业（虽然还未完成），都给我带来了很多欢乐！坦白说，我觉得自己不是一个喜欢做重复工作的人，很多时候，一些课程的无聊且无用的东西非常困惑我！我并不能很好的平衡好这些东西！</p><p>计组内容非常有趣，多个维度去审视计算机，然后编程作业的设计也很棒！虽然其中的一些东西让我有些头疼，助教的文档我也多次理解错误意思！但看着一个看似简单的乘除法，经过如此多次的修正，去探寻最优组织结构，最有效的算法，实在令人惊讶！并且</p><p>而数据科学大作业，我在听助教讲解要求时，就非常开心，也很想去尝试做代码分析的那个主题，但我也清楚的知道自己的水平，所以还是决定做计算社会学的方向！然后加入了一个大家水平似乎都不怎么高的小组，我也很庆幸，大家都很愿意交流协作。</p><p>然后就是自学爬虫，稍作回忆了寒假疫情在家无心学习看的一点HTML知识，帮助了我更好的通过标签去提取信息。一点一点的构建好爬虫的框架，一点一点的去看文档，了解库的使用，了解正则表达式（虽然应该又忘得差不多了）。。。。。</p><p>算了，之后在更新吧！实在太多想说的了！我是实在太想去参加一些比赛，去同队友们协作！</p><p>我觉得自己算是一个想尝试科研的人吧！可能是我的性格使然，亦或是其他的！总之，我希望自己能够在新的一年里，可以更多的去完善提高自己！罗里吧嗦的，还没说个啥！不说了，等考完试再更新！</p><p>加油加油加油！！！！</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>闲谈</title>
    <link href="/2020/12/30/%E9%97%B2%E8%B0%88/"/>
    <url>/2020/12/30/%E9%97%B2%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<h1>闲谈</h1><h4 id="前言">前言</h4><blockquote><p>📄最近不知为何，内心总是想着写点什么，但却不知道记录些什么。而恰巧，南京近来下了一场酣畅淋漓的大雪，很多年没有见过这么大的雪了，不由分外欣喜。借此，便把近来的点滴稍稍记录作罢。</p></blockquote><h3 id="一、花堪折时直须折-莫待花落空折枝">一、花堪折时直须折,莫待花落空折枝</h3><p>夏秋时令，从食堂到宿舍，一路上散发桂花的香气，甚至略过浓厚。每次经过，我都会驻足欣赏品味一番；三栋旁的一颗花瓣金黄色的桂花树尤其令我感到惊喜；不远处的花圃中，长满了鲜红的南天竹，不禁让人想摘下来品尝品尝。</p><p>香气扑鼻的时光或许也是短暂的，看着掉落一地的花瓣，满脑子都是“花堪折时直须折,莫待花落空折枝”，但或许听着它静静的脱落，才方为最好的欣赏！</p><p>前段时间，刚好碰到滇山茶🌸盛开，美的让人忘却了时间，我便将它那张扬自信的姿态定格了下来。<img src="/img/article_img/snow1.png" alt=""></p><h3 id="二、🐱喵喵喵">二、🐱喵喵喵~</h3><p>南大的猫，总能给人温暖！像数分公主、老婆，汤圆都是南大”明星“。我时常于逸夫楼探寻数分公主的踪迹，但似乎并不总是幸运的。偶然间，在B105碰到数分小公主在线同隔壁桌的女孩子撒娇，甚至跳到电脑上，羡慕至极。</p><p>当然，也有好运降临到我身上的时候，早晨前往教室上课，碰到一群熟睡着的小喵咪，想必正在做着一个无比甜美的梦吧！猫猫虫们围在一起，简直将我的心都化了！<img src="/img/article_img/snow2.png" alt=""></p><p>夜间路过竹林处，一眼就看到了一条蜷缩着的猫猫虫，啊！！！这柔软的身子，我真的很想去摸摸它，但是我知道，我不能！<img src="/img/article_img/snow3.png" alt=""></p><p>最后，当然少不了美貌与憨憨并存的老婆啦！😘<img src="/img/article_img/snow4.png" alt=""><img src="/img/article_img/snow5.png" alt=""></p><p>😂以及金毛狮王的猛虎下山！！！<img src="/img/article_img/snow6.png" alt=""></p><h3 id="三、传递快乐的雪人🏂">三、传递快乐的雪人🏂</h3><p>复习之余，刷着BBQ，偶尔也能感受到大家在繁忙之中为生活传递快乐的善意！</p><p>大雪的那天，我也兴致勃勃地前去炜华看了看！路灯下的薄雪，格外的洁白。伫立着的是一份又一份的快乐，有心的同学甚至给雪人带上了口罩！<img src="/img/article_img/snow8.png" alt="">”我们终将战胜疫情！“但令我最为震惊的是观察雪人时不小心看到的一对小情侣正在向对方传递自己的爱意💖！内心给送上祝福后就默默的逃离了冰冷的雪地。</p><p>最后送上一张BBQ盗来的美图，镇镇场子！</p><p><img src="/img/article_img/snow7.png" alt=""></p><blockquote><p>新年将近，也提前祝大家快乐开心啦！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>散记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HeapSort和一点疑惑</title>
    <link href="/2020/12/28/HeapSort%E5%92%8C%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/"/>
    <url>/2020/12/28/HeapSort%E5%92%8C%E4%B8%80%E7%82%B9%E7%96%91%E6%83%91/</url>
    
    <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> MaxData = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">using</span> ElementType  = <span class="hljs-keyword">int</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HNode</span> &#123;</span><br>    ElementType *Data;<br>    <span class="hljs-keyword">int</span> Size;<br>    <span class="hljs-keyword">int</span> Capacity;<br>&#125;;<br><br><span class="hljs-keyword">using</span> MinHeap = struct HNode *;<br><span class="hljs-function">MinHeap <span class="hljs-title">MinCreate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> MaxSize)</span></span>;<br><span class="hljs-function">MinHeap  <span class="hljs-title">CreateMinHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr [], <span class="hljs-keyword">int</span> len)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MinHeap_Insert</span><span class="hljs-params">(MinHeap H, ElementType item)</span></span>;<br><span class="hljs-function">ElementType <span class="hljs-title">DeleteMin</span><span class="hljs-params">(MinHeap H)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MinHeap_Adjust</span><span class="hljs-params">(MinHeap H)</span></span>;<br><span class="hljs-function">MinHeap <span class="hljs-title">HeapSort</span><span class="hljs-params">(MinHeap H)</span></span>;<br><span class="hljs-function">MinHeap <span class="hljs-title">HeapSort</span><span class="hljs-params">(MinHeap H, <span class="hljs-keyword">int</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">(MinHeap H)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(MinHeap H)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(MinHeap H)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">12</span>;<br>    <span class="hljs-keyword">int</span> arr [] = &#123;<span class="hljs-number">142</span>, <span class="hljs-number">543</span>, <span class="hljs-number">123</span>, <span class="hljs-number">65</span>, <span class="hljs-number">453</span>, <span class="hljs-number">879</span>, <span class="hljs-number">572</span>, <span class="hljs-number">434</span>, <span class="hljs-number">111</span>, <span class="hljs-number">242</span>, <span class="hljs-number">811</span>, <span class="hljs-number">102</span>&#125;;<br>    MinHeap H = CreateMinHeap(arr, len);<br>    H = HeapSort(H);<br>    <span class="hljs-comment">// H = HeapSort(H, H-&gt;Size);</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= H-&gt;Capacity; ++i) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; H-&gt;Data[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-comment">//Test2();</span><br>    Test();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function">MinHeap <span class="hljs-title">MinCreate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> MaxSize)</span></span><br><span class="hljs-function"></span>&#123;<br>    MinHeap H = <span class="hljs-keyword">new</span> (struct HNode);<br>    H-&gt;Data = <span class="hljs-keyword">new</span> ElementType[MaxSize+<span class="hljs-number">1</span>];  <span class="hljs-comment">// 下标从1开始</span><br>    H-&gt;Size = <span class="hljs-number">0</span>;<br>    H-&gt;Capacity = MaxSize;<br>    H-&gt;Data[<span class="hljs-number">0</span>] = MaxData;  <span class="hljs-comment">// 哨兵，比所有优先级都大</span><br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br><br><span class="hljs-function">MinHeap <span class="hljs-title">CreateMinHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    MinHeap H = MinCreate(len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= len - <span class="hljs-number">1</span>; ++i) &#123;<br>        H-&gt;Data[++H-&gt;Size] = arr[i];<br>    &#125;<br>    MinHeap_Adjust(H);<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MinHeap_Insert</span><span class="hljs-params">(MinHeap H, ElementType item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">if</span> (IsFull(H)) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;堆已满&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    i = ++H-&gt;Size;<br>    <span class="hljs-keyword">for</span> ( ; i &gt;= <span class="hljs-number">2</span> &amp;&amp; H-&gt;Data[i/<span class="hljs-number">2</span>] &gt; item; i /= <span class="hljs-number">2</span>) &#123;<br>        H-&gt;Data[i] = H-&gt;Data[i/<span class="hljs-number">2</span>];<br>    &#125;<br>    H-&gt;Data[i] = item;<br>&#125;<br><br><span class="hljs-function">ElementType <span class="hljs-title">DeleteMin</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 从堆中取出键值最大的元素，并删除一个节点       // O(logN)</span><br>    <span class="hljs-keyword">int</span> parent, child;<br>    ElementType MinItem, temp;<br>    <span class="hljs-keyword">if</span> (IsEmpty(H)) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;最小堆为空&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span> - <span class="hljs-number">1</span>;<br>    &#125;<br>    MinItem = H-&gt;Data[<span class="hljs-number">1</span>]; <span class="hljs-comment">// 取出根节点最大值</span><br>    temp = H-&gt;Data[H-&gt;Size--]; <span class="hljs-comment">// 用最大堆中最后一个元素从更节点开始向上过滤下层节点</span><br>    <span class="hljs-keyword">for</span> (parent = <span class="hljs-number">1</span>; parent * <span class="hljs-number">2</span> &lt;= H-&gt;Size; parent = child) &#123;<br>        child = parent * <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> ((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child+<span class="hljs-number">1</span>])) &#123;<br>            child += <span class="hljs-number">1</span>;  <span class="hljs-comment">// child指向左右节点较大者</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp &lt;= H-&gt;Data[child]) &#123;<br>            <span class="hljs-comment">//H-&gt;Data[parent] = temp;  // 加在这里是错误的</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">// 移动temp到下一层</span><br>            H-&gt;Data[parent] = H-&gt;Data[child];<br>        &#125;<br>    &#125;<br>    H-&gt;Data[parent] = temp; <span class="hljs-comment">//这个必须有</span><br><br>   <span class="hljs-comment">/* for (int i = 1; i &lt;= H-&gt;Size; ++i) &#123;</span><br><span class="hljs-comment">        cout &lt;&lt; H-&gt;Data[i] &lt;&lt; &quot; &quot;;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    cout &lt;&lt; endl;*/</span><br>    <span class="hljs-keyword">return</span> MinItem;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MinHeap_Adjust</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> parent = H-&gt;Size / <span class="hljs-number">2</span>; parent &gt;= <span class="hljs-number">1</span>; --parent) &#123;<br>        ElementType temp = H-&gt;Data[parent];<br>        <span class="hljs-keyword">int</span> child = <span class="hljs-number">2</span> * parent;<br>        <span class="hljs-keyword">while</span> (child &lt;= H-&gt;Size) &#123;<br>            <span class="hljs-keyword">if</span> ((child + <span class="hljs-number">1</span>) &lt;= H-&gt;Size &amp;&amp; H-&gt;Data[child + <span class="hljs-number">1</span>] &lt;= H-&gt;Data[child]) &#123;<br>                child += <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (temp &lt;= H-&gt;Data[child]) &#123;<br>                H-&gt;Data[child / <span class="hljs-number">2</span>] = temp;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            H-&gt;Data[child / <span class="hljs-number">2</span>] = H-&gt;Data[child];<br>            H-&gt;Data[child] = temp;<br>            child = <span class="hljs-number">2</span> * child;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">MinHeap <span class="hljs-title">HeapSort</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= H-&gt;Capacity; ++i) &#123;<br>        <span class="hljs-comment">// H-&gt;Data[H-&gt;Size + 1] = DeleteMin(H);  错误</span><br>        <span class="hljs-comment">// H-&gt;Data[H-&gt;Size] = DeleteMin(H); 正确</span><br>        <span class="hljs-keyword">int</span> item = DeleteMin(H);<br>        H-&gt;Data[H-&gt;Size + <span class="hljs-number">1</span>] = item;<br>    &#125;<br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br><br><span class="hljs-function">MinHeap <span class="hljs-title">HeapSort</span><span class="hljs-params">(MinHeap H, <span class="hljs-keyword">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> H;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// H-&gt;Data[H-&gt;Size + 1] = DeleteMin(H);  错误</span><br>        <span class="hljs-comment">// H-&gt;Data[H-&gt;Size] = DeleteMin(H); 正确</span><br>        <span class="hljs-keyword">int</span> item = DeleteMin(H);<br>        H-&gt;Data[H-&gt;Size + <span class="hljs-number">1</span>] = item;<br>        <span class="hljs-keyword">return</span> HeapSort(H, H-&gt;Size - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> H-&gt;Size == H-&gt;Capacity;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> H-&gt;Size == <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">(MinHeap H)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> H-&gt;Size;<br>&#125;<br></code></pre></td></tr></table></figure><p>emmm！写作业的时候，刚好将之前的堆操作简单的复习了一下，不过单纯手码的话会调很久吧！！</p><h3 id="❌不过这里有点疑惑🙏">❌不过这里有点疑惑🙏</h3><blockquote><p>在HeapSort函数里，为什么我注释掉的那部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// H-&gt;Data[H-&gt;Size + 1] = DeleteMin(H);</span><br></code></pre></td></tr></table></figure><p>结果就是错的，而先DeleteMin，然后赋值就是正确的？？？？</p><p>里面的Adjust函数还是很有意思的！</p></blockquote><h3 id="✔️hooo-在助教哥哥的帮助下算是解决了🌥">✔️hooo! 在助教哥哥的帮助下算是解决了🌥</h3><blockquote><p>通过汇编发现，$H -&gt; Data[H-&gt;Size+1] = DeleteMin(H);$ 这个语句它是先会通过H-&gt;Size给确定好数组的位置，然后再调用DeleteMin函数给它赋值，这也就导致了为什么第一个内容会丢掉了，其实并没有丢掉，只是赋值给了数组有效位置地后一个位置。这也解释了为什么前两天我运行时会出现奇怪的bug&lt;好可惜，没能记录下来！&gt;</p><p>所以改成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">H-&gt;Data[H-&gt;Size] = DeleteMin(H);<br>或者<br><span class="hljs-keyword">int</span> item = DeleteMin(H);<br>H-&gt;Data[H-&gt;Size + <span class="hljs-number">1</span>] = item;<br></code></pre></td></tr></table></figure><p>就可以了！！！</p><p>✔️我现在将上面的代码块修正了，原来的错误这里都有解释，然后在上面注释掉了！！！</p><p>然后给张测试图吧！<img src="/img/article_img/HeapSort1.png" alt=""></p><p>emmm,再给下这段代码的不同语句使用时地汇编代码吧！</p><p><img src="/img/article_img/HeapSort2.png" alt=""></p><p><img src="/img/article_img/HeapSort3.png" alt=""></p></blockquote><h3 id="小小小彩蛋！！！-🍀-出卖一下我和助教哥哥地神奇对话">小小小彩蛋！！！:🍀: 出卖一下我和助教哥哥地神奇对话</h3><p><img src="/img/article_img/HeapSort4.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QuickSort的小思考</title>
    <link href="/2020/12/25/QuickSort%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/"/>
    <url>/2020/12/25/QuickSort%E7%9A%84%E5%B0%8F%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1>QuickSort的小思考</h1><h4 id="前言">前言</h4><p>！！！数据结构课刚好讲了排序，虽然我之前粗略的学了数据结构，也涉及到了排序，但是对于快速排序的理解太浅了。</p><p>然后在课上实现快排时，老是出错，调试也调不对，主要原因是没理解清楚。</p><h4 id="虚假的代码">虚假的代码</h4><p>emmm！贴个我课上实现的错误代码吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPivotPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testQuickSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> n = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">int</span> arr[] = &#123;<span class="hljs-number">46</span>, <span class="hljs-number">13</span>, <span class="hljs-number">55</span>, <span class="hljs-number">42</span>, <span class="hljs-number">94</span>, <span class="hljs-number">5</span>, <span class="hljs-number">17</span>, <span class="hljs-number">70</span>, <span class="hljs-number">82</span>, <span class="hljs-number">100</span>&#125;;<br><span class="hljs-keyword">int</span> expect [] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span>, <span class="hljs-number">42</span>, <span class="hljs-number">46</span>, <span class="hljs-number">55</span>, <span class="hljs-number">70</span>, <span class="hljs-number">82</span>, <span class="hljs-number">94</span>, <span class="hljs-number">100</span>&#125;;<br>quickSort(arr, <span class="hljs-number">0</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">1</span>; ++i) &#123;<br><span class="hljs-keyword">if</span> (arr[i] != expect[i]) &#123;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;FALSE&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;TRUE&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>testQuickSort();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (head &lt; end) &#123;<br><span class="hljs-keyword">int</span> curPos = getPivotPos(arr, head, end);<br>quickSort(arr, head, curPos - <span class="hljs-number">1</span>);<br>quickSort(arr, curPos + <span class="hljs-number">1</span>, end);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPivotPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 不妨每次去最后一个值</span><br><span class="hljs-comment">// 对以基准值为比较对象进行分组</span><br><span class="hljs-comment">// 左边小，右边大</span><br><span class="hljs-keyword">int</span>  pivot = arr[end];<br><span class="hljs-keyword">int</span> pivotPos = end;<br><span class="hljs-keyword">while</span> (head &lt; end) &#123;<br><span class="hljs-keyword">while</span> ((head &lt; end) &amp;&amp; arr[end] &gt;= pivot) &#123;<br>end -= <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-comment">// 此时已经找到了一个值可能会小于基准值</span><br><span class="hljs-keyword">if</span> (head &lt; end) &#123;<br><span class="hljs-keyword">int</span> tmp = arr[end];<br>arr[end] = pivot;<br>arr[pivotPos] = tmp;<br>pivotPos = end;<br>&#125;<br><span class="hljs-keyword">while</span> ((head &lt; end) &amp;&amp; arr[head] &lt;= pivot) &#123;<br>head += <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (head &lt; end) &#123;<br><span class="hljs-keyword">int</span> tmp = arr[head];<br>arr[head] = pivot;<br>arr[pivotPos] = tmp;<br>pivotPos = head;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> pivotPos;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实问题主要出在getPivotPos这个函数里。这个函数的流程是：</p><ol><li>从最右边向左边寻找一个小于基准pivot的值，然后将它与基准值进行交换。（此时，基准值位于从右向左找到的第一个小于pivot的值的地方，而这个值位于原来的pivot值的地方）</li><li>然后从左边向右边寻找一个大于基准pivot的值，将它与基准值进行交换。（此时，基准值就位于左边找到的第一个大于基准值的地方。）此时相当于把左边的第一个大于基准值的值和右边一个小于基准值的值进行了交换。</li><li>返回此时基准值的位置</li></ol><blockquote><p>其实呢，思路是正确的，但是边界却没有考虑清楚。下面简单示例下（注意我代码的42，43两行）：</p><p>这是要交换数据的初始状态：max min 基准值</p><p>第一次交换：max 基准值 min</p><p>第二次交换：基准值 max min</p><p>返回基准值的坐标</p></blockquote><p>石破天惊！！！就是因为，我的基准值是在<strong>最右边</strong>，并且是从最右边开始寻找的<strong>第一个小于基准值的值</strong>，交换后，然后再同左边进行交换后，它会导致两个值都在基准值的一侧，所以才会出现上述错误！！！</p><p>所以，只要将42，43两行改成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> pivot = arr[head];<br><span class="hljs-keyword">int</span> pivotPos = head;<br></code></pre></td></tr></table></figure><p>或者将下面进行交换（两个对应的while循环和if语句）的次序进行一下调整，就不会出现这种问题了！</p><hr><p>emmm！再贴个改进后的代码凑凑数吧！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta"># <span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPivotPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (head &lt; end) &#123;<br>        <span class="hljs-keyword">int</span> curPos = getPivotPos(arr, head, end);<br>        quickSort(arr, head, curPos - <span class="hljs-number">1</span>);<br>        quickSort(arr, curPos + <span class="hljs-number">1</span>, end);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPivotPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[], <span class="hljs-keyword">int</span> head, <span class="hljs-keyword">int</span> end)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 不妨每次去最后一个值</span><br>    <span class="hljs-comment">// 对以基准值为比较对象进行分组</span><br>    <span class="hljs-comment">// 左边小，右边大</span><br>    <span class="hljs-keyword">int</span>  pivot = arr[end];<br>    <span class="hljs-keyword">while</span> (head != end) &#123;<br>        <span class="hljs-keyword">while</span> ((head &lt; end) &amp;&amp; arr[head] &lt;= pivot) &#123;<br>            head += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-comment">// 此时已经找到了一个值可能会小于基准值</span><br>        <span class="hljs-keyword">if</span> (head &lt; end) &#123;<br>            arr[end] = arr[head];<br>        &#125;<br>        <span class="hljs-keyword">while</span> ((head &lt; end) &amp;&amp; arr[end] &gt;= pivot) &#123;<br>            end -= <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (head &lt; end) &#123;<br>            arr[head] = arr[end];<br>        &#125;<br>    &#125;<br>    arr[end] = pivot;<br>    <span class="hljs-keyword">return</span> end;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testQuickSort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 10</span><br>    <span class="hljs-comment">//46 13 55 42 94 05 17 70 82 100</span><br>    <span class="hljs-keyword">int</span> n;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>    <span class="hljs-keyword">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i= <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; arr[i];<br>    &#125;<br>    quickSort(arr, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    testQuickSort();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="还是对改进后的代码做个简单的说明吧！嗨！罗里吧嗦的！">还是对改进后的代码做个简单的说明吧！嗨！罗里吧嗦的！</h4><ol><li><p>改进后的代码，我是<strong>默认每次最右边的值为基准值</strong>，所以我们要从<strong>最左边</strong>找到一个<strong>大于</strong>它的值，将其与这个大于它的值进行交换。但是为什么我们不要把原来大于基准值的位置给覆盖上基准值呢？</p></li><li><p>因为此时我们已经确定了大于基准值的位置，我们目的也是将这个位置用基准值另一侧小于基准值的值进行覆盖，所以就可以暂时不覆盖。</p></li><li><p>接着从基准值的<strong>最右边</strong>开始找到一个<strong>小于基准值</strong>的值，将这个较小值填入原来那个等待覆盖的地方。此时这个<strong>小于基准值的</strong>区域等待被基准值覆盖，但是我们还要进行迭代，它的位置被记住了，所以不用管</p></li><li><p>然后重复上述1，3步骤，直至将数据分好块！此时数据已经分好块了，但是还有个位置被记录了下来，也就是等待被基准值覆盖的位置，进行覆盖即可，然后返回基准值的位置！完成！</p></li></ol><h4 id="小结一下吧！">小结一下吧！</h4><p>其实快速排序的主要思想是：通过跨过多个数据进行数据的交换，从而达到少进行数据交换的目的。</p><p>主要算法步骤在于：</p><ul><li>选定基准</li><li>将数据进行分块，基准左边的数据都小于/大于基准，右边的都大于/小于基准</li><li>重复n次，就能将数据都排好序</li></ul><p>关键步骤就在于，我们将数据进行分块：直接想法就是从<strong>基准的右边</strong>找到一个小于基准的值，基准左边找到的一个大于基准的值进行交换，这样就不会导致交换后数据还在基准的同一侧！<strong>所以，基准选取后，第一个从哪里取要交换的值，这步其实也算是一个关键点吧！</strong></p><p>ok，problem solve！</p>]]></content>
    
    
    <categories>
      
      <category>数据结构和算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计组上机考试后的一些小思考</title>
    <link href="/2020/12/20/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/"/>
    <url>/2020/12/20/%E8%AE%A1%E7%BB%84%E4%B8%8A%E6%9C%BA%E8%80%83%E8%AF%95%E5%90%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1>计组上机考试后的一些小思考</h1><p>​昨天进行了上机考试，然后感觉发挥的不是很好吧！没能拿到自己理想的结果，所以下次要冲一下。我并不是想卷一个好看点的分数，只是说我在考试中真的暴露出了太多的问题😢。</p><p>​话说，自从高考结束后，我也很少再特意的腾出一块时间来单独的用来思考和总结，以及规划我的前行的道路了。这也导致了我在整个大一和即将结束的大二学习都是很莽撞的样子，像极了一只无头苍蝇，💢局限于透明的玻璃瓶中，撞得头破血流！也就越发的觉得思考和规划是多么的重要！</p><p>​首先回顾一下考试！emmm！我对这次考试准备的不算多吧，就要考试的那天把自己写过的代码过了一遍，然后主要自己把PPT上的知识点进行了一些列的总结。在这期间，也把之前没掌握或者说掌握的很朦胧的知识点给理清了。同时思考后获取新的理解的感觉真的很棒😀。然后最值得自豪的是，自己简单的改进了下NBCD码减法的算法步骤，然后给老师发了封我证明我自己结论的PDF，不过他还没回，估计是觉得这都讲过了，你才知道！！！（可能是老师上课讲了，我当时没听到？啊！这里很气，我早就该换一副眼镜了。每次只要没做到前排位置，我就基本看不清黑板和投屏！）</p><p>​然后整个计组的编程作业我也都是很认真的在做，而且这是为数不多的让我觉得很惊喜的课程！✨虽然Cache一度让我难受！Virtual Memory也让我感受到了它的神秘之力~~不过，我都解决了，并且都是靠着自己一点一点的去理解，一点一点的去挖掘其中的联系！TLB，永远的神！✨我觉得自己在作业这方面做的还算不错吧，没有抄袭，并且是本着学知识的态度去完成的！主要是，这个作业是真的蛮好玩的！👍</p><p>​ok，回到机考！题目怎么说呢！我感觉出的很好，但同时也出的有点问题！很好的原因是：它整个代码框架的逻辑非常的贯通，一环扣一环，同时纸质题卷让我感觉这才是南大考试该有的样子吧！但是它可能稍微简单了点？导致了一些不公平？还有，这机房的电脑也太垃圾了吧！！！ 五六十台电脑用不了，还在那等别人写完了，轮到自己了才能去写？？？</p><p>​这稍微有点离谱！更奇葩的是，居然有的同学的电脑里有往年考试的答案，然后知识寄存器/操作数参数不一样？？？一个是8，一个是16？？这不是只要改个参数就好了嘛？考试从下午13：00开始，我等到了14：29才有机器用！然后这其实也就算了。</p><p>​最主要我在考试的时候，助教一直在我旁边看着，因为其他同学基本都走完了，我是属于倒数第二批去机房考试的！一批大概2-5个人不等！然后因为比较简单，事先就构思好了，然后在Booth算法那里出了点bug，把两个操作数搞反了，导致中间步骤的部分积和测试用例的不一样，就一直在找！！！然后助教也在旁边看着，我就有点慌乱！为嘛我心态这么容易慌张？从高中到大学一直这样！害，还是稍微菜了点，对自己不够自信！</p><p>​个人评价：主要是自己内心不够平静，老是自乱阵脚，明明平时做的都不错，准备的也不差，就以考试就考不出来！高中也是，不过高中我一直在写小结，复盘，思考，找解决方法，所以在慢慢向好的方向发展。现在大学里，同样需要做到这点，以后的人生里也是。调整心跳，学习这是一生都要做的事！！还有就是规划，规划真的太重要了！</p><p>​好了，罗里吧嗦的吐槽完了！之后再进一步做更详细的规划！现在需要赶进复习期末考试了，我的GPA真的太低了！退学警告！！！✊</p><p>​克制自己，平静！淡定！在勤奋一点！加油，冲冲冲！相信自己期末不会差的！这学期肯定能把GPA提高一个小的等级！！！🚀</p>]]></content>
    
    
    <categories>
      
      <category>个人思考总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>错误修正</title>
    <link href="/2020/12/18/%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/"/>
    <url>/2020/12/18/%E9%94%99%E8%AF%AF%E4%BF%AE%E6%AD%A3/</url>
    
    <content type="html"><![CDATA[<h1>错误修正</h1><ul><li><p>半导体存储系统是很容易出错的</p></li><li><p>错误类型：</p><ul><li>硬故障<ul><li>永久性的物理故障，以至于影响存储单元不能可靠的存储数据，称为固定的“1”或“0”或其之间跳转的故障</li></ul></li><li>软差错<ul><li>随即非破坏性事件，改变了存储单元的内容，但是不破坏存储器</li><li>可以是电源问题或$a$粒子引起</li></ul></li></ul></li><li><p>基本思想：增加一些额外的位用来存储纠错信息</p></li><li><p>过程：</p><ul><li><p>输入的数据：M位的数据D和映射函数$f$产生的K位纠错码C</p></li><li><p>输出的数据：一个新的数据$D<sup>{'}$和映射函数$f$产生的K位纠错码$C</sup>{‘’}$，并且和已经存在的K位纠错码$C^{'}$进行比较</p><ul><li>没有检测出错误：传送数据$D^{'}$</li><li>检测出一个可以修改的错误：纠正错误然后发送纠正后的数据</li><li>检测出一个不可修改的错误：报告错误</li><li><img src="/img/article_img/Error1.png" alt="Error Correction"></li></ul></li></ul><h2 id="奇偶校验">奇偶校验</h2><ul><li>基础思想：通过增加一位来确定数字1在数据中出现的是奇数词或偶数次</li><li>过程：<ul><li>假设数据$D=D_{M}…D_{2}D_{1}$</li><li>输入的数据：<ul><li>奇校验位：$C=D_{M} \bigoplus  … \bigoplus D_{2} \bigoplus D_{1} \bigoplus 1$；</li><li>偶校验位：$C=D_{M} \bigoplus  … \bigoplus D_{2} \bigoplus D_{1}$；</li></ul></li><li>输出的数据：<ul><li>奇校验位：$C=D^{‘}<em>{M} \bigoplus  … \bigoplus D^{'}</em>{2} \bigoplus D^{’}_{1} \bigoplus 1$；</li><li>偶校验位：$C=D^{‘}<em>{M} \bigoplus  … \bigoplus D^{'}</em>{2} \bigoplus D^{’}_{1}$；</li></ul></li><li>检查：$S=C^{‘’} \bigoplus C^{'}$<ul><li>S = 1: 出错的位数是奇数个</li><li>S = 0：正确或出错的位数的偶数个</li></ul></li></ul></li><li>简单说明：奇偶校验位，其中0的出现对结果没有影响，所以只考虑1，如果出现了偶数个1，定义奇数位是0，这个是定义的，偶数位必然和奇数位相反。</li><li>优点：消耗少</li><li>缺点：出错位数是奇数个时，不能找出具体出错的地方；也不能用来进行纠错</li><li>comment：比较是用于一个字节的数据的检验</li></ul></li></ul><h2 id="海明码-汉明码">海明码/汉明码</h2><ul><li>基本思想：把数据位分成不同的组，然后使用奇偶校验码来对每组进行纠错和检验</li><li>步骤：<ul><li>将M位分成K组</li><li>输入的数据：用一位来指示一组，生成K位的校验码</li><li>输出的数据：用一位来指示一组，生成一个新的K位的校验码</li><li>校验：对获取的数据，重新计算出一个K位的校验码，把这个重新计算出的校验码和同数据一同传过来的数据中含有的校验码进行异或，获得一个K位的<strong>故障字</strong>。</li></ul></li><li>校验码的长度<ul><li>前提假设：最多的错误是数据中只有1位出现错误</li><li>可能的错误：<ul><li>1位数据位出错：M</li><li>一位校验码错误：K</li><li>没有错误：1</li></ul></li><li>校验码长度：$2^{k} \geq M + K + 1$</li><li><img src="/img/article_img/Error2.png" alt=""></li></ul></li><li>对于故障字的值<ul><li>把故障字的值映射到可能出错或需要的环境</li><li>规则：<ul><li>全0：没有检测出错误</li><li>全1：检查位中出现了一位错误，但是不需要纠正，因为传输出去的时候会重新计算校验码</li><li>其他位：将这些位用来一一对应一个错误（或者闲置），并且用来进行纠错</li></ul></li></ul></li><li>数据位的划分<ul><li>假设8位的数据$D=D_{8}…D_{2}D_{1}$，4位校验码是$C=C_{4}C_{3}C_{2}C_{1}$</li><li>数据位+校验码与故障字的关系：<ul><li><img src="/img/article_img/Error3.png" alt=""></li></ul></li></ul></li><li><img src="/img/article_img/Error4.png" alt=""></li><li><img src="/img/article_img/Error5.png" alt=""></li><li><img src="/img/article_img/Error6.png" alt=""></li><li>SEC（single_error_correcting）:可以找到并修正1位的错误</li><li>SEC-DED（single_error_correcting, double_error_detecting）:可以找到2位错误，并修正1位错误<ul><li>增加额外的一位：$C_{5} = D_{1} \bigoplus D_{2} \bigoplus D_{3} \bigoplus D_{5} \bigoplus D_{6} \bigoplus D_{8}$</li><li>一位的错误出现了，三位的校验码会被改变</li></ul></li><li><img src="/img/article_img/Error7.png" alt=""></li><li><img src="/img/article_img/Error8.png" alt=""></li></ul><h2 id="Cyclic-Redundancy-Check">Cyclic Redundancy Check</h2><ul><li>奇偶校验码的问题<ul><li>额外的消耗太大</li><li>需要将数据划分成字节</li></ul></li><li>CRC<ul><li>适用于存储和传输以流的形式的大容量的数据</li><li>通过数据函数生成数据的校验码</li></ul></li><li>基本思想<ul><li>假设数据N位，左移后与K+1位的生成多项式进行模二除法</li><li>使用K位的余数作为校验码</li><li>把校验码放在数据的后面</li></ul></li><li>Check<ul><li>如果N+K位数据同生成多项式进行模二除法能够进整除，没有错误出现</li><li>否则，出现错误</li></ul></li><li>例子：<img src="/img/article_img/Error9.png" alt=""></li><li>编程算法：<ul><li>数据D，生成多项式Pol，长度分别为N，K+1</li><li>在数据D后面加上K+1位0，同Pol进行模二除法（取异或）</li><li>最后获取的K位余数即为校验码</li><li>Check同理</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浮点数算术</title>
    <link href="/2020/12/18/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%AE%97%E6%9C%AF/"/>
    <url>/2020/12/18/%E6%B5%AE%E7%82%B9%E6%95%B0%E7%AE%97%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1>浮点数算术</h1><h2 id="1-加减法">1. 加减法</h2><ul><li><p>确保两个操作数得指数相同</p><p>$X + Y = (X_{s} \times B^{X_{E} - Y_{E}} + Y_{S}) \times B^{Y_{E}}$</p><p>$X - Y = (X_{s} \times B^{X_{E} - Y_{E}} - Y_{S}) \times B^{Y_{E}}$</p><p>$X_{E} \leq Y_{E}$</p></li><li><p>步骤</p><ol><li>检查是否有0</li><li>对阶：把阶数较小的向阶数较大得对齐（大阶小阶，有效位的高位左移被丢失，准确度损失大❌；小阶对大阶，有效位低位右移被丢失，损失相对较小✔️）</li><li>对有效值加减</li><li>规格化结果</li></ol></li><li><p><img src="/img/article_img/FPU1.png" alt="add/sub workflow"></p></li><li><p>阶数上溢：</p><ul><li>正阶数查过了阶码域能表示的范围</li><li>记为$+\infty$;$-\infty$</li></ul></li><li><p>阶数下溢：</p><ul><li>负阶数小于阶码域能表示的最小值</li><li>报告为0</li></ul></li><li><p>有效值上溢：</p><ul><li>相同符号的有效值相加可能会导致进位</li><li>调整阶数和有效值的关系</li></ul></li><li><p>有效值下溢：</p><ul><li>在对阶过程中，有效值的有效位可能会右移到有效值域的外面</li><li>使用一些保护位</li></ul></li></ul><h2 id="2-符号幅值加法">2. 符号幅值加法</h2><ul><li>如果操作数的符号相同，做加法，否则做减法<ul><li>加法：直接相加<ul><li>如果最高位有进位，上溢</li><li>符号和加数的符号相同</li></ul></li><li>减法：加减数的补码<ul><li>如果最高位有进位，修正（去掉进位就是结果）</li><li>否则计算它的补码后取负</li></ul></li></ul></li></ul><p><img src="/img/article_img/FPU2.png" alt="example"></p><ul><li>例子中：第一个表示上溢；第二个现堆0.8125取补码，然后相加后发现没有进位，那么再次取补码后取负即为结果；第三个先对0.625取补码，相加后有进位，修正符号同减数的符号（舍弃进位）</li><li>简单说明：$X + Y$; 如果$X; Y$符号相同就直接相加，否则就是相当于$X - (-Y)$,做减法💨<ul><li>先对$(-Y)$取补码得$(-Y_{c})$，假设$X， Y$都是n位，又因为我们不计入符号位，所以有$2^{n} = (-Y) + (-Y)_{c}$</li><li>执行加法：$Z = X + (-Y)_{c} = X + 2^{n} - Y$</li><li>如果$Z$得最高位有进位，说明$Z = 2^{n} + X - Y \geq 2<sup>{n}$；即进位即为$2</sup>{n}$，所以去掉进位即为结果</li><li>如果$Z$得最高位没有进位，则说明$Z = 2^{n} + X - Y &lt; 2^{n}$, 即结果$X - Y = - (2^{n} - Z)$；即对$Z$取补码，然后取负即为结果。</li></ul></li></ul><p><img src="/img/article_img/FPU3.png" alt="addition &amp; subtraction"></p><p><img src="/img/article_img/FPU4.png" alt="addition &amp; subtraction"></p><ul><li>对上述例子得简单说明：<ul><li>上述两个例子就是很好得用到了上面的符号幅值加法得算法原理！简直棒极了！！！🚀</li><li>第一个例子：先对阶，然后发现是0.5 -(-0.4375)；所以要转为加法来计算—&gt;0.5 + (-(-0.4375)) = 0.5 + 0.4375, 直接相加即可。</li><li>第二个例子：先对阶，然后发现是0.5+(-0.4375)；所以采用符号幅值加法，即相当于0.5-0.4375; 对0.4375得有效值取补码，然后同0.5的有效值相加，判断是否有进位，发现有进位，直接舍弃掉进位即为真正的有效值，然后再规格化就好了！</li></ul></li></ul><h2 id="3-乘法">3. 乘法</h2><ul><li>运算步骤：<ul><li>如果操作数出现0，直接返回0</li><li>对两个操作数的阶码求和，减去偏移量（32bits的bias=127）（因为在浮点数表示为计算机中的01串时，会对阶码加上偏移量，即$E_{1} = E_{true, 1} + bias; E_{2} = E_{true, 2} + bias=&gt; E_{3} = E_{true, 3} + bias = E_{1} + E_{2} - bias$）</li><li>有效值相乘</li><li>规格化结果，并且进行舍入</li><li><img src="/img/article_img/FPU5.png" alt="multiply workflow"></li><li><img src="/img/article_img/FPU6.png" alt="example"></li></ul></li><li>主要是需要注意下浮点数的表示，以及阶码和那个地方。其余的乘法就是普通的无符号乘法，然后判断下符号即可。</li></ul><h2 id="4-除法">4. 除法</h2><ul><li>运算步骤：<ul><li>如果除数为0，抛出异常，或者设置结果为无穷大（看需求）</li><li>被除数为0，结果为0</li><li>被除数阶码减去除数阶码，然后再加上偏移量（做减法时，偏移量抵消了）</li><li>对有效值进行除法</li><li>对结果进行规格化和舍入</li><li><img src="/img/article_img/FPU7.png" alt="div workflow"></li><li><img src="/img/article_img/FPU8.png" alt="example"></li></ul></li><li>需要注意的点：主要是除数为0，被除数为0的处理方法，它的时限要求不要随着需求改变；还有就是规格化时，可能会涉及到后面的保护位的使用</li></ul><h2 id="5-精度的考量">5. 精度的考量</h2><ul><li><p>保护位：</p><ul><li>实际的浮点寄存器的比有效值要长一点</li><li>这些多出来的位用来存储一些可能会用到的位，称为保护位</li><li>它们通过“0”这个位来拉长有效位的右端</li></ul><p><img src="/img/article_img/FPU9.png" alt="example"></p><ul><li>注意🍎：它们是实际拉长了有效位来计算的，但计算完结果后，截取后面的保护位，能够增大精确度</li></ul></li><li><p>舍入：</p><ul><li>计算后的有效值一般会存储在比较长的寄存器中</li><li>当我们把数字读取位正常的浮点数的格式时，我们会忽略那些多余出来的位，因此就需要考量怎么舍入的问题：<ul><li>就近舍入：结果被舍入为最近可表示的数</li><li>向$+\infty$舍入：结果向正无穷大方向向上舍入</li><li>向$-\infty$舍入：结果向负无穷大方向向下舍入</li><li>朝0舍入：结果向0舍入</li></ul></li></ul></li><li><p>有意思的两个小例子🔔：假设浮点数16位，1位符号位，9位有效值位，6位阶码（bias：31）</p><ul><li><p>+652.13: 0 101000 010001100 -&gt; +652.0；-7.48: 1 100001 110111101 -&gt; -7.4765</p></li><li><p>🌼：652.13 + ( - 7.48) = 644.65</p></li><li><p>101000 - 100001 = 000111</p></li><li><p>calculate without guard bits:</p><ul><li>1 010001100  - 0 00000111 -&gt; 1 010000101</li><li>=&gt; 0 101000 010000101 (645.0)</li></ul></li><li><p>calculate with guard bits:</p><ul><li>1 010001100 000000 - 0 000000111 011110 -&gt; 1 010000100 100010</li><li>=&gt; 0 10100 010000100（644.0）</li></ul></li><li><p>为什么使用了保护为结果反而离实际结果更远了呢？👻</p><ul><li>因为我们把一个浮点数输入计算机中表示，它本身就是有误差的；而这个计算结果是在计算机表示更精确（使用了保护位，有效值位数多）的情况下计算出的结果，是计算机认为的准确结果，也是我们所认为计算机更加精确了的结果。</li></ul></li><li><p>🍁：652.13 - ( -7.48 ) = 659.61</p></li><li><p>101000 - 100001 = 000111</p></li><li><p>calculate without guard bits:</p><ul><li><p>1 010001100  + 0 00000111 -&gt; 1 010010011</p></li><li><p>=&gt; 0 101000 010010011 (659.0)</p></li><li><p>calculate with guard bits:</p><ul><li>1 010001100 000000 + 0 000000111 011110 -&gt; 1 010010011 011110</li><li>=&gt; 0 101000 010010011（659.0）</li></ul></li></ul></li></ul></li></ul><p>—end!📄</p>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十进制运算</title>
    <link href="/2020/12/17/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    <url>/2020/12/17/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1>十进制运算</h1><h2 id="加法🌙">加法🌙</h2><p><img src="/img/article_img/Dec1.png" alt="Addition"></p><ul><li>当有进位时，就对整个二进制表示加 <strong>0110</strong>；这相当于16进制和10进制的转换需要✔️</li></ul><h1>减法</h1><p><img src="/img/article_img/Dec2.png" alt="Subtraction"></p><p><img src="/img/article_img/Dec3.png" alt="example"></p><ul><li><p>emmm！对于减法的实现，我们很容易会和二进制补码联系起来，就是重复利用已经实现好的加法器进行运算​​</p></li><li><p>$N_{1} - N_{2} = N_{1} + (10 ^{n} - N_{2})$</p></li><li><p>因为我们使用NBCD码进行减法运算时，它是将每4位当作一个块，计算数字后乘以10的底来运算的</p></li><li><p>$N_{1} - N_{2} = [10^{n} - (10^n - N_{1} + N_{2})]$</p></li><li><p>修正后步骤即为：</p><ul><li>$N_{1} - N_{2}$; 现对$N_{1}$对照着表格进行转换(其实就是9 - X),记转换后的为$N^{'}$</li><li>然后对$N^{'}$与$N_{2}$进行上面的加法（复用）</li><li>考虑加法结果的进位<ul><li>进位为0：直接进行转换即为结果</li><li>进位为1：直接在低位+1，然后取负即为结果</li></ul></li></ul><p>😆简单证明：</p><p>NBCD减法算法的简单证明✔️:</p><ul><li>给定$N_{1}, N_{2}$; 假设它们用$4n$位01串表示的NBCD码，均为整数，不带符号，因为有符号的数计算同理。</li><li>计算$Ans = N1 - N2$； $N_{1} = (a_{n,4}…a_{n,1})…(a_{1,4}…a_{1,1}); N_{2} = (b_{n,4}…b_{n,1})…(b_{1,4}…b_{1,1})$</li><li>算法步骤为：<ol><li>按照转换表，对$N_{1}$的从左开始，每四位做一次转换（1001 - 4bits）得$N^{‘}<em>{1} = (a<sup>{'}_{n,4}…a</sup>{'}</em>{n,1})…(a<sup>{'}_{1,4}…a</sup>{’}<em>{1,1})$；其中$N^{'}</em>{1} = 9 \times 10^{n-1} + 9 \times 10^{n-2} + … +  9 \times 10^{0} - N_{1} = 1 \times 10^{n} - N_{1} - 1$</li><li>复用NBCD码得加法得$N_{3} = N^{'}<em>{1} + N</em>{2} = 1 \times 10^{n} - N_{1} - 1 + N_{2}$（以通过NBCD码加法进位得修正）</li><li>看$N_{3}$是否有进位：<ul><li>如果$N_{3}$没有进位，则说明$10^{n} - N_{1} - 1 + N_{2} &lt; 10^{n}$； 即$N_{1} - N_{2} &gt; 1$；所以直接对$N_{3}$做一次上述转换得$N^{'}<em>{3}$; 有$N^{'}</em>{3} = 10^{n} - N_{3} - 1 = 10^{n} - (10^{n} - N_{1} - 1 +N_{2}) = N_{1} - N_{2}$即为结果。</li><li>如果$N_{3}$有进位，即$10^{n} - N_{1} - 1 + N_{2} \geq 10^{n}$；即有$N_{2} - N_{1} \geq 1$；即$N_{3} = 10^{n} + N_{2} - N_{1} - 1 $；即进位表示$10^{n}$, 而$N_{3}$为$N_{2} - N_{1} - 1$; 为此，我们只要对$N_{3}$在低位加上“0001”，然后取负即为结果。</li></ul></li></ol></li></ul><p><strong>✔️简单的例子</strong></p><p>eg: 309 - 125<br>0011 0000 1001 （309）-<br>0001 0010 0101 （125）</p><p>0110 1001 0000  （进行一次转换）+<br>0001 0010 0101 -&gt;<br>0111 1011 0101</p><p>0111 1011 0101 （对1011修正）+<br>0000 0110 0000   -&gt;<br>1000 0001 0101 进位为0， 直接转换即为结果 -&gt;<br>0001 1000 0100 (184)</p><p>eg: 125 - 309<br>0001 0010 0101   (125) -<br>0011 0000 1001   (309)</p><p>1000 0111 0100   (进行了一次转换) +<br>0011 0000 1001   -&gt;<br>1011 0111 1101</p><p>1011 0111 1101  （对1011、1101进行修正) +<br>0110 0000 0110   -&gt;<br>1 0001 1000 0011  (进位为1，在此基础上+1后取负) -&gt;</p><p>0001 1000 0100 （-184）</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>整数算术</title>
    <link href="/2020/12/17/%E6%95%B4%E6%95%B0%E7%AE%97%E6%9C%AF/"/>
    <url>/2020/12/17/%E6%95%B4%E6%95%B0%E7%AE%97%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1>整数算术</h1><h3 id="1-整数运算在ALU中进行">1. 整数运算在ALU中进行</h3><ul><li>数据、结果、标志都保存在寄存器中</li><li>控制单元提供控制信号来控制数据的转运和运算的进行</li><li><img src="/img/article_img/ALU1.png" alt="ALU"></li></ul><h2 id="2-加法全加器">2. 加法全加器</h2><ul><li>$S = X + Y $; $S = S_{n}S_{n-1}…S_{1}$; $X = X_{n}X_{n-1}…X_{1}$; $Y = Y_{n}Y_{n-1}…Y_{1}$(可能结果还会多出进位$C_{n}$</li><li>$S_{i} = X_{i} \bigoplus Y_{i} \bigoplus C_{i-1}$;  $C_{i} = X_{i}C_{i-1} | Y_{i}C_{i-1} | X_{i}Y_{i}$;</li><li>与门延迟: 1ty</li><li>或门延迟：1ty</li><li>异或门延迟：3ty</li><li><img src="/img/article_img/ALU2.png" alt=""></li><li><img src="/img/article_img/ALU3.png" alt=""></li></ul><h2 id="3-串行进位加法器">3. 串行进位加法器</h2><ul><li>延迟：<ul><li>$C_{n}: 2n ty$</li><li>$S_{n} : (2n+1)ty$</li></ul></li><li>缺点：慢</li></ul><p><img src="/img/article_img/ALU4.png" alt="serial carry Adder"></p><h2 id="4-进位超前加法器">4. 进位超前加法器</h2><p><img src="/img/article_img/ALU5.png" alt="carry look ahead Adder"></p><p><img src="/img/article_img/ALU6.png" alt="carry look ahead Adder"></p><ul><li>1ty: 将所有的$P_{i}, G_{i}$都算好</li><li>2ty：计算所有的$C_{i}$</li><li>3ty：计算所有的$S_{i}$</li></ul><h2 id="5-部分进位超前加法器">5. 部分进位超前加法器</h2><p><img src="/img/article_img/ALU7.png" alt="part carry look ahead Adder"></p><ul><li>3ty：计算好所有$P_{i}$;$C_{i} (0&lt;=i&lt;=7)$；同时异或好所有$X_{i},Y_{i}$</li><li>2ty：开始计算$S_{i}(0&lt;=i&lt;=7)$;并且计算好$C_{i}(8&lt;=i&lt;=15)$</li><li>2ty：计算好$S_{i}(0&lt;=i&lt;=7)$;开始计算$S_{i}(8&lt;=i&lt;=15)$;并且计算好$C_{i}(16&lt;=i&lt;=23)$</li><li>2ty：计算好$S_{i}(8&lt;=i&lt;=15)$;开始计算$S_{i}(16&lt;=i&lt;=23)$;并且计算好$C_{i}(24&lt;=i&lt;=31)$</li><li>3ty：计算好$S_{i}(16&lt;=i&lt;=23)$;并且计算好$S_{i}(24&lt;=i&lt;=31)$</li></ul><p><strong>❌溢出</strong>：</p><ul><li><p>$C_{n} \neq C_{n-1}$: $overflow = C_{n} \bigoplus C_{n-1}$</p></li><li><p>$S_{n} \neq X_{n} and S_{n} \neq Y_{n}$:$overflow = X_{n}Y_{n} \overline S_{n} | \overline X_{n} \overline Y_{n}S_{n}$;</p></li><li><table><thead><tr><th>C<sub>n</sub></th><th>C<sub>n-1</sub></th><th>X<sub>n</sub></th><th>Y<sub>n</sub></th><th>S<sub>n</sub></th></tr></thead><tbody><tr><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr></tbody></table><table><thead><tr><th>X<sub>n</sub></th><th>Y<sub>n</sub></th><th>S<sub>n</sub></th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table><h2 id="6-减法">6. 减法</h2><ul><li>$[X - Y]<em>{c} = [X]</em>{c} + [-Y]_{c}$</li><li>overflow: same to addition</li></ul><p><img src="/img/article_img/ALU8.png" alt="subtraction"></p><h2 id="7-乘法">7. 乘法</h2><ul><li><p>模拟手算乘法的变化：</p><ul><li>每一步都计算部分积</li><li>右移部分积</li><li>如果$Y_{i} = 0$,右移部分积</li></ul></li><li><p>example：<img src="/img/article_img/ALU9.png" alt="example"></p></li><li><p>问题：$[X \times Y]<em>{c} \neq [X]</em>{c} \times [Y]_{c}$; 即补码乘法结果并不等于其直接乘法结果</p></li><li><p>粗略的想法：</p><ul><li>将补码表示的乘数和被乘数转为符号位表示的数</li><li>然后再将计算结果转为补码表示</li></ul></li><li><p>✔️Booth’s algorithm</p><p><img src="/img/article_img/ALU10.png" alt="Booth's algorithm"></p></li><li><p>Booth’s algorithm</p><ol><li>$Y_{0} = 0$</li><li>根据$Y_{i+1}Y_{i}$;来决定是否是$+X | -X$</li><li>右移部分积</li><li>重复2-3的步骤n次</li></ol><p><img src="/img/article_img/ALU11.png" alt="example"></p></li></ul><h2 id="8-除法">8. 除法</h2><ul><li><p>preprocessing:</p><ul><li>$X = 0$ &amp; $Y \neq 0$: 0</li><li>$X \neq 0$ &amp; $Y = 0$: exception</li><li>$X = 0$ &amp; $Y = 0$: NaN</li><li>$X \neq 0$ &amp; $Y \neq 0$: further processing</li></ul></li><li><p>手算除法</p><ul><li>从左到右检查被除数，直到找到大于等于除数的位置</li><li>被除数减去除数，如果部分余大于等于0，商1，否则商0</li><li>右移除数，然后重复上述步骤</li></ul><p><img src="/img/article_img/ALU12.png" alt="example"></p><p><img src="/img/article_img/ALU13.png" alt=""></p></li><li><p>ALU除法步骤</p><ul><li>扩展被除数，增加n位符号位在前面，分别存储在余数和商寄存器中</li><li>左移余数和商，判断余数是否足够大<ul><li>足够大：做减法，然后设置商1</li><li>不够大：设置商0</li></ul></li><li>重复上述步骤</li><li>如果被除数和除数的符号不同，对计算的商取补就是真正结果</li><li>余数在余数寄存器中</li></ul></li><li><p>这种除法的问题❌：</p><ul><li>回复余数的代价太高了，加减做了多次</li></ul></li><li><p>解决方法✔️: 不去恢复商</p><ul><li>只考虑减法：<ul><li>如果余数足够大：左移后直接减除数</li><li>不够大：左移后加上除数</li></ul></li></ul></li></ul><h2 id="9-另一种除法">9. 另一种除法</h2><p>1.步骤：</p><ul><li>向扩展n位，分别存储在余数和商中</li><li>如果除数和被除数符号相同，做减法，否则做加法<ul><li>如果余数和除数的符号相同，商1；否则商0</li></ul></li><li>如果左移后的余数和除数符号相同，做减法；否则做加法<ul><li>如果新的余数符号和除数符号相同，商1；否则商0</li></ul></li><li>重复上述步骤</li></ul><ol start="2"><li>对商的修正，如果商是负的就加上1</li><li>对除数的修正，如果符号不同的，如果除数和被除数符号是否相同，如果相同，我们需要减去除数。</li><li>还要看余数是否和除数相同，如果相同要进行处理</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数的表示</title>
    <link href="/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
    <url>/2020/12/17/%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h1>数的表示</h1><h2 id="1-二进制表示">1. 二进制表示</h2><ol><li>为了表示多个数值，必须对多个位进行组合<ul><li>如果有k位，最多能区分出$2^{k}$个不同的值</li></ul></li></ol><h2 id="2-整数类型：">2. 整数类型：</h2><ul><li>无符号整数</li><li>有符号整数： 原码、反码、补码<ul><li>原码和反码在进行加法运算时都会造成不必要的硬件需求，于是出现了补码</li></ul></li></ul><ol><li><p>补码表示：</p><p>$ [X]<em>{c} = X</em>{n}X_{n-1}…X_{2}X_{1} $</p><p>=&gt; $X = -X_{n}*2^{n-1} + … + X_{2} * 2^{1} + X_{1} * 2^{0} =&gt; (-2^{n-1} &lt;= X&lt;= 2^{n-1} - 1) $</p></li></ol><h2 id="3-浮点数表示">3. 浮点数表示</h2><ol><li>实数表示（科学计数法）</li><li><strong>定点表示法</strong>的值的范围极大的被限制了</li><li>科学计数法: $\pm S*B^{\pm E}$<ul><li>$\pm$: plus or minus</li><li>S: significant</li><li>B: base</li><li>E: exponent</li></ul></li><li><img src="/img/article_img/compute1.png" alt="representation"></li><li>规格化的数：<ul><li>任何一个浮点数都能表示为多个式子：$0.110 \times 2^{5}, 110 \times 2^{2}$</li><li>规格化表示：$\pm 1.bbb…b \times 2^{\pm E}$</li><li>符号位：第一位</li><li>第一位有效数字是 1 ；不需要保存在有效字段中</li><li>真正的$e = E - 127$</li><li>基是2</li></ul></li><li><img src="/img/article_img/compute2.png" alt="value range"></li><li>精度和范围之间有一个平衡：<ul><li>增加exponent的位数，意味着减少S的位数，即扩大表示范围-&gt;精度减少；反之亦然</li></ul></li><li>使用更大的基底？<ul><li>获得了更大的表示范围，同时也会减小精度</li></ul></li></ol><h2 id="4-IEEE-Standard-754">4. IEEE Standard 754</h2><ul><li>确定了32位/64位浮点数的格式</li><li><img src="/img/article_img/compute3.png" alt="format"></li><li>确定了两种扩展方式<ul><li>包括了指数域和有效值域的扩展</li><li>减少了高度交换数据带来的错误和中间溢出</li><li><img src="/img/article_img/compute4.png" alt="interpretation"></li></ul></li></ul><h2 id="5-十进制表示">5. 十进制表示</h2><ul><li>浮点数的算术问题：<ul><li>精度的限制</li><li>高代价的转换</li><li>应用需求：<ul><li>计算长的字符串表示的数字、可计算的</li></ul></li><li>解决方案：<ul><li>使用4位2进制表示0，1，…，9（BCD, Binary-Coded Decimal)</li></ul></li></ul></li><li>Natural Binary Coded Decimal (NBCD, 8421code)<ul><li>0 - 9: 0000 - 1001</li><li>sign:<ul><li>p: 1100/0</li><li>n: 1101/1</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机功能和互连的顶层视图</title>
    <link href="/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/"/>
    <url>/2020/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8A%9F%E8%83%BD%E5%92%8C%E4%BA%92%E8%BF%9E%E7%9A%84%E9%A1%B6%E5%B1%82%E8%A7%86%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1>计算机功能和互连的顶层视图</h1><p><img src="/img/article_img/top_view1.png" alt="Top level view"></p><h1>1. 计算机元素</h1><ol><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li><li>执行指令的顺序是从当前指令到下一个，除非显式的修改</li></ol><h3 id="1-Memory">1. Memory</h3><ol><li>单个的存储器<ul><li>数据和指令存在一个单独的读写存储器中</li><li>存储器中的内容依据位置寻址无关于数据类型</li></ul></li></ol><p><img src="/img/article_img/top_view2.png" alt="Memory"></p><ol start="2"><li>问题：数据在CPU和主存中传输的速度远远的慢于CPU执行的速度</li></ol><p><img src="/img/article_img/top_view3.png" alt="Memory wall"></p><ol start="3"><li><p>解决方法：</p><ul><li>增加一个cache或者其他的缓冲装置来减少CPU对主存的访问频率</li><li>增加一次传输的数据宽度</li></ul></li><li><p>约束：</p><ul><li>容量：越大越好</li><li>速度：能够跟得上处理器</li><li>价格：相对于其他组件合理</li></ul></li><li><p>约束之间的关系：</p><ul><li>更短的访问时间、每位数据的开销更大</li></ul></li><li><p>需求：</p><ul><li>大容量的数据存储</li><li>高速度的访问性能</li></ul></li><li><p>解决方案：</p><ul><li>采用一种层次结构而不是单个的存储器</li></ul></li></ol><p><img src="/img/article_img/top_view4.png" alt="hierarchy"></p><h3 id="2-I-O">2. I/O</h3><ol><li><p>在外设和CPU、主存之间交换数据</p></li><li><p>问题：I/O的性能跟不上CPU的执行速度</p></li></ol><p><img src="/img/article_img/top_view5.png" alt="I/O performance"></p><ol start="3"><li>解决方法：<ul><li>缓冲机制</li><li>新的接口技术</li></ul></li></ol><h3 id="3-CPU">3. CPU</h3><ol><li><p>从一条执行到下一条，除非发生显示的改变</p></li><li><p>问题：CPU会经常出于空闲状态等待I/O设备读写完成</p></li><li><p>解决方法：</p><ul><li><p>中断：其他设备可以中断正常的执行过程的机制</p></li><li><p>中断检测：在指令周期里加上一个中断周期</p><p><img src="/img/article_img/top_view6.png" alt="interrupt detection"></p></li></ul></li><li><p>多级中断：</p><ul><li><img src="/img/article_img/top_view7.png" alt="sequential interrupt processing"></li><li><img src="/img/article_img/top_view8.png" alt="nested interrupt processing"></li></ul></li></ol><p><img src="/img/article_img/top_view9.png" alt="theoretical max performance"></p><h3 id="4-Bus">4. Bus</h3><ol><li>总线是一种连接多个设备的数据传输通路</li></ol><p><img src="/img/article_img/top_view10.png" alt="interconnection solution"></p><ol start="2"><li>数据传输类型：任何总线都可以被分为三种类型<ul><li>数据线：在系统模块中传输数据</li><li>地址线：指定数据源或接收数据的端口，也就是传输地址</li><li>控制线：控制设备对数据线地址线上的内容的读取</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>概论</title>
    <link href="/2020/12/16/%E6%A6%82%E8%AE%BA/"/>
    <url>/2020/12/16/%E6%A6%82%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1>概论</h1><h3 id="1-结构和组织">1. 结构和组织</h3><ul><li>计算机结构：对程序员可见的系统属性，这些属性直接决定了程序的逻辑执行<ul><li>指令集、数据类型、输入输出机制、寻址技术</li></ul></li><li>计算机组成：实现结构规范的操作单元及其互连<ul><li>硬件细节，如控制信号、计算机和外设的接口以及存储器使用的技术</li></ul></li></ul><h2 id="2-冯诺伊曼机">2. 冯诺伊曼机</h2><ul><li>组成部分：<ul><li>存储器：地址和存储的内容</li><li>处理单元：执行信息的实际处理</li><li>控制单元：指挥信息的处理</li><li>输入设备：将信息送入计算机中</li><li>输出设备：将处理结果以某种形式显示在计算机外</li></ul></li></ul><p><img src="/img/article_img/intro1.png" alt="冯诺依曼机结构图"></p><ul><li>重要思想：存储程序，及把数中据和程序存储到计算机中</li></ul><h2 id="3-摩尔定律">3. 摩尔定律</h2><ul><li>内容：单芯片上包含的晶体管数量每年/18个月翻一番</li><li>影响：<ul><li>因为单片芯片的价格不变而导致芯片的逻辑电路和存储器电路成本显著下降</li><li>更小的体积使得更容易放置在各种环境中</li><li>更短的电路提高了芯片的工作速度</li><li>减少了电能的消耗和冷却的要求</li><li>集成电路上的连接比焊接更加可靠，由于芯片电路的增加，减少了芯片之间的连接。</li></ul></li></ul><p><img src="/img/article_img/intro2.png" alt="data process"></p><h2 id="4-计算机性能">4. 计算机性能</h2><ul><li>重要参数：外观、价格、大小、安全性、稳定性、续航</li><li>用来评估的一些标准：<ul><li>CPU： speed</li><li>Memory：capacity、speed</li><li>I/O：capacity、speed</li></ul></li></ul><p><strong>main goal/driver</strong>： increase of CPU speed</p><h2 id="5-CPU性能">5. CPU性能</h2><ul><li><p>系统时钟：</p><ul><li>时钟频率/时钟速度：一秒钟内计算运转的周期数</li><li>clock cycle/clock tick：单次CPU的脉冲/时钟称为一个时钟周期/时钟滴答声</li><li>周期时间：两次脉冲间的时间</li><li>处理器的速度由时钟产生的脉冲频率来指示，用每秒周期数/赫兹数测量</li></ul></li><li><p>指令执行速度：</p><ul><li>处理器由时钟驱动，时钟固定频率为$f$或等价为固定时钟周期$t$, $t = 1/ f$</li><li>$I_{c}$: 一个程序的指令条数</li><li>$CPI(average cycle per instruction)$:每条指令的平均周期数</li><li>$CPI_{i}$: $i$类型执行所需周期数；$I_{i}$：某一给定程序中所执行的$i$类型指令的条数</li><li><img src="/img/article_img/intro3.png" alt="CPI"></li><li>处理器执行完一个给定的程序所需的时间$T = I_{c} * CPI * t$</li><li><img src="/img/article_img/intro4.png" alt="T"></li><li><img src="/img/article_img/intro5.png" alt="MIPS"></li><li>$R_{i}$时第i个程序高级语言指令执行的速度</li><li><img src="/img/article_img/intro6.png" alt="平均结果"></li></ul></li><li><p><strong>基本来说，用户更加关心系统的执行时间，而非它的执行速度。如果我们获得了各种测试程序的指令执行速度的算术平均值，那么我们就一定能得到一个与执行时间倒数之和成正比的结果，但这不与执行时间之和成反比。</strong></p></li><li><p><strong>指令执行速度的算术平均值并不能准确地刻画执行时间；另一方面，指令执行速度的调和平均值是平均执行时间的倒数</strong></p></li><li><p>阿姆达尔定律：</p><ul><li><p>考虑系统性能，人们会通过改变技术/设计来提高性能，如并行处理器、cache的使用、高速I/O访问等。</p></li><li><p>但之加速技术/设计的一个方面并不能很好的提高性能的相应改善。</p></li><li><p>一个程序在多处理器上运行与单处理器上运行的加速比：</p><p>假设一个程序有$f$可以无限并行，无调度负载；$(1-f)$只能串行；$T_{sin}$:单个处理器上运行的时间；$T_{n}$:n个处理器系统上运行的时间；则</p><p>$speedup = T_{sin} / T_{n} = [T(1-f) + Tf] / [T(1-f) + Tf/ n] = 1 / [1-f + f / n]$</p><ol><li>f非常小，使用并行处理器有一些影响</li><li>n的增大，加速比被限制</li></ol></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache存储器</title>
    <link href="/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <url>/2020/12/16/Cache%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1>Cache存储器</h1><h2 id="1-为什么使用Cache？">1. 为什么使用Cache？</h2><ol><li>内存墙的存在（内存性能严重限制CPU性能的发挥）</li></ol><h2 id="2-解决内存墙问题的方法">2. 解决内存墙问题的方法</h2><ol><li>同时使用速度快容量小的Cache与速度慢容量大的存储块</li><li>cache包含主存一部分内存的副本</li><li>cache位于CPU和主存之间，或者位于CPU内部</li></ol><h2 id="3-Cache如何工作得？">3. Cache如何工作得？</h2><ul><li>check：当处理器需要读取一个数据时，先去cache里检查一下是否在cache里</li><li>hit：如果在，直接将这个数据传给处理器</li><li>miss：如果不在，从主存中将包括这个数据的固定大小的块写进cache，并把需要的数据传给处理器</li></ul><p><img src="/img/article_img/cache1.png" alt="cache workFlow"></p><h2 id="4-cache工作流程的一些问题">4. cache工作流程的一些问题</h2><ul><li>如何确定一个数据是否在cache里？<ul><li>冯诺依曼计算机结构确定“无论什么数据都是以相同的方式寻址”</li><li>cache包含一个tag用来确定cache的某一行对应主存的那一部分</li><li>内存中的数据是由标签来进行指向的，而不是依据数据类型进行访问</li></ul></li><li>为什么在cache-miss时是从主存中读取一个块而不是一个字？<ul><li>因为程序的局部性原理</li><li>在程序执行过程中，处理器会倾向于向一块地方集中的访问数据</li><li>局部性分为：<ul><li>时间局部性</li><li>空间局部性</li><li>顺序访问（数组之类的）</li></ul></li></ul></li></ul><p><img src="/img/article_img/cache2.png" alt="temporal locality"></p><p><img src="/img/article_img/cache3.png" alt="spatial locality"></p><h2 id="5-把数据搬到Cache">5. 把数据搬到Cache</h2><ul><li>使用时间局部性</li><li>经典的cache组织</li></ul><p><img src="/img/article_img/cache4.png" alt="typical cache organization"></p><h2 id="6-一次搬用一整块内容而不是一个字">6. 一次搬用一整块内容而不是一个字</h2><ul><li>使用空间局部性原理</li><li>cache结构</li></ul><p><img src="/img/article_img/cache5.png" alt="cache structure"></p><h2 id="7-同比起来，使用cache会多更多的操作，为什么能节省时间呢？">7. 同比起来，使用cache会多更多的操作，为什么能节省时间呢？</h2><ul><li>访问cache的速度比访问内存的速度快很多</li><li>由于局部性原理的存在，cache的命中率会比较高</li><li>一次搬用一个块的数据比多次搬用一个字的时间少</li></ul><h2 id="8-平均访问时间">8. 平均访问时间</h2><ul><li><p>假设命中率为$p$，$T_{c}$为访问cache的时间，$T_{m}$是访问存储器的时间，那么平均访问时间为：$T_{A} = pT_{c} + (1-p)(T_{c} + T_{M}) = T_{c} + (1-p)T_{M}$</p></li><li><p>当$p &gt; T_{c} / T_{M}$时，$T_{A} &lt; T_{M}$</p></li><li><p>问题：cache的容量远小于存储器的容量</p></li></ul><h2 id="9-cache设计考虑因素">9. cache设计考虑因素</h2><ul><li>大小</li><li>映射策略</li><li>替换策略</li><li>写策略</li><li>行大小</li><li>数量</li></ul><h2 id="10-Cache-Size">10. Cache Size</h2><ul><li>增加行大小 -&gt; 增加命中率$p$, 同时也会增加cache的访问时间</li><li><img src="/img/article_img/cache6.png" alt="cache_size_hit _ratio"></li></ul><h2 id="11-Mapping-Function">11. Mapping Function</h2><ul><li>用来将主中的块映射到cache行的策略/算法</li><li>一种覆盖cache中哪一行的策略</li><li>映射函数的选择决定了cache行的组织</li><li>类型：<ul><li>直接映射</li><li>全相关映射</li><li>组相关映射</li></ul></li></ul><h4 id="1-直接映射">1. 直接映射</h4><ul><li>将存储器中的块固定的对应于cache中可以用的行中</li><li>$i = j mod C$, $i$:cache行号，$j$:数据块的块号, $C$:cache总行数</li><li>tag：前n位，$n = log_{2}M - log_{2}C$</li></ul><p><img src="/img/article_img/cache7.png" alt="​address​"></p><p><strong>1. 优点</strong>：</p><ul><li>简单</li><li>映射速度快</li><li>检查速度快</li></ul><p><strong>2.缺点</strong>：</p><ul><li>抖动大：当一个程序需要多次交替的访问两个映射在同一行的块，会发生多次的块替换</li></ul><p>comment：适用于大容量的cache</p><h4 id="2-全相关映射">2. 全相关映射</h4><ul><li>允许将存储器中的块映射到cache的任意行</li><li>tag：前n位， $n = log_{2}M$</li></ul><p><img src="/img/article_img/cache8.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>避免了抖动</li></ul><p><strong>2.缺点</strong>：</p><ul><li>复杂的实现</li><li>cache的查询消耗大</li></ul><p>comment：是用于小容量的cache</p><h4 id="3-组相关映射">3. 组相关映射</h4><ul><li>cache被分为$s$个组，每组$k$行。</li><li>$j$为块号，$i = j mod s$，第j块被映射到第i组。</li><li>称为k-路组</li><li>tag：前n位，$n = log_{2}M - log_{2}S$</li></ul><p><img src="/img/article_img/cache9.png" alt="address"></p><p><strong>1. 优点</strong>：</p><ul><li>集成了直接映射和全相关映射的优点</li></ul><p><strong>2. 缺点</strong>：</p><ul><li>同时也集成了直接映射和全相关映射的缺点</li></ul><p>comment：对任意容量的cache在性能上进行了很好的权衡</p><h2 id="12-映射策略的对比">12. 映射策略的对比</h2><h5 id="1-相关性：每个块可能在cache中的行数">1. 相关性：每个块可能在cache中的行数</h5><ul><li>直接映射：1</li><li>全相关映射：C</li><li>组相关映射：k</li></ul><h5 id="2-相关性与性能">2. 相关性与性能</h5><ul><li>相关性越低，命中率越低</li><li>相关性越低，检查速度越快</li><li>相关性越低，tag长度越短</li></ul><h2 id="13-替换策略">13. 替换策略</h2><ol><li><p>当cache的行被填充时，一个新的块需要插入cache，那么此时就可能将cache中已有的块丢弃，也就是替换掉</p></li><li><p>对于直接映射：一个确定的块有且只有一个对应的cache行可以装填</p></li><li><p>对于全相关和组相关映射而言，替换策略是必需的，并且必须通过硬件来实现。</p></li><li><p><strong>最常用的集中替换算法</strong></p><ul><li>least recently use（LRU）-- 最近最少使用</li><li>first in first out（FIFO）-- 先进先出</li><li>least frequently used（LFU）-- 最不经常被使用</li><li>random – 随机</li></ul><h4 id="1-LRU">1. LRU</h4><ul><li>根据最近一次被用到的时间进行排序<ul><li>以二路组为例，我们将一位置为1，则另一位被置为0</li></ul></li><li>替换cache中当前最长时间没被使用的块</li><li>将设最近被使用的块不久还将会被使用</li><li>特别适合二路组关联映射</li></ul><h4 id="2-FIFO">2. FIFO</h4><ul><li>和使用时间关系不大，根据进入cache的时间来排序</li><li>假设越靠后的数据越容易被再次使用到</li><li>实现：循环/循环缓冲技术</li><li>通过计数器来时间（时间戳）</li></ul><h4 id="3-Random">3.Random</h4><ul><li>随机的替换对应的行</li><li>假设每个存储位置都等概率被再次访问到</li></ul></li></ol><h2 id="14-写策略">14. 写策略</h2><ul><li>内存与cache的一致性要求<ul><li>当一个块在cache中被替换时，需要考虑块是否被个别更改可</li></ul></li><li>两种情况：<ul><li>如果没有更改，可以直接替换</li><li>如果更改了，对应在内存中的块需要被更新</li></ul></li><li>两种策略：<ul><li>写入法（write through）</li><li>写回法（write back）</li></ul></li></ul><h4 id="1-写入法">1. 写入法</h4><ul><li><p>当cache中的行发生改变时，立即对内存中对应的块进行更新</p></li><li><p>优点：确保了内存中的数据始终被更新过了</p></li><li><p>缺点：</p><ul><li><p>产生大量的内存访问，出现时间瓶颈</p></li><li><p>减慢了写操作</p></li></ul></li></ul><h4 id="2-写回法">2. 写回法</h4><ul><li>只更新cache中的数据，当这个快被替换或者遇到I/O操作需要对主存这块区域读取数据时，才发生更新</li><li>使用dirty bit/ use bit，来代表是否被修改了</li><li>优点：减少了对内存的写操作</li><li>缺点：内存中对应的内容时过时的，因此当存在I/O操作时，只能允许通过cache进行，因此会造成复杂的电路以及潜在的瓶颈</li></ul><h2 id="15-行大小">15. 行大小</h2><ul><li>当行大小从很小的容量增加到比较大的容量时：<ul><li>命中率提高</li><li>更多有用的数据可以被带入cache</li></ul></li><li>当行大小变的非常大时：<ul><li>命中率提高，但提高的速度明显减慢<ul><li>更大的行，导致cache的行数减少，这将导致频繁的替换</li><li>每个额外的字都会离被需要的字更远，因此更小的可能性会在不久的将来被访问在</li></ul></li></ul></li><li>块大小和命中率之间的关系更加复杂</li></ul><h2 id="16-cache行数量">16. cache行数量</h2><ul><li>unified（统一）：<ul><li>提高指令与数据负载自动平衡的命中率</li><li>只有一个cache需要被设计和实现</li></ul></li><li>split（分隔）：<ul><li>消除指令获取/解码单元和执行单元之间对缓存的争用，这对指令的流水线很重要</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CPU结构和功能</title>
    <link href="/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
    <url>/2020/12/15/CPU%E7%BB%93%E6%9E%84%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h1>CPU结构和功能</h1><h3 id="一、CPU的任务">一、CPU的任务</h3><ul><li>取指令：从存储器（register、main-memory、cache）读取指令</li><li>解释指令：对指令解码，确定要进行的操作</li><li>取数据：指令的执行可能需要从存储器或I/O中读取数据</li><li>处理数据：对数据完成要求的算术/逻辑运算</li><li>写数据：执行的结果可能需要写回存储器或I/O</li></ul><h3 id="二、CPU的要求">二、CPU的要求</h3><ul><li>CPU能暂时的存储部分数据</li><li>CPU必须知道当前执行指令的位置，以便获取下一条指令的位置</li><li>CPU必须在执行指令期间保存指令和数据</li></ul><p><img src="/img/article_img/cpu_structure_function1.jpg" alt="cpu简介图"></p><p><img src="/img/article_img/cpu_structure_function2.jpg" alt="cpu详介图"></p><h3 id="三、寄存器的组成">三、寄存器的组成</h3><h4 id="1-CPU中寄存器主要可以分为两类：">1. CPU中寄存器主要可以分为两类：</h4><ul><li>用户可见寄存器：允许机器语言或者汇编语言的编程人员通过优化寄存器的使用而减少对内存的访问</li><li>控制和状态寄存器：由控制器来控制CPU的操作，并由拥有特权的操作系统程序来控制程序的执行</li></ul><h4 id="2-用户可见寄存器：">2. 用户可见寄存器：</h4><ul><li>通用寄存器：可被程序员指派各种用途</li><li>数据寄存器：用于保存数据，不能用于操作数地址的计算</li><li>地址寄存器：用于可以是自身有某种通用性或者专用性的寻址方式</li><li>标志寄存器：保存条件码、允许程序员读出，但不能更改</li></ul><h4 id="3-寄存器的设计出发点：">3. 寄存器的设计出发点：</h4><ul><li>使用完全通用寄存器还是规定各寄存器的用途</li><li>寄存器的数量</li><li>寄存器的长度</li></ul><h4 id="4-控制和状态寄存器：">4. 控制和状态寄存器：</h4><ul><li>程序计数器（PC）：存放待取指令的地址</li><li>指令寄存器（IR）：存放最近取来的地址</li><li>存储器地址寄存器（MAR）：存放存储器位置的地址</li><li>存储器缓冲寄存器（MBR）：存有将被写入或最近从存储器读出的字</li></ul><h4 id="5-程序状态字（PSW）：">5. 程序状态字（PSW）：</h4><ul><li>符号（sign）：容纳算术运算结果的符号位</li><li>零（zero）：当结果是0时置位</li><li>进位（carry）：操作导致向最高位有向上进位或借位时被置位</li><li>等于（equal）：逻辑结果相等置位</li><li>溢出（overflow）：用于指示算术运算溢出</li><li>中断允许/禁止（interrupt enable/disable）：用于允许/禁止中断</li><li>监管（supervisor）：指出CPU是执行在监管模式还是用户模式</li></ul><h4 id="6-设计控制和状态寄存器组织时考虑的几个因素：">6. 设计控制和状态寄存器组织时考虑的几个因素：</h4><ul><li>考虑对操作系统的支持（某些控制信息专门为控制操作系统使用）</li><li>考虑控制信息在寄存器和存储器之间的分配</li></ul><h4 id="7-指令周期：">7. 指令周期：</h4><ul><li>取指：将下一条指令从存储器中读入CPU</li><li>执行；解释操作码并完成指定操作</li><li>中断：如果中断允许并且有中断发生，则保存当前状态执行中断</li></ul><h4 id="8-间接周期：">8. 间接周期：</h4><ul><li>指令的执行可能涉及到内存中的一个或多个操作数，并且每个操作数都需要内存访问</li><li>如果使用间接地址，需要额外的内存访问</li><li>将间接地址的获取视为一个或多个指令周期</li></ul><p><img src="/img/article_img/cpu_structure_function3.png" alt="指令周期"></p><p><img src="/img/article_img/cpu_structure_function4.png" alt="指令周期状态图"></p><h4 id="9-数据流：">9. 数据流：</h4><ol><li><p><img src="/img/article_img/cpu_structure_function5.png" alt="数据流与取指周期"></p><ul><li>控制器向PC发送请求 -&gt; PC将存有的下一条指令的地址传给MAR -&gt; MAR放到地址总线上</li><li>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号 -&gt; 存储器获取指令地址并将对应的指令放到数据总线上</li><li>MBR从数据总线上获取指令然后传给IR</li></ul></li><li><p><img src="/img/article_img/cpu_structure_function6.png" alt="数据流间接周期"></p><ul><li><p>MBR存储的是指令的地址 -&gt; MBR将地址传给MAR -&gt; MAR将该地址传放到地址总线上</p></li><li><p>控制器将控制信号放到控制总线上 -&gt; 存储器接收信号并读取指令的地址</p></li><li><p>存储器根据地址将对应指令放到数据线上 -&gt; MBR读取指令</p></li></ul><p><img src="/img/article_img/cpu_structure_function7.png" alt=""></p><ul><li>控制器向MAR传送信号 -&gt; MAR将当前数据要保存到的地址放到地址总线上</li><li>控制器向PC传送信号 -&gt; PC将当前要保存的数据传入MBR -&gt; MBR将数据放到数据总线上</li><li>控制器向控制总线上发送信号 -&gt; 存储器读取信号 -&gt; 存储器从地址总线上接收地址，并从数据总线上接收数据</li><li>存储器将数据写入对应的地址</li></ul></li></ol><h3 id="四、指令流水线技术：">四、指令流水线技术：</h3><p><strong>1. 流水线技术</strong>：把制作过程安排在一条装配线上，多个产品能在各个阶段同时被加工</p><p><strong>2. 对指令执行使用流水线技术</strong>：显然能够加快指令的执行，但是使得执行速度翻倍是不可能的，原因如下：</p><ul><li>执行时间一般长于指令的执行（执行指令和取指令都可能使用I/O，所以会产生冲突，一次只能有一个进行）</li><li>条件分支指令使得待取的下一条指令的地址未知（当多条指令执行了一些步骤后，遇到跳转指令，这些指令执行的步骤将会作废）</li></ul><p><strong>3.对指令执行的细分</strong>（为了进一步加速）：</p><ul><li>取指：获取下一条要执行指令到MBR</li><li>译码：解析指令，确定操作码、操作数</li><li>计算操作数：计算源操作数的有效地址</li><li>取操作数：从存储器中读取操作数（寄存器中的数据不需要读取）</li><li>执行：完成指定操作</li><li>写回操作数：将结果写回存储器</li></ul><p><strong>4. 几个限制性能提升的因素</strong>：</p><ul><li>细分的各个阶段时间不完全相等</li><li>遇到条件转移指令时，之前进行的指令会作废</li><li>寄存器和存储器可能产生冲突</li></ul><p><strong>5. 人们认为流水线中阶段越多，执行速度越快？No</strong></p><ul><li>流水线的每一阶段，都会有某些开销设计数据在MBR间的传送，以及各种准备会使得一次指令的总的执行时间边长</li><li>优化流水线的使用和处理存储器及寄存器相关性所需要的控制逻辑总量，会随着流水线阶段数的增长而急剧增长</li><li><strong>锁存延迟</strong>，即流水线阶段之间的缓冲需要一定时间来完成其操作，这也会增加指令周期的时间</li></ul><p><strong>6.流水线性能</strong>：</p><ul><li>$t_{i}$:流水线第$i$段的延迟</li><li>$t_{m}$:最大段延迟</li><li>$k$:指令流水线段数</li><li>$d$:所存延迟</li><li>$t = max[ t_{i} ] + d = t_{m} + d$ -&gt; $t$: 指令流水线周期</li><li>假设$n$条指令没有条件转移的在进行，$T_{k, n} = [ k + (n - 1)] t$表示k段流水线执行n条指令所需的总时间</li><li>完成第一条指令需要k个周期，其余n-1条指令需要n-1个周期</li><li>加速比$S_{k} = T_{1, n} / T_{k, n} = nk / (k + n - 1)$</li></ul>]]></content>
    
    
    <categories>
      
      <category>20COA-NOTES</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机体系结构</tag>
      
      <tag>CS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
